
build/ch.elf:     file format elf32-littlearm


Disassembly of section .text:

08000140 <Reset_Handler>:
 8000140:	b672      	cpsid	i
 8000142:	4823      	ldr	r0, [pc, #140]	; (80001d0 <endfiniloop+0x6>)
 8000144:	f380 8809 	msr	PSP, r0
 8000148:	2002      	movs	r0, #2
 800014a:	f380 8814 	msr	CONTROL, r0
 800014e:	f3bf 8f6f 	isb	sy
 8000152:	f001 fa25 	bl	80015a0 <__core_init>
 8000156:	f000 ff4b 	bl	8000ff0 <__early_init>
 800015a:	f04f 3055 	mov.w	r0, #1431655765	; 0x55555555
 800015e:	491d      	ldr	r1, [pc, #116]	; (80001d4 <endfiniloop+0xa>)
 8000160:	4a1d      	ldr	r2, [pc, #116]	; (80001d8 <endfiniloop+0xe>)

08000162 <msloop>:
 8000162:	4291      	cmp	r1, r2
 8000164:	bf3c      	itt	cc
 8000166:	f841 0b04 	strcc.w	r0, [r1], #4
 800016a:	e7fa      	bcc.n	8000162 <msloop>
 800016c:	491b      	ldr	r1, [pc, #108]	; (80001dc <endfiniloop+0x12>)
 800016e:	4a18      	ldr	r2, [pc, #96]	; (80001d0 <endfiniloop+0x6>)

08000170 <psloop>:
 8000170:	4291      	cmp	r1, r2
 8000172:	bf3c      	itt	cc
 8000174:	f841 0b04 	strcc.w	r0, [r1], #4
 8000178:	e7fa      	bcc.n	8000170 <psloop>
 800017a:	4919      	ldr	r1, [pc, #100]	; (80001e0 <endfiniloop+0x16>)
 800017c:	4a19      	ldr	r2, [pc, #100]	; (80001e4 <endfiniloop+0x1a>)
 800017e:	4b1a      	ldr	r3, [pc, #104]	; (80001e8 <endfiniloop+0x1e>)

08000180 <dloop>:
 8000180:	429a      	cmp	r2, r3
 8000182:	bf3e      	ittt	cc
 8000184:	f851 0b04 	ldrcc.w	r0, [r1], #4
 8000188:	f842 0b04 	strcc.w	r0, [r2], #4
 800018c:	e7f8      	bcc.n	8000180 <dloop>
 800018e:	2000      	movs	r0, #0
 8000190:	4916      	ldr	r1, [pc, #88]	; (80001ec <endfiniloop+0x22>)
 8000192:	4a17      	ldr	r2, [pc, #92]	; (80001f0 <endfiniloop+0x26>)

08000194 <bloop>:
 8000194:	4291      	cmp	r1, r2
 8000196:	bf3c      	itt	cc
 8000198:	f841 0b04 	strcc.w	r0, [r1], #4
 800019c:	e7fa      	bcc.n	8000194 <bloop>
 800019e:	f001 f9b7 	bl	8001510 <__init_ram_areas>
 80001a2:	f001 f9f5 	bl	8001590 <__late_init>
 80001a6:	4c13      	ldr	r4, [pc, #76]	; (80001f4 <endfiniloop+0x2a>)
 80001a8:	4d13      	ldr	r5, [pc, #76]	; (80001f8 <endfiniloop+0x2e>)

080001aa <initloop>:
 80001aa:	42ac      	cmp	r4, r5
 80001ac:	da03      	bge.n	80001b6 <endinitloop>
 80001ae:	f854 1b04 	ldr.w	r1, [r4], #4
 80001b2:	4788      	blx	r1
 80001b4:	e7f9      	b.n	80001aa <initloop>

080001b6 <endinitloop>:
 80001b6:	f000 fc03 	bl	80009c0 <main>
 80001ba:	4c10      	ldr	r4, [pc, #64]	; (80001fc <endfiniloop+0x32>)
 80001bc:	4d10      	ldr	r5, [pc, #64]	; (8000200 <endfiniloop+0x36>)

080001be <finiloop>:
 80001be:	42ac      	cmp	r4, r5
 80001c0:	da03      	bge.n	80001ca <endfiniloop>
 80001c2:	f854 1b04 	ldr.w	r1, [r4], #4
 80001c6:	4788      	blx	r1
 80001c8:	e7f9      	b.n	80001be <finiloop>

080001ca <endfiniloop>:
 80001ca:	f001 b9d9 	b.w	8001580 <__default_exit>
 80001ce:	0000      	.short	0x0000
 80001d0:	20000800 	.word	0x20000800
 80001d4:	20000000 	.word	0x20000000
 80001d8:	20000400 	.word	0x20000400
 80001dc:	20000400 	.word	0x20000400
 80001e0:	08001858 	.word	0x08001858
 80001e4:	20000800 	.word	0x20000800
 80001e8:	20000800 	.word	0x20000800
 80001ec:	20000800 	.word	0x20000800
 80001f0:	20000a60 	.word	0x20000a60
 80001f4:	08000140 	.word	0x08000140
 80001f8:	08000140 	.word	0x08000140
 80001fc:	08000140 	.word	0x08000140
 8000200:	08000140 	.word	0x08000140
	...

08000210 <_port_switch>:
 8000210:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8000214:	f8c1 d00c 	str.w	sp, [r1, #12]
 8000218:	68c3      	ldr	r3, [r0, #12]
 800021a:	469d      	mov	sp, r3
 800021c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08000220 <_port_thread_start>:
 8000220:	2300      	movs	r3, #0
 8000222:	f383 8811 	msr	BASEPRI, r3
 8000226:	4628      	mov	r0, r5
 8000228:	47a0      	blx	r4
 800022a:	2000      	movs	r0, #0
 800022c:	f001 f948 	bl	80014c0 <chThdExit>

08000230 <_port_switch_from_isr>:
 8000230:	f000 ff5e 	bl	80010f0 <chSchDoReschedule>

08000234 <_port_exit_from_isr>:
 8000234:	df00      	svc	0
 8000236:	e7fe      	b.n	8000236 <_port_exit_from_isr+0x2>
	...

08000240 <_idle_thread>:
 *          that this thread is executed only if there are no other ready
 *          threads in the system.
 *
 * @param[in] p         the thread parameter, unused in this scenario
 */
static void _idle_thread(void *p) {
 8000240:	e7fe      	b.n	8000240 <_idle_thread>
 8000242:	bf00      	nop
	...

08000250 <chCoreAlloc>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @api
 */
void *chCoreAlloc(size_t size) {
 8000250:	b410      	push	{r4}

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8000252:	2320      	movs	r3, #32
 8000254:	f383 8811 	msr	BASEPRI, r3

  chDbgCheckClassI();

  size = MEM_ALIGN_NEXT(size);
  /*lint -save -e9033 [10.8] The cast is safe.*/
  if ((size_t)(endmem - nextmem) < size) {
 8000258:	4c09      	ldr	r4, [pc, #36]	; (8000280 <chCoreAlloc+0x30>)
 800025a:	4b0a      	ldr	r3, [pc, #40]	; (8000284 <chCoreAlloc+0x34>)
 800025c:	6822      	ldr	r2, [r4, #0]
 800025e:	6819      	ldr	r1, [r3, #0]
void *chCoreAllocI(size_t size) {
  void *p;

  chDbgCheckClassI();

  size = MEM_ALIGN_NEXT(size);
 8000260:	1dc3      	adds	r3, r0, #7
 8000262:	f023 0307 	bic.w	r3, r3, #7
  /*lint -save -e9033 [10.8] The cast is safe.*/
  if ((size_t)(endmem - nextmem) < size) {
 8000266:	1a89      	subs	r1, r1, r2
 8000268:	428b      	cmp	r3, r1
  /*lint -restore*/
    return NULL;
  }
  p = nextmem;
  nextmem += size;
 800026a:	bf9d      	ittte	ls
 800026c:	189b      	addls	r3, r3, r2
 800026e:	6023      	strls	r3, [r4, #0]

  return p;
 8000270:	4610      	movls	r0, r2

  size = MEM_ALIGN_NEXT(size);
  /*lint -save -e9033 [10.8] The cast is safe.*/
  if ((size_t)(endmem - nextmem) < size) {
  /*lint -restore*/
    return NULL;
 8000272:	2000      	movhi	r0, #0
 8000274:	2300      	movs	r3, #0
 8000276:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  p = chCoreAllocI(size);
  chSysUnlock();

  return p;
}
 800027a:	bc10      	pop	{r4}
 800027c:	4770      	bx	lr
 800027e:	bf00      	nop
 8000280:	200009c4 	.word	0x200009c4
 8000284:	200009bc 	.word	0x200009bc
	...

08000290 <notify1>:

#if STM32_SERIAL_USE_USART1 || defined(__DOXYGEN__)
static void notify1(io_queue_t *qp) {

  (void)qp;
  USART1->CR1 |= USART_CR1_TXEIE;
 8000290:	4a02      	ldr	r2, [pc, #8]	; (800029c <notify1+0xc>)
 8000292:	68d3      	ldr	r3, [r2, #12]
 8000294:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8000298:	60d3      	str	r3, [r2, #12]
 800029a:	4770      	bx	lr
 800029c:	40013800 	.word	0x40013800

080002a0 <_port_irq_epilogue>:
 80002a0:	2320      	movs	r3, #32
 80002a2:	f383 8811 	msr	BASEPRI, r3
 * @brief   Exception exit redirection to _port_switch_from_isr().
 */
void _port_irq_epilogue(void) {

  port_lock_from_isr();
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
 80002a6:	4b0f      	ldr	r3, [pc, #60]	; (80002e4 <_port_irq_epilogue+0x44>)
 80002a8:	685b      	ldr	r3, [r3, #4]
 80002aa:	f413 6300 	ands.w	r3, r3, #2048	; 0x800
 80002ae:	d102      	bne.n	80002b6 <_port_irq_epilogue+0x16>
 80002b0:	f383 8811 	msr	BASEPRI, r3
 80002b4:	4770      	bx	lr
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 80002b6:	f3ef 8309 	mrs	r3, PSP
    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;

    /* Setting up a fake XPSR register value.*/
    ctxp->xpsr = (regarm_t)0x01000000;
 80002ba:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
 80002be:	f843 2c04 	str.w	r2, [r3, #-4]

    \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 80002c2:	f1a3 0220 	sub.w	r2, r3, #32
 80002c6:	f382 8809 	msr	PSP, r2
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
  tprio_t p1 = firstprio(&ch.rlist.r_queue);
 80002ca:	4a07      	ldr	r2, [pc, #28]	; (80002e8 <_port_irq_epilogue+0x48>)
 80002cc:	6811      	ldr	r1, [r2, #0]
  tprio_t p2 = currp->p_prio;
 80002ce:	6992      	ldr	r2, [r2, #24]
    /* Writing back the modified PSP value.*/
    __set_PSP((uint32_t)ctxp);

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
 80002d0:	6889      	ldr	r1, [r1, #8]
 80002d2:	6892      	ldr	r2, [r2, #8]
 80002d4:	4291      	cmp	r1, r2
      /* Preemption is required we need to enforce a context switch.*/
      ctxp->pc = (regarm_t)_port_switch_from_isr;
 80002d6:	bf8c      	ite	hi
 80002d8:	4a04      	ldrhi	r2, [pc, #16]	; (80002ec <_port_irq_epilogue+0x4c>)
    }
    else {
      /* Preemption not required, we just need to exit the exception
         atomically.*/
      ctxp->pc = (regarm_t)_port_exit_from_isr;
 80002da:	4a05      	ldrls	r2, [pc, #20]	; (80002f0 <_port_irq_epilogue+0x50>)
 80002dc:	f843 2c08 	str.w	r2, [r3, #-8]
 80002e0:	4770      	bx	lr
 80002e2:	bf00      	nop
 80002e4:	e000ed00 	.word	0xe000ed00
 80002e8:	20000800 	.word	0x20000800
 80002ec:	08000231 	.word	0x08000231
 80002f0:	08000234 	.word	0x08000234
	...

08000300 <VectorB0>:
 * @brief   TIM2 interrupt handler.
 * @details This interrupt is used for system tick in free running mode.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(ST_HANDLER) {
 8000300:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  OSAL_IRQ_PROLOGUE();

  /* Note, under rare circumstances an interrupt can remain latched even if
     the timer SR register has been cleared, in those cases the interrupt
     is simply ignored.*/
  if ((STM32_ST_TIM->SR & TIM_SR_CC1IF) != 0U) {
 8000304:	f04f 4480 	mov.w	r4, #1073741824	; 0x40000000
 8000308:	6923      	ldr	r3, [r4, #16]
 800030a:	079b      	lsls	r3, r3, #30
 800030c:	d403      	bmi.n	8000316 <VectorB0+0x16>
    osalOsTimerHandlerI();
    osalSysUnlockFromISR();
  }

  OSAL_IRQ_EPILOGUE();
}
 800030e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    osalSysLockFromISR();
    osalOsTimerHandlerI();
    osalSysUnlockFromISR();
  }

  OSAL_IRQ_EPILOGUE();
 8000312:	f7ff bfc5 	b.w	80002a0 <_port_irq_epilogue>

  /* Note, under rare circumstances an interrupt can remain latched even if
     the timer SR register has been cleared, in those cases the interrupt
     is simply ignored.*/
  if ((STM32_ST_TIM->SR & TIM_SR_CC1IF) != 0U) {
    STM32_ST_TIM->SR = 0U;
 8000316:	2700      	movs	r7, #0
 8000318:	6127      	str	r7, [r4, #16]

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 800031a:	2520      	movs	r5, #32
 800031c:	f385 8811 	msr	BASEPRI, r5
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  virtual_timer_t *vtp;
  systime_t now, delta;

  /* First timer to be processed.*/
  vtp = ch.vtlist.vt_next;
 8000320:	4e1e      	ldr	r6, [pc, #120]	; (800039c <VectorB0+0x9c>)
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8000322:	6a62      	ldr	r2, [r4, #36]	; 0x24

  /* All timers within the time window are triggered and removed,
     note that the loop is stopped by the timers header having
     "ch.vtlist.vt_delta == (systime_t)-1" which is greater than
     all deltas.*/
  while (vtp->vt_delta <= (systime_t)(now - ch.vtlist.vt_lasttime)) {
 8000324:	f8b6 e026 	ldrh.w	lr, [r6, #38]	; 0x26
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  virtual_timer_t *vtp;
  systime_t now, delta;

  /* First timer to be processed.*/
  vtp = ch.vtlist.vt_next;
 8000328:	69f3      	ldr	r3, [r6, #28]
 800032a:	b290      	uxth	r0, r2

  /* All timers within the time window are triggered and removed,
     note that the loop is stopped by the timers header having
     "ch.vtlist.vt_delta == (systime_t)-1" which is greater than
     all deltas.*/
  while (vtp->vt_delta <= (systime_t)(now - ch.vtlist.vt_lasttime)) {
 800032c:	ebce 0100 	rsb	r1, lr, r0
 8000330:	891a      	ldrh	r2, [r3, #8]
 8000332:	b289      	uxth	r1, r1
 8000334:	4291      	cmp	r1, r2
 8000336:	f106 081c 	add.w	r8, r6, #28
 800033a:	d31b      	bcc.n	8000374 <VectorB0+0x74>
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.vt_lasttime += vtp->vt_delta;

    vtp->vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
 800033c:	6819      	ldr	r1, [r3, #0]
     all deltas.*/
  while (vtp->vt_delta <= (systime_t)(now - ch.vtlist.vt_lasttime)) {
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.vt_lasttime += vtp->vt_delta;
 800033e:	4472      	add	r2, lr
    ch.vtlist.vt_next = vtp->vt_next;
    fn = vtp->vt_func;
    vtp->vt_func = NULL;

    /* if the list becomes empty then the timer is stopped.*/
    if (ch.vtlist.vt_next == (virtual_timer_t *)&ch.vtlist) {
 8000340:	4541      	cmp	r1, r8
     all deltas.*/
  while (vtp->vt_delta <= (systime_t)(now - ch.vtlist.vt_lasttime)) {
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.vt_lasttime += vtp->vt_delta;
 8000342:	84f2      	strh	r2, [r6, #38]	; 0x26

    vtp->vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
    ch.vtlist.vt_next = vtp->vt_next;
    fn = vtp->vt_func;
 8000344:	68da      	ldr	r2, [r3, #12]
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.vt_lasttime += vtp->vt_delta;

    vtp->vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
 8000346:	f8c1 8004 	str.w	r8, [r1, #4]
    ch.vtlist.vt_next = vtp->vt_next;
 800034a:	61f1      	str	r1, [r6, #28]
    fn = vtp->vt_func;
    vtp->vt_func = NULL;
 800034c:	60df      	str	r7, [r3, #12]
 *
 * @notapi
 */
static inline void st_lld_stop_alarm(void) {

  STM32_ST_TIM->DIER = 0;
 800034e:	bf08      	it	eq
 8000350:	60e7      	streq	r7, [r4, #12]
 8000352:	f387 8811 	msr	BASEPRI, r7
       and in order to give a preemption chance to higher priority
       interrupts.*/
    chSysUnlockFromISR();

    /* The callback is invoked outside the kernel critical zone.*/
    fn(vtp->vt_par);
 8000356:	6918      	ldr	r0, [r3, #16]
 8000358:	4790      	blx	r2
 800035a:	f385 8811 	msr	BASEPRI, r5
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 800035e:	6a62      	ldr	r2, [r4, #36]	; 0x24

  /* All timers within the time window are triggered and removed,
     note that the loop is stopped by the timers header having
     "ch.vtlist.vt_delta == (systime_t)-1" which is greater than
     all deltas.*/
  while (vtp->vt_delta <= (systime_t)(now - ch.vtlist.vt_lasttime)) {
 8000360:	f8b6 e026 	ldrh.w	lr, [r6, #38]	; 0x26
       of the list.*/
    chSysLockFromISR();

    /* Next element in the list, the current time could have advanced so
       recalculating the time window.*/
    vtp = ch.vtlist.vt_next;
 8000364:	69f3      	ldr	r3, [r6, #28]
 8000366:	b290      	uxth	r0, r2

  /* All timers within the time window are triggered and removed,
     note that the loop is stopped by the timers header having
     "ch.vtlist.vt_delta == (systime_t)-1" which is greater than
     all deltas.*/
  while (vtp->vt_delta <= (systime_t)(now - ch.vtlist.vt_lasttime)) {
 8000368:	ebce 0100 	rsb	r1, lr, r0
 800036c:	891a      	ldrh	r2, [r3, #8]
 800036e:	b289      	uxth	r1, r1
 8000370:	428a      	cmp	r2, r1
 8000372:	d9e3      	bls.n	800033c <VectorB0+0x3c>
    vtp = ch.vtlist.vt_next;
    now = chVTGetSystemTimeX();
  }

  /* if the list is empty, nothing else to do.*/
  if (ch.vtlist.vt_next == (virtual_timer_t *)&ch.vtlist) {
 8000374:	4543      	cmp	r3, r8
 8000376:	d00a      	beq.n	800038e <VectorB0+0x8e>
    return;
  }

  /* Recalculating the next alarm time.*/
  delta = ch.vtlist.vt_lasttime + vtp->vt_delta - now;
 8000378:	4472      	add	r2, lr
 800037a:	1a12      	subs	r2, r2, r0
 800037c:	b292      	uxth	r2, r2
  if (delta < (systime_t)CH_CFG_ST_TIMEDELTA) {
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
 800037e:	2a01      	cmp	r2, #1
 8000380:	bf98      	it	ls
 8000382:	2202      	movls	r2, #2
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8000384:	4402      	add	r2, r0
 8000386:	b292      	uxth	r2, r2
 8000388:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800038c:	635a      	str	r2, [r3, #52]	; 0x34
 800038e:	2300      	movs	r3, #0
 8000390:	f383 8811 	msr	BASEPRI, r3
    osalOsTimerHandlerI();
    osalSysUnlockFromISR();
  }

  OSAL_IRQ_EPILOGUE();
}
 8000394:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    osalSysLockFromISR();
    osalOsTimerHandlerI();
    osalSysUnlockFromISR();
  }

  OSAL_IRQ_EPILOGUE();
 8000398:	f7ff bf82 	b.w	80002a0 <_port_irq_epilogue>
 800039c:	20000800 	.word	0x20000800

080003a0 <Vector84>:
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH7_HANDLER) {

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM7);
 80003a0:	4b09      	ldr	r3, [pc, #36]	; (80003c8 <Vector84+0x28>)
 80003a2:	6819      	ldr	r1, [r3, #0]
 80003a4:	f3c1 6103 	ubfx	r1, r1, #24, #4
 80003a8:	b159      	cbz	r1, 80003c2 <Vector84+0x22>
 80003aa:	4808      	ldr	r0, [pc, #32]	; (80003cc <Vector84+0x2c>)
/**
 * @brief   DMA1 stream 7 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH7_HANDLER) {
 80003ac:	b510      	push	{r4, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM7);
 80003ae:	6b04      	ldr	r4, [r0, #48]	; 0x30
 80003b0:	060a      	lsls	r2, r1, #24
 80003b2:	605a      	str	r2, [r3, #4]
 80003b4:	b10c      	cbz	r4, 80003ba <Vector84+0x1a>
 80003b6:	6b40      	ldr	r0, [r0, #52]	; 0x34
 80003b8:	47a0      	blx	r4

  OSAL_IRQ_EPILOGUE();
}
 80003ba:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM7);

  OSAL_IRQ_EPILOGUE();
 80003be:	f7ff bf6f 	b.w	80002a0 <_port_irq_epilogue>
 80003c2:	f7ff bf6d 	b.w	80002a0 <_port_irq_epilogue>
 80003c6:	bf00      	nop
 80003c8:	40026000 	.word	0x40026000
 80003cc:	20000950 	.word	0x20000950

080003d0 <Vector80>:
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH6_HANDLER) {

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM6);
 80003d0:	4b09      	ldr	r3, [pc, #36]	; (80003f8 <Vector80+0x28>)
 80003d2:	6819      	ldr	r1, [r3, #0]
 80003d4:	f3c1 5103 	ubfx	r1, r1, #20, #4
 80003d8:	b159      	cbz	r1, 80003f2 <Vector80+0x22>
 80003da:	4808      	ldr	r0, [pc, #32]	; (80003fc <Vector80+0x2c>)
/**
 * @brief   DMA1 stream 6 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH6_HANDLER) {
 80003dc:	b510      	push	{r4, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM6);
 80003de:	6a84      	ldr	r4, [r0, #40]	; 0x28
 80003e0:	050a      	lsls	r2, r1, #20
 80003e2:	605a      	str	r2, [r3, #4]
 80003e4:	b10c      	cbz	r4, 80003ea <Vector80+0x1a>
 80003e6:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
 80003e8:	47a0      	blx	r4

  OSAL_IRQ_EPILOGUE();
}
 80003ea:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM6);

  OSAL_IRQ_EPILOGUE();
 80003ee:	f7ff bf57 	b.w	80002a0 <_port_irq_epilogue>
 80003f2:	f7ff bf55 	b.w	80002a0 <_port_irq_epilogue>
 80003f6:	bf00      	nop
 80003f8:	40026000 	.word	0x40026000
 80003fc:	20000950 	.word	0x20000950

08000400 <Vector7C>:
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH5_HANDLER) {

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM5);
 8000400:	4b09      	ldr	r3, [pc, #36]	; (8000428 <Vector7C+0x28>)
 8000402:	6819      	ldr	r1, [r3, #0]
 8000404:	f3c1 4103 	ubfx	r1, r1, #16, #4
 8000408:	b159      	cbz	r1, 8000422 <Vector7C+0x22>
 800040a:	4808      	ldr	r0, [pc, #32]	; (800042c <Vector7C+0x2c>)
/**
 * @brief   DMA1 stream 5 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH5_HANDLER) {
 800040c:	b510      	push	{r4, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM5);
 800040e:	6a04      	ldr	r4, [r0, #32]
 8000410:	040a      	lsls	r2, r1, #16
 8000412:	605a      	str	r2, [r3, #4]
 8000414:	b10c      	cbz	r4, 800041a <Vector7C+0x1a>
 8000416:	6a40      	ldr	r0, [r0, #36]	; 0x24
 8000418:	47a0      	blx	r4

  OSAL_IRQ_EPILOGUE();
}
 800041a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM5);

  OSAL_IRQ_EPILOGUE();
 800041e:	f7ff bf3f 	b.w	80002a0 <_port_irq_epilogue>
 8000422:	f7ff bf3d 	b.w	80002a0 <_port_irq_epilogue>
 8000426:	bf00      	nop
 8000428:	40026000 	.word	0x40026000
 800042c:	20000950 	.word	0x20000950

08000430 <Vector78>:
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH4_HANDLER) {

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM4);
 8000430:	4b09      	ldr	r3, [pc, #36]	; (8000458 <Vector78+0x28>)
 8000432:	6819      	ldr	r1, [r3, #0]
 8000434:	f3c1 3103 	ubfx	r1, r1, #12, #4
 8000438:	b159      	cbz	r1, 8000452 <Vector78+0x22>
 800043a:	4808      	ldr	r0, [pc, #32]	; (800045c <Vector78+0x2c>)
/**
 * @brief   DMA1 stream 4 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH4_HANDLER) {
 800043c:	b510      	push	{r4, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM4);
 800043e:	6984      	ldr	r4, [r0, #24]
 8000440:	030a      	lsls	r2, r1, #12
 8000442:	605a      	str	r2, [r3, #4]
 8000444:	b10c      	cbz	r4, 800044a <Vector78+0x1a>
 8000446:	69c0      	ldr	r0, [r0, #28]
 8000448:	47a0      	blx	r4

  OSAL_IRQ_EPILOGUE();
}
 800044a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM4);

  OSAL_IRQ_EPILOGUE();
 800044e:	f7ff bf27 	b.w	80002a0 <_port_irq_epilogue>
 8000452:	f7ff bf25 	b.w	80002a0 <_port_irq_epilogue>
 8000456:	bf00      	nop
 8000458:	40026000 	.word	0x40026000
 800045c:	20000950 	.word	0x20000950

08000460 <Vector74>:
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH3_HANDLER) {

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM3);
 8000460:	4b09      	ldr	r3, [pc, #36]	; (8000488 <Vector74+0x28>)
 8000462:	6819      	ldr	r1, [r3, #0]
 8000464:	f3c1 2103 	ubfx	r1, r1, #8, #4
 8000468:	b159      	cbz	r1, 8000482 <Vector74+0x22>
 800046a:	4808      	ldr	r0, [pc, #32]	; (800048c <Vector74+0x2c>)
/**
 * @brief   DMA1 stream 3 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH3_HANDLER) {
 800046c:	b510      	push	{r4, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM3);
 800046e:	6904      	ldr	r4, [r0, #16]
 8000470:	020a      	lsls	r2, r1, #8
 8000472:	605a      	str	r2, [r3, #4]
 8000474:	b10c      	cbz	r4, 800047a <Vector74+0x1a>
 8000476:	6940      	ldr	r0, [r0, #20]
 8000478:	47a0      	blx	r4

  OSAL_IRQ_EPILOGUE();
}
 800047a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM3);

  OSAL_IRQ_EPILOGUE();
 800047e:	f7ff bf0f 	b.w	80002a0 <_port_irq_epilogue>
 8000482:	f7ff bf0d 	b.w	80002a0 <_port_irq_epilogue>
 8000486:	bf00      	nop
 8000488:	40026000 	.word	0x40026000
 800048c:	20000950 	.word	0x20000950

08000490 <Vector70>:
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH2_HANDLER) {

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM2);
 8000490:	4b09      	ldr	r3, [pc, #36]	; (80004b8 <Vector70+0x28>)
 8000492:	6819      	ldr	r1, [r3, #0]
 8000494:	f3c1 1103 	ubfx	r1, r1, #4, #4
 8000498:	b159      	cbz	r1, 80004b2 <Vector70+0x22>
 800049a:	4808      	ldr	r0, [pc, #32]	; (80004bc <Vector70+0x2c>)
/**
 * @brief   DMA1 stream 2 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH2_HANDLER) {
 800049c:	b510      	push	{r4, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM2);
 800049e:	6884      	ldr	r4, [r0, #8]
 80004a0:	010a      	lsls	r2, r1, #4
 80004a2:	605a      	str	r2, [r3, #4]
 80004a4:	b10c      	cbz	r4, 80004aa <Vector70+0x1a>
 80004a6:	68c0      	ldr	r0, [r0, #12]
 80004a8:	47a0      	blx	r4

  OSAL_IRQ_EPILOGUE();
}
 80004aa:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM2);

  OSAL_IRQ_EPILOGUE();
 80004ae:	f7ff bef7 	b.w	80002a0 <_port_irq_epilogue>
 80004b2:	f7ff bef5 	b.w	80002a0 <_port_irq_epilogue>
 80004b6:	bf00      	nop
 80004b8:	40026000 	.word	0x40026000
 80004bc:	20000950 	.word	0x20000950

080004c0 <Vector6C>:
/**
 * @brief   DMA1 stream 1 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH1_HANDLER) {
 80004c0:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM1);
 80004c2:	4b07      	ldr	r3, [pc, #28]	; (80004e0 <Vector6C+0x20>)
 80004c4:	6819      	ldr	r1, [r3, #0]
 80004c6:	f011 010f 	ands.w	r1, r1, #15
 80004ca:	d005      	beq.n	80004d8 <Vector6C+0x18>
 80004cc:	4a05      	ldr	r2, [pc, #20]	; (80004e4 <Vector6C+0x24>)
 80004ce:	6059      	str	r1, [r3, #4]
 80004d0:	6813      	ldr	r3, [r2, #0]
 80004d2:	b10b      	cbz	r3, 80004d8 <Vector6C+0x18>
 80004d4:	6850      	ldr	r0, [r2, #4]
 80004d6:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
}
 80004d8:	e8bd 4008 	ldmia.w	sp!, {r3, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM1);

  OSAL_IRQ_EPILOGUE();
 80004dc:	f7ff bee0 	b.w	80002a0 <_port_irq_epilogue>
 80004e0:	40026000 	.word	0x40026000
 80004e4:	20000950 	.word	0x20000950
	...

080004f0 <SVC_Handler>:
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 80004f0:	f3ef 8309 	mrs	r3, PSP

    \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 80004f4:	3320      	adds	r3, #32
 80004f6:	f383 8809 	msr	PSP, r3

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 80004fa:	2300      	movs	r3, #0
 80004fc:	f383 8811 	msr	BASEPRI, r3
 8000500:	4770      	bx	lr
 8000502:	bf00      	nop
	...

08000510 <chTMStopMeasurementX>:
 *
 * @return              The realtime counter value.
 */
static inline rtcnt_t port_rt_get_counter_value(void) {

  return DWT->CYCCNT;
 8000510:	4b0e      	ldr	r3, [pc, #56]	; (800054c <chTMStopMeasurementX+0x3c>)
 *
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
 8000512:	490f      	ldr	r1, [pc, #60]	; (8000550 <chTMStopMeasurementX+0x40>)
 8000514:	685a      	ldr	r2, [r3, #4]
static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = (now - tmp->last) - offset;
 8000516:	6883      	ldr	r3, [r0, #8]
 *
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
 8000518:	6f09      	ldr	r1, [r1, #112]	; 0x70
static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = (now - tmp->last) - offset;
 800051a:	1ad3      	subs	r3, r2, r3

static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
 800051c:	68c2      	ldr	r2, [r0, #12]
 *
 * @param[in,out] tmp   pointer to a @p time_measurement_t structure
 *
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {
 800051e:	b430      	push	{r4, r5}
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = (now - tmp->last) - offset;
  tmp->cumulative += (rttime_t)tmp->last;
 8000520:	e9d0 4504 	ldrd	r4, r5, [r0, #16]
static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = (now - tmp->last) - offset;
 8000524:	1a5b      	subs	r3, r3, r1

static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
 8000526:	3201      	adds	r2, #1
  tmp->last = (now - tmp->last) - offset;
  tmp->cumulative += (rttime_t)tmp->last;
  if (tmp->last > tmp->worst) {
 8000528:	6841      	ldr	r1, [r0, #4]
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = (now - tmp->last) - offset;
  tmp->cumulative += (rttime_t)tmp->last;
 800052a:	18e4      	adds	r4, r4, r3

static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
 800052c:	60c2      	str	r2, [r0, #12]
  tmp->last = (now - tmp->last) - offset;
  tmp->cumulative += (rttime_t)tmp->last;
  if (tmp->last > tmp->worst) {
    tmp->worst = tmp->last;
  }
  if (tmp->last < tmp->best) {
 800052e:	6802      	ldr	r2, [r0, #0]
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = (now - tmp->last) - offset;
  tmp->cumulative += (rttime_t)tmp->last;
 8000530:	f145 0500 	adc.w	r5, r5, #0
  if (tmp->last > tmp->worst) {
 8000534:	428b      	cmp	r3, r1
    tmp->worst = tmp->last;
 8000536:	bf88      	it	hi
 8000538:	6043      	strhi	r3, [r0, #4]
  }
  if (tmp->last < tmp->best) {
 800053a:	4293      	cmp	r3, r2
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = (now - tmp->last) - offset;
  tmp->cumulative += (rttime_t)tmp->last;
 800053c:	e9c0 4504 	strd	r4, r5, [r0, #16]
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
}
 8000540:	bc30      	pop	{r4, r5}
static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = (now - tmp->last) - offset;
 8000542:	6083      	str	r3, [r0, #8]
  tmp->cumulative += (rttime_t)tmp->last;
  if (tmp->last > tmp->worst) {
    tmp->worst = tmp->last;
  }
  if (tmp->last < tmp->best) {
    tmp->best = tmp->last;
 8000544:	bf38      	it	cc
 8000546:	6003      	strcc	r3, [r0, #0]
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
}
 8000548:	4770      	bx	lr
 800054a:	bf00      	nop
 800054c:	e0001000 	.word	0xe0001000
 8000550:	20000800 	.word	0x20000800
	...

08000560 <wakeup>:
}

/*
 * Timeout wakeup callback.
 */
static void wakeup(void *p) {
 8000560:	b410      	push	{r4}
 8000562:	2320      	movs	r3, #32
 8000564:	f383 8811 	msr	BASEPRI, r3
  thread_t *tp = (thread_t *)p;

  chSysLockFromISR();
  switch (tp->p_state) {
 8000568:	7f03      	ldrb	r3, [r0, #28]
 800056a:	2b07      	cmp	r3, #7
 800056c:	d80e      	bhi.n	800058c <wakeup+0x2c>
 800056e:	e8df f003 	tbb	[pc, r3]
 8000572:	0d26      	.short	0x0d26
 8000574:	0408220d 	.word	0x0408220d
 8000578:	080d      	.short	0x080d
  case CH_STATE_SUSPENDED:
    *tp->p_u.wttrp = NULL;
    break;
#if CH_CFG_USE_SEMAPHORES == TRUE
  case CH_STATE_WTSEM:
    chSemFastSignalI(tp->p_u.wtsemp);
 800057a:	6a02      	ldr	r2, [r0, #32]
 */
static inline void chSemFastSignalI(semaphore_t *sp) {

  chDbgCheckClassI();

  sp->s_cnt++;
 800057c:	6893      	ldr	r3, [r2, #8]
 800057e:	3301      	adds	r3, #1
 8000580:	6093      	str	r3, [r2, #8]
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->p_prev->p_next = tp->p_next;
 8000582:	e890 000c 	ldmia.w	r0, {r2, r3}
 8000586:	601a      	str	r2, [r3, #0]
  tp->p_next->p_prev = tp->p_prev;
 8000588:	6802      	ldr	r2, [r0, #0]
 800058a:	6053      	str	r3, [r2, #4]
    break;
  default:
    /* Any other state, nothing to do.*/
    break;
  }
  tp->p_u.rdymsg = MSG_TIMEOUT;
 800058c:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 8000590:	2200      	movs	r2, #0
 8000592:	6881      	ldr	r1, [r0, #8]
  cp = (thread_t *)&ch.rlist.r_queue;
 8000594:	4b0c      	ldr	r3, [pc, #48]	; (80005c8 <wakeup+0x68>)
    break;
  default:
    /* Any other state, nothing to do.*/
    break;
  }
  tp->p_u.rdymsg = MSG_TIMEOUT;
 8000596:	6204      	str	r4, [r0, #32]
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 8000598:	7702      	strb	r2, [r0, #28]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
 800059a:	681b      	ldr	r3, [r3, #0]
  } while (cp->p_prio >= tp->p_prio);
 800059c:	689a      	ldr	r2, [r3, #8]
 800059e:	428a      	cmp	r2, r1
 80005a0:	d2fb      	bcs.n	800059a <wakeup+0x3a>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 80005a2:	685a      	ldr	r2, [r3, #4]
 80005a4:	2100      	movs	r1, #0
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
 80005a6:	6003      	str	r3, [r0, #0]
  tp->p_prev = cp->p_prev;
 80005a8:	6042      	str	r2, [r0, #4]
  tp->p_prev->p_next = tp;
 80005aa:	6010      	str	r0, [r2, #0]
  cp->p_prev = tp;
 80005ac:	6058      	str	r0, [r3, #4]
 80005ae:	f381 8811 	msr	BASEPRI, r1
    break;
  }
  tp->p_u.rdymsg = MSG_TIMEOUT;
  (void) chSchReadyI(tp);
  chSysUnlockFromISR();
}
 80005b2:	bc10      	pop	{r4}
 80005b4:	4770      	bx	lr
    /* Handling the special case where the thread has been made ready by
       another thread with higher priority.*/
    chSysUnlockFromISR();
    return;
  case CH_STATE_SUSPENDED:
    *tp->p_u.wttrp = NULL;
 80005b6:	6a03      	ldr	r3, [r0, #32]
 80005b8:	2200      	movs	r2, #0
 80005ba:	601a      	str	r2, [r3, #0]
 80005bc:	e7e6      	b.n	800058c <wakeup+0x2c>
 80005be:	2300      	movs	r3, #0
 80005c0:	f383 8811 	msr	BASEPRI, r3
    break;
  }
  tp->p_u.rdymsg = MSG_TIMEOUT;
  (void) chSchReadyI(tp);
  chSysUnlockFromISR();
}
 80005c4:	bc10      	pop	{r4}
 80005c6:	4770      	bx	lr
 80005c8:	20000800 	.word	0x20000800
 80005cc:	00000000 	.word	0x00000000

080005d0 <BusFault_Handler>:
 *          This function simply stops the system into an infinite loop.
 *
 * @notapi
 */
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void _unhandled_exception(void) {
 80005d0:	e7fe      	b.n	80005d0 <BusFault_Handler>
 80005d2:	bf00      	nop
	...

080005e0 <chSchGoSleepS>:
void chSchGoSleepS(tstate_t newstate) {
  thread_t *otp;

  chDbgCheckClassS();

  otp = currp;
 80005e0:	4b07      	ldr	r3, [pc, #28]	; (8000600 <chSchGoSleepS+0x20>)
 *
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
 80005e2:	b430      	push	{r4, r5}
  thread_t *otp;

  chDbgCheckClassS();

  otp = currp;
 80005e4:	6999      	ldr	r1, [r3, #24]
  tp->p_prev->p_next = tp;
  tqp->p_prev = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;
 80005e6:	681a      	ldr	r2, [r3, #0]
  otp->p_state = newstate;
 80005e8:	7708      	strb	r0, [r1, #28]

  tqp->p_next = tp->p_next;
 80005ea:	6814      	ldr	r4, [r2, #0]
#if defined(CH_CFG_IDLE_ENTER_HOOK)
  if (currp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 80005ec:	2501      	movs	r5, #1
  tqp->p_next->p_prev = (thread_t *)tqp;
 80005ee:	6063      	str	r3, [r4, #4]
 80005f0:	7715      	strb	r5, [r2, #28]
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 80005f2:	601c      	str	r4, [r3, #0]
  chSysSwitch(currp, otp);
 80005f4:	4610      	mov	r0, r2
}
 80005f6:	bc30      	pop	{r4, r5}
#if CH_CFG_TIME_QUANTUM > 0
  /* The thread is renouncing its remaining time slices so it will have a new
     time quantum when it will wakeup.*/
  otp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
  setcurrp(queue_fifo_remove(&ch.rlist.r_queue));
 80005f8:	619a      	str	r2, [r3, #24]
  if (currp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
  chSysSwitch(currp, otp);
 80005fa:	f7ff be09 	b.w	8000210 <_port_switch>
 80005fe:	bf00      	nop
 8000600:	20000800 	.word	0x20000800
	...

08000610 <chSchGoSleepTimeoutS>:
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {

  chDbgCheckClassS();

  if (TIME_INFINITE != time) {
 8000610:	f64f 73ff 	movw	r3, #65535	; 0xffff
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
 8000614:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}

  chDbgCheckClassS();

  if (TIME_INFINITE != time) {
 8000618:	4299      	cmp	r1, r3
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
 800061a:	b086      	sub	sp, #24

  chDbgCheckClassS();

  if (TIME_INFINITE != time) {
 800061c:	d051      	beq.n	80006c2 <chSchGoSleepTimeoutS+0xb2>
    virtual_timer_t vt;

    chVTDoSetI(&vt, time, wakeup, currp);
 800061e:	4c48      	ldr	r4, [pc, #288]	; (8000740 <chSchGoSleepTimeoutS+0x130>)
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8000620:	f04f 4780 	mov.w	r7, #1073741824	; 0x40000000
    if (delay < (systime_t)CH_CFG_ST_TIMEDELTA) {
      delay = (systime_t)CH_CFG_ST_TIMEDELTA;
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {
 8000624:	4625      	mov	r5, r4
 8000626:	f855 2f1c 	ldr.w	r2, [r5, #28]!
 800062a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    systime_t now = chVTGetSystemTimeX();

    /* If the requested delay is lower than the minimum safe delta then it
       is raised to the minimum safe value.*/
    if (delay < (systime_t)CH_CFG_ST_TIMEDELTA) {
      delay = (systime_t)CH_CFG_ST_TIMEDELTA;
 800062c:	2901      	cmp	r1, #1
 800062e:	4606      	mov	r6, r0

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->vt_par = par;
  vtp->vt_func = vtfunc;
 8000630:	f8df e110 	ldr.w	lr, [pc, #272]	; 8000744 <chSchGoSleepTimeoutS+0x134>
  systime_t delta;

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->vt_par = par;
 8000634:	69a0      	ldr	r0, [r4, #24]
    systime_t now = chVTGetSystemTimeX();

    /* If the requested delay is lower than the minimum safe delta then it
       is raised to the minimum safe value.*/
    if (delay < (systime_t)CH_CFG_ST_TIMEDELTA) {
      delay = (systime_t)CH_CFG_ST_TIMEDELTA;
 8000636:	bf98      	it	ls
 8000638:	2102      	movls	r1, #2
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {
 800063a:	42aa      	cmp	r2, r5
  systime_t delta;

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->vt_par = par;
 800063c:	9005      	str	r0, [sp, #20]
 800063e:	b29b      	uxth	r3, r3
  vtp->vt_func = vtfunc;
 8000640:	f8cd e010 	str.w	lr, [sp, #16]
    if (delay < (systime_t)CH_CFG_ST_TIMEDELTA) {
      delay = (systime_t)CH_CFG_ST_TIMEDELTA;
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {
 8000644:	d064      	beq.n	8000710 <chSchGoSleepTimeoutS+0x100>
      return;
    }

    /* Special case where the timer will be placed as first element in a
       non-empty list, the alarm needs to be recalculated.*/
    delta = now + delay - ch.vtlist.vt_lasttime;
 8000646:	4419      	add	r1, r3
 8000648:	8ce3      	ldrh	r3, [r4, #38]	; 0x26
 800064a:	b289      	uxth	r1, r1
    if (delta < ch.vtlist.vt_next->vt_delta) {
 800064c:	8910      	ldrh	r0, [r2, #8]
      return;
    }

    /* Special case where the timer will be placed as first element in a
       non-empty list, the alarm needs to be recalculated.*/
    delta = now + delay - ch.vtlist.vt_lasttime;
 800064e:	1acb      	subs	r3, r1, r3
 8000650:	b29b      	uxth	r3, r3
    if (delta < ch.vtlist.vt_next->vt_delta) {
 8000652:	4283      	cmp	r3, r0
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8000654:	bf38      	it	cc
 8000656:	6379      	strcc	r1, [r7, #52]	; 0x34
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = ch.vtlist.vt_next;
  while (p->vt_delta < delta) {
 8000658:	4283      	cmp	r3, r0
 800065a:	d905      	bls.n	8000668 <chSchGoSleepTimeoutS+0x58>
    delta -= p->vt_delta;
    p = p->vt_next;
 800065c:	6812      	ldr	r2, [r2, #0]

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = ch.vtlist.vt_next;
  while (p->vt_delta < delta) {
    delta -= p->vt_delta;
 800065e:	1a1b      	subs	r3, r3, r0
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = ch.vtlist.vt_next;
  while (p->vt_delta < delta) {
 8000660:	8910      	ldrh	r0, [r2, #8]
    delta -= p->vt_delta;
 8000662:	b29b      	uxth	r3, r3
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = ch.vtlist.vt_next;
  while (p->vt_delta < delta) {
 8000664:	4298      	cmp	r0, r3
 8000666:	d3f9      	bcc.n	800065c <chSchGoSleepTimeoutS+0x4c>
  vtp->vt_delta = delta

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->vt_delta -= delta;
  ch.vtlist.vt_delta = (systime_t)-1;
 8000668:	f64f 70ff 	movw	r0, #65535	; 0xffff
    p = p->vt_next;
  }

  /* The timer is inserted in the delta list.*/
  vtp->vt_next = p;
  vtp->vt_prev = vtp->vt_next->vt_prev;
 800066c:	6851      	ldr	r1, [r2, #4]
  vtp->vt_prev->vt_next = vtp;
 800066e:	f10d 0804 	add.w	r8, sp, #4
    p = p->vt_next;
  }

  /* The timer is inserted in the delta list.*/
  vtp->vt_next = p;
  vtp->vt_prev = vtp->vt_next->vt_prev;
 8000672:	9102      	str	r1, [sp, #8]
    delta -= p->vt_delta;
    p = p->vt_next;
  }

  /* The timer is inserted in the delta list.*/
  vtp->vt_next = p;
 8000674:	9201      	str	r2, [sp, #4]
  vtp->vt_prev = vtp->vt_next->vt_prev;
  vtp->vt_prev->vt_next = vtp;
 8000676:	f8c1 8000 	str.w	r8, [r1]
  p->vt_prev = vtp;
 800067a:	f8c2 8004 	str.w	r8, [r2, #4]
  vtp->vt_delta = delta
 800067e:	f8ad 300c 	strh.w	r3, [sp, #12]

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->vt_delta -= delta;
 8000682:	8911      	ldrh	r1, [r2, #8]
 8000684:	1acb      	subs	r3, r1, r3
 8000686:	8113      	strh	r3, [r2, #8]
  ch.vtlist.vt_delta = (systime_t)-1;
 8000688:	84a0      	strh	r0, [r4, #36]	; 0x24
    chSchGoSleepS(newstate);
 800068a:	4630      	mov	r0, r6
 800068c:	f7ff ffa8 	bl	80005e0 <chSchGoSleepS>
    if (chVTIsArmedI(&vt)) {
 8000690:	9b04      	ldr	r3, [sp, #16]
 8000692:	b18b      	cbz	r3, 80006b8 <chSchGoSleepTimeoutS+0xa8>
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  systime_t nowdelta, delta;

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.vt_next != vtp) {
 8000694:	69e3      	ldr	r3, [r4, #28]
 8000696:	4a2a      	ldr	r2, [pc, #168]	; (8000740 <chSchGoSleepTimeoutS+0x130>)
 8000698:	4543      	cmp	r3, r8
 800069a:	d01a      	beq.n	80006d2 <chSchGoSleepTimeoutS+0xc2>
    /* Removing the element from the delta list.*/
    vtp->vt_prev->vt_next = vtp->vt_next;
 800069c:	9a02      	ldr	r2, [sp, #8]
 800069e:	9b01      	ldr	r3, [sp, #4]
    vtp->vt_next->vt_prev = vtp->vt_prev;
    vtp->vt_func = NULL;
 80006a0:	2100      	movs	r1, #0

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.vt_next != vtp) {
    /* Removing the element from the delta list.*/
    vtp->vt_prev->vt_next = vtp->vt_next;
 80006a2:	6013      	str	r3, [r2, #0]
    vtp->vt_next->vt_prev = vtp->vt_prev;
 80006a4:	9b01      	ldr	r3, [sp, #4]
    vtp->vt_func = NULL;

    /* Adding delta to the next element, if it is not the last one.*/
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->vt_next)
 80006a6:	42ab      	cmp	r3, r5
  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.vt_next != vtp) {
    /* Removing the element from the delta list.*/
    vtp->vt_prev->vt_next = vtp->vt_next;
    vtp->vt_next->vt_prev = vtp->vt_prev;
 80006a8:	605a      	str	r2, [r3, #4]
    vtp->vt_func = NULL;
 80006aa:	9104      	str	r1, [sp, #16]

    /* Adding delta to the next element, if it is not the last one.*/
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->vt_next)
 80006ac:	d004      	beq.n	80006b8 <chSchGoSleepTimeoutS+0xa8>
      vtp->vt_next->vt_delta += vtp->vt_delta;
 80006ae:	8919      	ldrh	r1, [r3, #8]
 80006b0:	f8bd 200c 	ldrh.w	r2, [sp, #12]
 80006b4:	440a      	add	r2, r1
 80006b6:	811a      	strh	r2, [r3, #8]
  }
  else {
    chSchGoSleepS(newstate);
  }

  return currp->p_u.rdymsg;
 80006b8:	69a3      	ldr	r3, [r4, #24]
}
 80006ba:	6a18      	ldr	r0, [r3, #32]
 80006bc:	b006      	add	sp, #24
 80006be:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if (chVTIsArmedI(&vt)) {
      chVTDoResetI(&vt);
    }
  }
  else {
    chSchGoSleepS(newstate);
 80006c2:	f7ff ff8d 	bl	80005e0 <chSchGoSleepS>
 80006c6:	4c1e      	ldr	r4, [pc, #120]	; (8000740 <chSchGoSleepTimeoutS+0x130>)
  }

  return currp->p_u.rdymsg;
 80006c8:	69a3      	ldr	r3, [r4, #24]
}
 80006ca:	6a18      	ldr	r0, [r3, #32]
 80006cc:	b006      	add	sp, #24
 80006ce:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

    return;
  }

  /* Removing the first timer from the list.*/
  ch.vtlist.vt_next = vtp->vt_next;
 80006d2:	9901      	ldr	r1, [sp, #4]
  ch.vtlist.vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
  vtp->vt_func = NULL;
 80006d4:	2300      	movs	r3, #0

  /* If the list become empty then the alarm timer is stopped and done.*/
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {
 80006d6:	42a9      	cmp	r1, r5

    return;
  }

  /* Removing the first timer from the list.*/
  ch.vtlist.vt_next = vtp->vt_next;
 80006d8:	61d1      	str	r1, [r2, #28]
  ch.vtlist.vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
 80006da:	604d      	str	r5, [r1, #4]
  vtp->vt_func = NULL;
 80006dc:	9304      	str	r3, [sp, #16]

  /* If the list become empty then the alarm timer is stopped and done.*/
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {
 80006de:	d02a      	beq.n	8000736 <chSchGoSleepTimeoutS+0x126>
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 80006e0:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
 80006e4:	6a45      	ldr	r5, [r0, #36]	; 0x24
/*  if (ch.vtlist.vt_next->vt_delta == 0) {
    return;
  }*/

  /* Distance in ticks between the last alarm event and current time.*/
  nowdelta = chVTGetSystemTimeX() - ch.vtlist.vt_lasttime;
 80006e6:	8cd2      	ldrh	r2, [r2, #38]	; 0x26

    return;
  }

  /* The delta of the removed timer is added to the new first timer.*/
  ch.vtlist.vt_next->vt_delta += vtp->vt_delta;
 80006e8:	890e      	ldrh	r6, [r1, #8]
 80006ea:	f8bd 300c 	ldrh.w	r3, [sp, #12]
 80006ee:	b2ad      	uxth	r5, r5
/*  if (ch.vtlist.vt_next->vt_delta == 0) {
    return;
  }*/

  /* Distance in ticks between the last alarm event and current time.*/
  nowdelta = chVTGetSystemTimeX() - ch.vtlist.vt_lasttime;
 80006f0:	1aaa      	subs	r2, r5, r2

    return;
  }

  /* The delta of the removed timer is added to the new first timer.*/
  ch.vtlist.vt_next->vt_delta += vtp->vt_delta;
 80006f2:	4433      	add	r3, r6
 80006f4:	b29b      	uxth	r3, r3
/*  if (ch.vtlist.vt_next->vt_delta == 0) {
    return;
  }*/

  /* Distance in ticks between the last alarm event and current time.*/
  nowdelta = chVTGetSystemTimeX() - ch.vtlist.vt_lasttime;
 80006f6:	b292      	uxth	r2, r2

  /* If the current time surpassed the time of the next element in list
     then the event interrupt is already pending, just return.*/
  if (nowdelta >= ch.vtlist.vt_next->vt_delta) {
 80006f8:	4293      	cmp	r3, r2

    return;
  }

  /* The delta of the removed timer is added to the new first timer.*/
  ch.vtlist.vt_next->vt_delta += vtp->vt_delta;
 80006fa:	810b      	strh	r3, [r1, #8]
  /* Distance in ticks between the last alarm event and current time.*/
  nowdelta = chVTGetSystemTimeX() - ch.vtlist.vt_lasttime;

  /* If the current time surpassed the time of the next element in list
     then the event interrupt is already pending, just return.*/
  if (nowdelta >= ch.vtlist.vt_next->vt_delta) {
 80006fc:	d9dc      	bls.n	80006b8 <chSchGoSleepTimeoutS+0xa8>
    return;
  }

  /* Distance from the next scheduled event and now.*/
  delta = ch.vtlist.vt_next->vt_delta - nowdelta;
 80006fe:	1a9a      	subs	r2, r3, r2
 8000700:	b293      	uxth	r3, r2

  /* Making sure to not schedule an event closer than CH_CFG_ST_TIMEDELTA
     ticks from now.*/
  if (delta < (systime_t)CH_CFG_ST_TIMEDELTA) {
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
 8000702:	2b01      	cmp	r3, #1
 8000704:	bf98      	it	ls
 8000706:	2302      	movls	r3, #2
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8000708:	442b      	add	r3, r5
 800070a:	b29b      	uxth	r3, r3
 800070c:	6343      	str	r3, [r0, #52]	; 0x34
 800070e:	e7d3      	b.n	80006b8 <chSchGoSleepTimeoutS+0xa8>
 *
 * @notapi
 */
static inline void st_lld_start_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8000710:	185a      	adds	r2, r3, r1
    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {

      /* The delta list is empty, the current time becomes the new
         delta list base time, the timer is inserted.*/
      ch.vtlist.vt_lasttime = now;
 8000712:	84e3      	strh	r3, [r4, #38]	; 0x26
      ch.vtlist.vt_next = vtp;
 8000714:	f10d 0804 	add.w	r8, sp, #4
 8000718:	b292      	uxth	r2, r2
  STM32_ST_TIM->SR     = 0;
 800071a:	2000      	movs	r0, #0
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 800071c:	2302      	movs	r3, #2
      ch.vtlist.vt_prev = vtp;
      vtp->vt_next = (virtual_timer_t *)&ch.vtlist;
 800071e:	9501      	str	r5, [sp, #4]
      vtp->vt_prev = (virtual_timer_t *)&ch.vtlist;
 8000720:	9502      	str	r5, [sp, #8]
      vtp->vt_delta = delay;
 8000722:	f8ad 100c 	strh.w	r1, [sp, #12]
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {

      /* The delta list is empty, the current time becomes the new
         delta list base time, the timer is inserted.*/
      ch.vtlist.vt_lasttime = now;
      ch.vtlist.vt_next = vtp;
 8000726:	f8c4 801c 	str.w	r8, [r4, #28]
      ch.vtlist.vt_prev = vtp;
 800072a:	f8c4 8020 	str.w	r8, [r4, #32]
 *
 * @notapi
 */
static inline void st_lld_start_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 800072e:	637a      	str	r2, [r7, #52]	; 0x34
  STM32_ST_TIM->SR     = 0;
 8000730:	6138      	str	r0, [r7, #16]
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 8000732:	60fb      	str	r3, [r7, #12]
 8000734:	e7a9      	b.n	800068a <chSchGoSleepTimeoutS+0x7a>
 *
 * @notapi
 */
static inline void st_lld_stop_alarm(void) {

  STM32_ST_TIM->DIER = 0;
 8000736:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 800073a:	60d3      	str	r3, [r2, #12]
 800073c:	e7bc      	b.n	80006b8 <chSchGoSleepTimeoutS+0xa8>
 800073e:	bf00      	nop
 8000740:	20000800 	.word	0x20000800
 8000744:	08000561 	.word	0x08000561
	...

08000750 <chThdEnqueueTimeoutS>:
 *
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, systime_t timeout) {

  if (TIME_IMMEDIATE == timeout) {
 8000750:	b161      	cbz	r1, 800076c <chThdEnqueueTimeoutS+0x1c>
 8000752:	4602      	mov	r2, r0
    return MSG_TIMEOUT;
  }

  queue_insert(currp, tqp);
 8000754:	4b07      	ldr	r3, [pc, #28]	; (8000774 <chThdEnqueueTimeoutS+0x24>)
 *                      invoked with @p TIME_IMMEDIATE as timeout
 *                      specification.
 *
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, systime_t timeout) {
 8000756:	b410      	push	{r4}

  if (TIME_IMMEDIATE == timeout) {
    return MSG_TIMEOUT;
  }

  queue_insert(currp, tqp);
 8000758:	699b      	ldr	r3, [r3, #24]
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->p_next = (thread_t *)tqp;
  tp->p_prev = tqp->p_prev;
 800075a:	6844      	ldr	r4, [r0, #4]

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 800075c:	2004      	movs	r0, #4
 800075e:	e883 0014 	stmia.w	r3, {r2, r4}
  tp->p_prev->p_next = tp;
 8000762:	6023      	str	r3, [r4, #0]
  tqp->p_prev = tp;
 8000764:	6053      	str	r3, [r2, #4]
}
 8000766:	bc10      	pop	{r4}
    return MSG_TIMEOUT;
  }

  queue_insert(currp, tqp);

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 8000768:	f7ff bf52 	b.w	8000610 <chSchGoSleepTimeoutS>
}
 800076c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8000770:	4770      	bx	lr
 8000772:	bf00      	nop
 8000774:	20000800 	.word	0x20000800
	...

08000780 <chOQWriteTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t chOQWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                        size_t n, systime_t timeout) {
 8000780:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8000784:	b083      	sub	sp, #12
 8000786:	4604      	mov	r4, r0
 8000788:	460d      	mov	r5, r1
 800078a:	4616      	mov	r6, r2
 800078c:	9301      	str	r3, [sp, #4]
  qnotify_t nfy = oqp->q_notify;
 800078e:	f8d0 801c 	ldr.w	r8, [r0, #28]
 8000792:	f04f 0920 	mov.w	r9, #32
 8000796:	f389 8811 	msr	BASEPRI, r9
  size_t w = 0;
 800079a:	2700      	movs	r7, #0
 800079c:	46ba      	mov	sl, r7
 */
static inline bool chOQIsFullI(output_queue_t *oqp) {

  chDbgCheckClassI();

  return (bool)(chQSpaceI(oqp) == 0U);
 800079e:	68a3      	ldr	r3, [r4, #8]
        return w;
      }
    }
    
    oqp->q_counter--;
    *oqp->q_wrptr++ = *bp++;
 80007a0:	f105 0b01 	add.w	fp, r5, #1

  chDbgCheck(n > 0U);

  chSysLock();
  while (true) {
    while (chOQIsFullI(oqp)) {
 80007a4:	b303      	cbz	r3, 80007e8 <chOQWriteTimeout+0x68>
        return w;
      }
    }
    
    oqp->q_counter--;
    *oqp->q_wrptr++ = *bp++;
 80007a6:	6961      	ldr	r1, [r4, #20]
        chSysUnlock();
        return w;
      }
    }
    
    oqp->q_counter--;
 80007a8:	68a3      	ldr	r3, [r4, #8]
    *oqp->q_wrptr++ = *bp++;
 80007aa:	1c48      	adds	r0, r1, #1
        chSysUnlock();
        return w;
      }
    }
    
    oqp->q_counter--;
 80007ac:	3b01      	subs	r3, #1
    *oqp->q_wrptr++ = *bp++;
 80007ae:	6160      	str	r0, [r4, #20]
        chSysUnlock();
        return w;
      }
    }
    
    oqp->q_counter--;
 80007b0:	60a3      	str	r3, [r4, #8]
    *oqp->q_wrptr++ = *bp++;
 80007b2:	782b      	ldrb	r3, [r5, #0]
 80007b4:	700b      	strb	r3, [r1, #0]
    if (oqp->q_wrptr >= oqp->q_top) {
 80007b6:	6923      	ldr	r3, [r4, #16]
 80007b8:	6961      	ldr	r1, [r4, #20]
 80007ba:	4299      	cmp	r1, r3
      oqp->q_wrptr = oqp->q_buffer;
 80007bc:	bf24      	itt	cs
 80007be:	68e3      	ldrcs	r3, [r4, #12]
 80007c0:	6163      	strcs	r3, [r4, #20]
    }

    if (nfy != NULL) {
 80007c2:	f1b8 0f00 	cmp.w	r8, #0
 80007c6:	d001      	beq.n	80007cc <chOQWriteTimeout+0x4c>
      nfy(oqp);
 80007c8:	4620      	mov	r0, r4
 80007ca:	47c0      	blx	r8
 80007cc:	f38a 8811 	msr	BASEPRI, sl
    }
    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/

    w++;
    if (--n == 0U) {
 80007d0:	3e01      	subs	r6, #1
    if (nfy != NULL) {
      nfy(oqp);
    }
    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/

    w++;
 80007d2:	f107 0701 	add.w	r7, r7, #1
    if (--n == 0U) {
 80007d6:	d011      	beq.n	80007fc <chOQWriteTimeout+0x7c>
 80007d8:	f389 8811 	msr	BASEPRI, r9
        return w;
      }
    }
    
    oqp->q_counter--;
    *oqp->q_wrptr++ = *bp++;
 80007dc:	465d      	mov	r5, fp
 80007de:	68a3      	ldr	r3, [r4, #8]
 80007e0:	f105 0b01 	add.w	fp, r5, #1

  chDbgCheck(n > 0U);

  chSysLock();
  while (true) {
    while (chOQIsFullI(oqp)) {
 80007e4:	2b00      	cmp	r3, #0
 80007e6:	d1de      	bne.n	80007a6 <chOQWriteTimeout+0x26>
      if (chThdEnqueueTimeoutS(&oqp->q_waiting, timeout) != Q_OK) {
 80007e8:	9901      	ldr	r1, [sp, #4]
 80007ea:	4620      	mov	r0, r4
 80007ec:	9300      	str	r3, [sp, #0]
 80007ee:	f7ff ffaf 	bl	8000750 <chThdEnqueueTimeoutS>
 80007f2:	9b00      	ldr	r3, [sp, #0]
 80007f4:	2800      	cmp	r0, #0
 80007f6:	d0d2      	beq.n	800079e <chOQWriteTimeout+0x1e>
 80007f8:	f383 8811 	msr	BASEPRI, r3
    if (--n == 0U) {
      return w;
    }
    chSysLock();
  }
}
 80007fc:	4638      	mov	r0, r7
 80007fe:	b003      	add	sp, #12
 8000800:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	...

08000810 <writet>:
  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
}

static size_t writet(void *ip, const uint8_t *bp, size_t n, systime_t timeout) {

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
 8000810:	3030      	adds	r0, #48	; 0x30
 8000812:	f7ff bfb5 	b.w	8000780 <chOQWriteTimeout>
 8000816:	bf00      	nop
	...

08000820 <write>:
 * queue-level function or macro.
 */

static size_t write(void *ip, const uint8_t *bp, size_t n) {

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
 8000820:	3030      	adds	r0, #48	; 0x30
 8000822:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8000826:	f7ff bfab 	b.w	8000780 <chOQWriteTimeout>
 800082a:	bf00      	nop
 800082c:	0000      	movs	r0, r0
	...

08000830 <chOQPutTimeout>:
 * @retval Q_TIMEOUT    if the specified time expired.
 * @retval Q_RESET      if the queue has been reset.
 *
 * @api
 */
msg_t chOQPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {
 8000830:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8000832:	4604      	mov	r4, r0
 8000834:	460f      	mov	r7, r1
 8000836:	4616      	mov	r6, r2
 8000838:	2320      	movs	r3, #32
 800083a:	f383 8811 	msr	BASEPRI, r3
 800083e:	e005      	b.n	800084c <chOQPutTimeout+0x1c>

  chSysLock();
  while (chOQIsFullI(oqp)) {
    msg_t msg = chThdEnqueueTimeoutS(&oqp->q_waiting, timeout);
 8000840:	4631      	mov	r1, r6
 8000842:	4620      	mov	r0, r4
 8000844:	f7ff ff84 	bl	8000750 <chThdEnqueueTimeoutS>
    if (msg < Q_OK) {
 8000848:	2800      	cmp	r0, #0
 800084a:	db17      	blt.n	800087c <chOQPutTimeout+0x4c>
 800084c:	68a5      	ldr	r5, [r4, #8]
 * @api
 */
msg_t chOQPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {

  chSysLock();
  while (chOQIsFullI(oqp)) {
 800084e:	2d00      	cmp	r5, #0
 8000850:	d0f6      	beq.n	8000840 <chOQPutTimeout+0x10>
      return msg;
    }
  }

  oqp->q_counter--;
  *oqp->q_wrptr++ = b;
 8000852:	6962      	ldr	r2, [r4, #20]
      chSysUnlock();
      return msg;
    }
  }

  oqp->q_counter--;
 8000854:	68a3      	ldr	r3, [r4, #8]
  *oqp->q_wrptr++ = b;
 8000856:	1c51      	adds	r1, r2, #1
      chSysUnlock();
      return msg;
    }
  }

  oqp->q_counter--;
 8000858:	3b01      	subs	r3, #1
  *oqp->q_wrptr++ = b;
 800085a:	6161      	str	r1, [r4, #20]
      chSysUnlock();
      return msg;
    }
  }

  oqp->q_counter--;
 800085c:	60a3      	str	r3, [r4, #8]
  *oqp->q_wrptr++ = b;
 800085e:	7017      	strb	r7, [r2, #0]
  if (oqp->q_wrptr >= oqp->q_top) {
 8000860:	6923      	ldr	r3, [r4, #16]
 8000862:	6962      	ldr	r2, [r4, #20]
 8000864:	429a      	cmp	r2, r3
    oqp->q_wrptr = oqp->q_buffer;
 8000866:	bf24      	itt	cs
 8000868:	68e3      	ldrcs	r3, [r4, #12]
 800086a:	6163      	strcs	r3, [r4, #20]
  }

  if (oqp->q_notify != NULL) {
 800086c:	69e3      	ldr	r3, [r4, #28]
 800086e:	b10b      	cbz	r3, 8000874 <chOQPutTimeout+0x44>
    oqp->q_notify(oqp);
 8000870:	4620      	mov	r0, r4
 8000872:	4798      	blx	r3
 8000874:	2000      	movs	r0, #0
 8000876:	f380 8811 	msr	BASEPRI, r0
  }
  chSysUnlock();

  return Q_OK;
}
 800087a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 800087c:	f385 8811 	msr	BASEPRI, r5
 8000880:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8000882:	bf00      	nop
	...

08000890 <putt>:
  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
}

static msg_t putt(void *ip, uint8_t b, systime_t timeout) {

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
 8000890:	3030      	adds	r0, #48	; 0x30
 8000892:	f7ff bfcd 	b.w	8000830 <chOQPutTimeout>
 8000896:	bf00      	nop
	...

080008a0 <put>:
                       n, TIME_INFINITE);
}

static msg_t put(void *ip, uint8_t b) {

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
 80008a0:	3030      	adds	r0, #48	; 0x30
 80008a2:	f64f 72ff 	movw	r2, #65535	; 0xffff
 80008a6:	f7ff bfc3 	b.w	8000830 <chOQPutTimeout>
 80008aa:	bf00      	nop
 80008ac:	0000      	movs	r0, r0
	...

080008b0 <chIQReadTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t chIQReadTimeout(input_queue_t *iqp, uint8_t *bp,
                       size_t n, systime_t timeout) {
 80008b0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80008b4:	4604      	mov	r4, r0
 80008b6:	b083      	sub	sp, #12
 80008b8:	4689      	mov	r9, r1
 80008ba:	4693      	mov	fp, r2
 80008bc:	461d      	mov	r5, r3
  qnotify_t nfy = iqp->q_notify;
 80008be:	f8d0 801c 	ldr.w	r8, [r0, #28]
 80008c2:	2720      	movs	r7, #32
 80008c4:	f387 8811 	msr	BASEPRI, r7
  size_t r = 0;
 80008c8:	2600      	movs	r6, #0
 80008ca:	46b2      	mov	sl, r6
 80008cc:	9701      	str	r7, [sp, #4]

  chDbgCheck(n > 0U);

  chSysLock();
  while (true) {
    if (nfy != NULL) {
 80008ce:	f1b8 0f00 	cmp.w	r8, #0
 80008d2:	d007      	beq.n	80008e4 <chIQReadTimeout+0x34>
      nfy(iqp);
 80008d4:	4620      	mov	r0, r4
 80008d6:	47c0      	blx	r8
 80008d8:	e004      	b.n	80008e4 <chIQReadTimeout+0x34>
    }

    while (chIQIsEmptyI(iqp)) {
      if (chThdEnqueueTimeoutS(&iqp->q_waiting, timeout) != Q_OK) {
 80008da:	4629      	mov	r1, r5
 80008dc:	4620      	mov	r0, r4
 80008de:	f7ff ff37 	bl	8000750 <chThdEnqueueTimeoutS>
 80008e2:	b9d0      	cbnz	r0, 800091a <chIQReadTimeout+0x6a>
 */
static inline bool chIQIsEmptyI(input_queue_t *iqp) {

  chDbgCheckClassI();

  return (bool)(chQSpaceI(iqp) == 0U);
 80008e4:	68a7      	ldr	r7, [r4, #8]
  while (true) {
    if (nfy != NULL) {
      nfy(iqp);
    }

    while (chIQIsEmptyI(iqp)) {
 80008e6:	2f00      	cmp	r7, #0
 80008e8:	d0f7      	beq.n	80008da <chIQReadTimeout+0x2a>
        return r;
      }
    }

    iqp->q_counter--;
    *bp++ = *iqp->q_rdptr++;
 80008ea:	69a2      	ldr	r2, [r4, #24]
        chSysUnlock();
        return r;
      }
    }

    iqp->q_counter--;
 80008ec:	68a3      	ldr	r3, [r4, #8]
    *bp++ = *iqp->q_rdptr++;
 80008ee:	1c51      	adds	r1, r2, #1
        chSysUnlock();
        return r;
      }
    }

    iqp->q_counter--;
 80008f0:	3b01      	subs	r3, #1
    *bp++ = *iqp->q_rdptr++;
 80008f2:	61a1      	str	r1, [r4, #24]
        chSysUnlock();
        return r;
      }
    }

    iqp->q_counter--;
 80008f4:	60a3      	str	r3, [r4, #8]
    *bp++ = *iqp->q_rdptr++;
 80008f6:	7813      	ldrb	r3, [r2, #0]
 80008f8:	f809 3b01 	strb.w	r3, [r9], #1
    if (iqp->q_rdptr >= iqp->q_top) {
 80008fc:	6923      	ldr	r3, [r4, #16]
 80008fe:	69a2      	ldr	r2, [r4, #24]
 8000900:	429a      	cmp	r2, r3
      iqp->q_rdptr = iqp->q_buffer;
 8000902:	bf24      	itt	cs
 8000904:	68e3      	ldrcs	r3, [r4, #12]
 8000906:	61a3      	strcs	r3, [r4, #24]
 8000908:	f38a 8811 	msr	BASEPRI, sl
    }
    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/

    r++;
 800090c:	3601      	adds	r6, #1
    if (--n == 0U) {
 800090e:	45b3      	cmp	fp, r6
 8000910:	d005      	beq.n	800091e <chIQReadTimeout+0x6e>
 8000912:	9b01      	ldr	r3, [sp, #4]
 8000914:	f383 8811 	msr	BASEPRI, r3
 8000918:	e7d9      	b.n	80008ce <chIQReadTimeout+0x1e>
 800091a:	f387 8811 	msr	BASEPRI, r7
      return r;
    }

    chSysLock();
  }
}
 800091e:	4630      	mov	r0, r6
 8000920:	b003      	add	sp, #12
 8000922:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8000926:	bf00      	nop
	...

08000930 <readt>:
  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
}

static size_t readt(void *ip, uint8_t *bp, size_t n, systime_t timeout) {

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp, n, timeout);
 8000930:	300c      	adds	r0, #12
 8000932:	f7ff bfbd 	b.w	80008b0 <chIQReadTimeout>
 8000936:	bf00      	nop
	...

08000940 <read>:
                        n, TIME_INFINITE);
}

static size_t read(void *ip, uint8_t *bp, size_t n) {

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
 8000940:	300c      	adds	r0, #12
 8000942:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8000946:	f7ff bfb3 	b.w	80008b0 <chIQReadTimeout>
 800094a:	bf00      	nop
 800094c:	0000      	movs	r0, r0
	...

08000950 <chIQGetTimeout>:
 * @retval Q_TIMEOUT    if the specified time expired.
 * @retval Q_RESET      if the queue has been reset.
 *
 * @api
 */
msg_t chIQGetTimeout(input_queue_t *iqp, systime_t timeout) {
 8000950:	b570      	push	{r4, r5, r6, lr}
 8000952:	2320      	movs	r3, #32
 8000954:	460e      	mov	r6, r1
 8000956:	4604      	mov	r4, r0
 8000958:	f383 8811 	msr	BASEPRI, r3
  uint8_t b;

  chSysLock();
  if (iqp->q_notify != NULL) {
 800095c:	69c3      	ldr	r3, [r0, #28]
 800095e:	b13b      	cbz	r3, 8000970 <chIQGetTimeout+0x20>
    iqp->q_notify(iqp);
 8000960:	4798      	blx	r3
 8000962:	e005      	b.n	8000970 <chIQGetTimeout+0x20>
  }

  while (chIQIsEmptyI(iqp)) {
    msg_t msg = chThdEnqueueTimeoutS(&iqp->q_waiting, timeout);
 8000964:	4631      	mov	r1, r6
 8000966:	4620      	mov	r0, r4
 8000968:	f7ff fef2 	bl	8000750 <chThdEnqueueTimeoutS>
    if (msg < Q_OK) {
 800096c:	2800      	cmp	r0, #0
 800096e:	db13      	blt.n	8000998 <chIQGetTimeout+0x48>
 8000970:	68a5      	ldr	r5, [r4, #8]
  chSysLock();
  if (iqp->q_notify != NULL) {
    iqp->q_notify(iqp);
  }

  while (chIQIsEmptyI(iqp)) {
 8000972:	2d00      	cmp	r5, #0
 8000974:	d0f6      	beq.n	8000964 <chIQGetTimeout+0x14>
      return msg;
    }
  }

  iqp->q_counter--;
  b = *iqp->q_rdptr++;
 8000976:	69a1      	ldr	r1, [r4, #24]
      chSysUnlock();
      return msg;
    }
  }

  iqp->q_counter--;
 8000978:	68a3      	ldr	r3, [r4, #8]
  b = *iqp->q_rdptr++;
  if (iqp->q_rdptr >= iqp->q_top) {
 800097a:	6925      	ldr	r5, [r4, #16]
      return msg;
    }
  }

  iqp->q_counter--;
  b = *iqp->q_rdptr++;
 800097c:	1c4a      	adds	r2, r1, #1
      chSysUnlock();
      return msg;
    }
  }

  iqp->q_counter--;
 800097e:	3b01      	subs	r3, #1
  b = *iqp->q_rdptr++;
  if (iqp->q_rdptr >= iqp->q_top) {
 8000980:	42aa      	cmp	r2, r5
      chSysUnlock();
      return msg;
    }
  }

  iqp->q_counter--;
 8000982:	60a3      	str	r3, [r4, #8]
  b = *iqp->q_rdptr++;
  if (iqp->q_rdptr >= iqp->q_top) {
    iqp->q_rdptr = iqp->q_buffer;
 8000984:	bf28      	it	cs
 8000986:	68e3      	ldrcs	r3, [r4, #12]
      return msg;
    }
  }

  iqp->q_counter--;
  b = *iqp->q_rdptr++;
 8000988:	61a2      	str	r2, [r4, #24]
 800098a:	7808      	ldrb	r0, [r1, #0]
  if (iqp->q_rdptr >= iqp->q_top) {
    iqp->q_rdptr = iqp->q_buffer;
 800098c:	bf28      	it	cs
 800098e:	61a3      	strcs	r3, [r4, #24]
 8000990:	2300      	movs	r3, #0
 8000992:	f383 8811 	msr	BASEPRI, r3
  }
  chSysUnlock();

  return (msg_t)b;
}
 8000996:	bd70      	pop	{r4, r5, r6, pc}
 8000998:	f385 8811 	msr	BASEPRI, r5
 800099c:	bd70      	pop	{r4, r5, r6, pc}
 800099e:	bf00      	nop

080009a0 <gett>:
  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
}

static msg_t gett(void *ip, systime_t timeout) {

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
 80009a0:	300c      	adds	r0, #12
 80009a2:	f7ff bfd5 	b.w	8000950 <chIQGetTimeout>
 80009a6:	bf00      	nop
	...

080009b0 <get>:
  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
}

static msg_t get(void *ip) {

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
 80009b0:	300c      	adds	r0, #12
 80009b2:	f64f 71ff 	movw	r1, #65535	; 0xffff
 80009b6:	f7ff bfcb 	b.w	8000950 <chIQGetTimeout>
 80009ba:	bf00      	nop
 80009bc:	0000      	movs	r0, r0
	...

080009c0 <main>:
 * @notapi
 */
void hal_lld_init(void) {

  /* Reset of all peripherals.*/
  rccResetAHB(~RCC_AHBRSTR_FLITFRST);
 80009c0:	4b25      	ldr	r3, [pc, #148]	; (8000a58 <main+0x98>)
 80009c2:	2200      	movs	r2, #0
 80009c4:	6919      	ldr	r1, [r3, #16]
}*/

/*
 * Application entry point.
 */
int main(void) {
 80009c6:	e92d 4880 	stmdb	sp!, {r7, fp, lr}
 80009ca:	f461 4100 	orn	r1, r1, #32768	; 0x8000
 80009ce:	6119      	str	r1, [r3, #16]
 80009d0:	611a      	str	r2, [r3, #16]
  rccResetAPB1(~RCC_APB1RSTR_PWRRST);
 80009d2:	6999      	ldr	r1, [r3, #24]
  rccResetAPB2(~0);
 80009d4:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
 */
void hal_lld_init(void) {

  /* Reset of all peripherals.*/
  rccResetAHB(~RCC_AHBRSTR_FLITFRST);
  rccResetAPB1(~RCC_APB1RSTR_PWRRST);
 80009d8:	f061 5180 	orn	r1, r1, #268435456	; 0x10000000
 80009dc:	6199      	str	r1, [r3, #24]
 80009de:	619a      	str	r2, [r3, #24]
  rccResetAPB2(~0);
 80009e0:	6959      	ldr	r1, [r3, #20]
 80009e2:	615c      	str	r4, [r3, #20]
 80009e4:	615a      	str	r2, [r3, #20]

  /* PWR clock enabled.*/
  rccEnablePWRInterface(FALSE);
 80009e6:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 * @brief   Initializes the backup domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 80009e8:	481c      	ldr	r0, [pc, #112]	; (8000a5c <main+0x9c>)
  rccResetAHB(~RCC_AHBRSTR_FLITFRST);
  rccResetAPB1(~RCC_APB1RSTR_PWRRST);
  rccResetAPB2(~0);

  /* PWR clock enabled.*/
  rccEnablePWRInterface(FALSE);
 80009ea:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 80009ee:	625a      	str	r2, [r3, #36]	; 0x24
 * @brief   Initializes the backup domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 80009f0:	6802      	ldr	r2, [r0, #0]
 80009f2:	b087      	sub	sp, #28
 80009f4:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 80009f8:	6002      	str	r2, [r0, #0]

  /* Reset BKP domain if different clock source selected.*/
  if ((RCC->CSR & STM32_RTCSEL_MASK) != STM32_RTCSEL){
 80009fa:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 80009fc:	f402 3240 	and.w	r2, r2, #196608	; 0x30000
 8000a00:	f5b2 3f80 	cmp.w	r2, #65536	; 0x10000
 8000a04:	d007      	beq.n	8000a16 <main+0x56>
    /* Backup domain reset.*/
    RCC->CSR |= RCC_CSR_RTCRST;
 8000a06:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8000a08:	f442 0200 	orr.w	r2, r2, #8388608	; 0x800000
 8000a0c:	635a      	str	r2, [r3, #52]	; 0x34
    RCC->CSR &= ~RCC_CSR_RTCRST;
 8000a0e:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8000a10:	f422 0200 	bic.w	r2, r2, #8388608	; 0x800000
 8000a14:	635a      	str	r2, [r3, #52]	; 0x34
  }

  /* If enabled then the LSE is started.*/
#if STM32_LSE_ENABLED
  RCC->CSR |= RCC_CSR_LSEON;
 8000a16:	4b10      	ldr	r3, [pc, #64]	; (8000a58 <main+0x98>)
  while ((RCC->CSR & RCC_CSR_LSERDY) == 0)
 8000a18:	4619      	mov	r1, r3
    RCC->CSR &= ~RCC_CSR_RTCRST;
  }

  /* If enabled then the LSE is started.*/
#if STM32_LSE_ENABLED
  RCC->CSR |= RCC_CSR_LSEON;
 8000a1a:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8000a1c:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8000a20:	635a      	str	r2, [r3, #52]	; 0x34
  while ((RCC->CSR & RCC_CSR_LSERDY) == 0)
 8000a22:	6b4a      	ldr	r2, [r1, #52]	; 0x34
 8000a24:	4b0c      	ldr	r3, [pc, #48]	; (8000a58 <main+0x98>)
 8000a26:	0590      	lsls	r0, r2, #22
 8000a28:	d5fb      	bpl.n	8000a22 <main+0x62>
#endif

#if STM32_RTCSEL != STM32_RTCSEL_NOCLOCK
  /* If the backup domain hasn't been initialized yet then proceed with
     initialization.*/
  if ((RCC->CSR & RCC_CSR_RTCEN) == 0) {
 8000a2a:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8000a2c:	0251      	lsls	r1, r2, #9
 8000a2e:	d407      	bmi.n	8000a40 <main+0x80>
    /* Selects clock source.*/
    RCC->CSR |= STM32_RTCSEL;
 8000a30:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8000a32:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 8000a36:	635a      	str	r2, [r3, #52]	; 0x34

    /* RTC clock enabled.*/
    RCC->CSR |= RCC_CSR_RTCEN;
 8000a38:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8000a3a:	f442 0280 	orr.w	r2, r2, #4194304	; 0x400000
 8000a3e:	635a      	str	r2, [r3, #52]	; 0x34
 * @init
 */
void dmaInit(void) {
  int i;

  dma_streams_mask = 0U;
 8000a40:	f8df 9024 	ldr.w	r9, [pc, #36]	; 8000a68 <main+0xa8>
 8000a44:	2100      	movs	r1, #0
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
 8000a46:	460b      	mov	r3, r1
    _stm32_dma_streams[i].channel->CCR = 0U;
 8000a48:	460c      	mov	r4, r1
 8000a4a:	4a05      	ldr	r2, [pc, #20]	; (8000a60 <main+0xa0>)
 * @init
 */
void dmaInit(void) {
  int i;

  dma_streams_mask = 0U;
 8000a4c:	4805      	ldr	r0, [pc, #20]	; (8000a64 <main+0xa4>)
 8000a4e:	f8df a01c 	ldr.w	sl, [pc, #28]	; 8000a6c <main+0xac>
 8000a52:	f8c9 1000 	str.w	r1, [r9]
 8000a56:	e00d      	b.n	8000a74 <main+0xb4>
 8000a58:	40023800 	.word	0x40023800
 8000a5c:	40007000 	.word	0x40007000
 8000a60:	08001738 	.word	0x08001738
 8000a64:	40026008 	.word	0x40026008
 8000a68:	200009c0 	.word	0x200009c0
 8000a6c:	20000950 	.word	0x20000950
 8000a70:	f852 0c14 	ldr.w	r0, [r2, #-20]
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
    _stm32_dma_streams[i].channel->CCR = 0U;
 8000a74:	6004      	str	r4, [r0, #0]
    _stm32_dma_isr_redir[i].dma_func = NULL;
 8000a76:	f84a 4033 	str.w	r4, [sl, r3, lsl #3]
 */
void dmaInit(void) {
  int i;

  dma_streams_mask = 0U;
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
 8000a7a:	3301      	adds	r3, #1
 8000a7c:	2b07      	cmp	r3, #7
 8000a7e:	f102 0214 	add.w	r2, r2, #20
    _stm32_dma_streams[i].channel->CCR = 0U;
 8000a82:	f04f 0500 	mov.w	r5, #0
 */
void dmaInit(void) {
  int i;

  dma_streams_mask = 0U;
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
 8000a86:	d1f3      	bne.n	8000a70 <main+0xb0>
static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
 8000a88:	f64f 71ff 	movw	r1, #65535	; 0xffff
 8000a8c:	f64e 723f 	movw	r2, #61247	; 0xef3f
    _stm32_dma_streams[i].channel->CCR = 0U;
    _stm32_dma_isr_redir[i].dma_func = NULL;
  }
  DMA1->IFCR = 0xFFFFFFFFU;
 8000a90:	4fc6      	ldr	r7, [pc, #792]	; (8000dac <main+0x3ec>)
   */
#if defined(STM32L0XX)
  RCC->IOPENR |= AHB_EN_MASK;
  RCC->IOPSMENR |= AHB_LPEN_MASK;
#elif defined(STM32L1XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
 8000a92:	4bc7      	ldr	r3, [pc, #796]	; (8000db0 <main+0x3f0>)
 8000a94:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
#if STM32_ADC_USE_ADC1
  /* Driver initialization.*/
  adcObjectInit(&ADCD1);
  ADCD1.adc = ADC1;
  ADCD1.dmastp  = STM32_DMA1_STREAM1;
  ADCD1.dmamode = STM32_DMA_CR_PL(STM32_ADC_ADC1_DMA_PRIORITY) |
 8000a98:	f242 588a 	movw	r8, #9610	; 0x258a
 8000a9c:	6078      	str	r0, [r7, #4]
 8000a9e:	f8d3 e01c 	ldr.w	lr, [r3, #28]
 *
 * @init
 */
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {

  sdp->vmt = &vmt;
 8000aa2:	4ec4      	ldr	r6, [pc, #784]	; (8000db4 <main+0x3f4>)
 8000aa4:	f04e 0e3f 	orr.w	lr, lr, #63	; 0x3f
 8000aa8:	f8c3 e01c 	str.w	lr, [r3, #28]
 8000aac:	46b3      	mov	fp, r6
 8000aae:	f8d3 e028 	ldr.w	lr, [r3, #40]	; 0x28
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8000ab2:	f5a7 47c0 	sub.w	r7, r7, #24576	; 0x6000
   */
#if defined(STM32L0XX)
  RCC->IOPENR |= AHB_EN_MASK;
  RCC->IOPSMENR |= AHB_LPEN_MASK;
#elif defined(STM32L1XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
 8000ab6:	f04e 0e3f 	orr.w	lr, lr, #63	; 0x3f
 8000aba:	f8c3 e028 	str.w	lr, [r3, #40]	; 0x28
  RCC->AHBLPENR |= AHB_LPEN_MASK;
 8000abe:	f8d3 e028 	ldr.w	lr, [r3, #40]	; 0x28

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 8000ac2:	f647 4cff 	movw	ip, #31999	; 0x7cff
 8000ac6:	f04e 0e3f 	orr.w	lr, lr, #63	; 0x3f
 8000aca:	f8c3 e028 	str.w	lr, [r3, #40]	; 0x28
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
 8000ace:	f04f 4e7c 	mov.w	lr, #4227858432	; 0xfc000000
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8000ad2:	607d      	str	r5, [r7, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8000ad4:	f8c7 e008 	str.w	lr, [r7, #8]
  gpiop->PUPDR   = config->pupdr;
 8000ad8:	f8df e320 	ldr.w	lr, [pc, #800]	; 8000dfc <main+0x43c>
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk));             /* clear bits to change               */
 8000adc:	f64f 04ff 	movw	r4, #63743	; 0xf8ff
 8000ae0:	f8c7 e00c 	str.w	lr, [r7, #12]
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
  gpiop->AFRH    = config->afrh;
  gpiop->MODER   = config->moder;
 8000ae4:	f04f 4e28 	mov.w	lr, #2818572288	; 0xa8000000
static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
 8000ae8:	6179      	str	r1, [r7, #20]
  gpiop->AFRL    = config->afrl;
 8000aea:	623d      	str	r5, [r7, #32]
  gpiop->AFRH    = config->afrh;
 8000aec:	627d      	str	r5, [r7, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8000aee:	f8c7 e000 	str.w	lr, [r7]
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
 8000af2:	f8df e30c 	ldr.w	lr, [pc, #780]	; 8000e00 <main+0x440>
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8000af6:	f8c7 5404 	str.w	r5, [r7, #1028]	; 0x404
  gpiop->OSPEEDR = config->ospeedr;
 8000afa:	f8c7 e408 	str.w	lr, [r7, #1032]	; 0x408
  gpiop->PUPDR   = config->pupdr;
 8000afe:	f8df e304 	ldr.w	lr, [pc, #772]	; 8000e04 <main+0x444>
 8000b02:	f8c7 e40c 	str.w	lr, [r7, #1036]	; 0x40c
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
  gpiop->AFRH    = config->afrh;
  gpiop->MODER   = config->moder;
 8000b06:	f8df e300 	ldr.w	lr, [pc, #768]	; 8000e08 <main+0x448>
static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
 8000b0a:	f8c7 2414 	str.w	r2, [r7, #1044]	; 0x414
  gpiop->AFRL    = config->afrl;
 8000b0e:	f8c7 5420 	str.w	r5, [r7, #1056]	; 0x420
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8000b12:	4aa9      	ldr	r2, [pc, #676]	; (8000db8 <main+0x3f8>)
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
  gpiop->AFRH    = config->afrh;
 8000b14:	f8c7 5424 	str.w	r5, [r7, #1060]	; 0x424
  gpiop->MODER   = config->moder;
 8000b18:	f8c7 e400 	str.w	lr, [r7, #1024]	; 0x400

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
 8000b1c:	4fa7      	ldr	r7, [pc, #668]	; (8000dbc <main+0x3fc>)
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
 8000b1e:	f04f 4e70 	mov.w	lr, #4026531840	; 0xf0000000
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8000b22:	6055      	str	r5, [r2, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8000b24:	f8c2 e008 	str.w	lr, [r2, #8]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8000b28:	f8df e2e0 	ldr.w	lr, [pc, #736]	; 8000e0c <main+0x44c>
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
 8000b2c:	60d7      	str	r7, [r2, #12]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8000b2e:	4fa4      	ldr	r7, [pc, #656]	; (8000dc0 <main+0x400>)
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
 8000b30:	6151      	str	r1, [r2, #20]
  gpiop->AFRL    = config->afrl;
 8000b32:	6215      	str	r5, [r2, #32]
  gpiop->AFRH    = config->afrh;
 8000b34:	6255      	str	r5, [r2, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8000b36:	6015      	str	r5, [r2, #0]

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
 8000b38:	f04f 3255 	mov.w	r2, #1431655765	; 0x55555555
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8000b3c:	f8ce 5004 	str.w	r5, [lr, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8000b40:	f8ce 5008 	str.w	r5, [lr, #8]
  gpiop->PUPDR   = config->pupdr;
 8000b44:	f8ce 200c 	str.w	r2, [lr, #12]
  gpiop->ODR     = config->odr;
 8000b48:	f8ce 1014 	str.w	r1, [lr, #20]
  gpiop->AFRL    = config->afrl;
 8000b4c:	f8ce 5020 	str.w	r5, [lr, #32]
  gpiop->AFRH    = config->afrh;
 8000b50:	f8ce 5024 	str.w	r5, [lr, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8000b54:	f8ce 5000 	str.w	r5, [lr]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8000b58:	607d      	str	r5, [r7, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8000b5a:	60bd      	str	r5, [r7, #8]
  gpiop->PUPDR   = config->pupdr;
 8000b5c:	60fa      	str	r2, [r7, #12]
  gpiop->ODR     = config->odr;
 8000b5e:	6179      	str	r1, [r7, #20]
  gpiop->AFRL    = config->afrl;
 8000b60:	623d      	str	r5, [r7, #32]
  gpiop->AFRH    = config->afrh;
 8000b62:	627d      	str	r5, [r7, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8000b64:	603d      	str	r5, [r7, #0]
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
 8000b66:	270f      	movs	r7, #15
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8000b68:	f8ce 5804 	str.w	r5, [lr, #2052]	; 0x804
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
 8000b6c:	3a05      	subs	r2, #5
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
 8000b6e:	f8ce 7808 	str.w	r7, [lr, #2056]	; 0x808
 *
 * @init
 */
void adcObjectInit(ADCDriver *adcp) {

  adcp->state    = ADC_STOP;
 8000b72:	4f94      	ldr	r7, [pc, #592]	; (8000dc4 <main+0x404>)
  gpiop->PUPDR   = config->pupdr;
 8000b74:	f8ce 280c 	str.w	r2, [lr, #2060]	; 0x80c
  gpiop->ODR     = config->odr;
 8000b78:	f8ce 1814 	str.w	r1, [lr, #2068]	; 0x814
  gpiop->AFRL    = config->afrl;
 8000b7c:	f8ce 5820 	str.w	r5, [lr, #2080]	; 0x820
  gpiop->AFRH    = config->afrh;
 8000b80:	f8ce 5824 	str.w	r5, [lr, #2084]	; 0x824
  gpiop->MODER   = config->moder;
 8000b84:	f8ce 5800 	str.w	r5, [lr, #2048]	; 0x800
void adc_lld_init(void) {

#if STM32_ADC_USE_ADC1
  /* Driver initialization.*/
  adcObjectInit(&ADCD1);
  ADCD1.adc = ADC1;
 8000b88:	f5ae 4e68 	sub.w	lr, lr, #59392	; 0xe800
 8000b8c:	f8c7 e028 	str.w	lr, [r7, #40]	; 0x28
  ADCD1.dmastp  = STM32_DMA1_STREAM1;
 8000b90:	f8df e27c 	ldr.w	lr, [pc, #636]	; 8000e10 <main+0x450>

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8000b94:	4a8c      	ldr	r2, [pc, #560]	; (8000dc8 <main+0x408>)
  ADCD1.dmamode = STM32_DMA_CR_PL(STM32_ADC_ADC1_DMA_PRIORITY) |
 8000b96:	f8c7 8030 	str.w	r8, [r7, #48]	; 0x30

#if STM32_ADC_USE_ADC1
  /* Driver initialization.*/
  adcObjectInit(&ADCD1);
  ADCD1.adc = ADC1;
  ADCD1.dmastp  = STM32_DMA1_STREAM1;
 8000b9a:	f8c7 e02c 	str.w	lr, [r7, #44]	; 0x2c
 8000b9e:	f04f 0801 	mov.w	r8, #1
 8000ba2:	f04f 0e60 	mov.w	lr, #96	; 0x60
  adcp->config   = NULL;
 8000ba6:	607d      	str	r5, [r7, #4]
  adcp->samples  = NULL;
 8000ba8:	60bd      	str	r5, [r7, #8]
  adcp->depth    = 0;
 8000baa:	60fd      	str	r5, [r7, #12]
  adcp->grpp     = NULL;
 8000bac:	613d      	str	r5, [r7, #16]
#if ADC_USE_WAIT == TRUE
  adcp->thread   = NULL;
 8000bae:	617d      	str	r5, [r7, #20]
void chMtxObjectInit(mutex_t *mp) {

  chDbgCheck(mp != NULL);

  queue_init(&mp->m_queue);
  mp->m_owner = NULL;
 8000bb0:	623d      	str	r5, [r7, #32]
 *
 * @init
 */
void adcObjectInit(ADCDriver *adcp) {

  adcp->state    = ADC_STOP;
 8000bb2:	f887 8000 	strb.w	r8, [r7]
 8000bb6:	f882 e312 	strb.w	lr, [r2, #786]	; 0x312
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8000bba:	f44f 2e80 	mov.w	lr, #262144	; 0x40000
 8000bbe:	f8c2 e180 	str.w	lr, [r2, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8000bc2:	f8c2 e000 	str.w	lr, [r2]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8000bc6:	f107 0e18 	add.w	lr, r7, #24
 8000bca:	f8c7 e018 	str.w	lr, [r7, #24]
  tqp->p_prev = (thread_t *)tqp;
 8000bce:	f8c7 e01c 	str.w	lr, [r7, #28]
 8000bd2:	f8df e240 	ldr.w	lr, [pc, #576]	; 8000e14 <main+0x454>
 8000bd6:	f84b eb04 	str.w	lr, [fp], #4
 */
void chOQObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                    qnotify_t onfy, void *link) {

  chThdQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
 8000bda:	f04f 0e10 	mov.w	lr, #16
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {

  esp->es_next = (event_listener_t *)esp;
 8000bde:	f8c6 b004 	str.w	fp, [r6, #4]
 */
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {

  chThdQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
 8000be2:	6175      	str	r5, [r6, #20]
 */
void chOQObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                    qnotify_t onfy, void *link) {

  chThdQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
 8000be4:	f8c6 e038 	str.w	lr, [r6, #56]	; 0x38

#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  /* Free running counter mode.*/

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
 8000be8:	f8d3 b024 	ldr.w	fp, [r3, #36]	; 0x24
  osalEventObjectInit(&sdp->event);
  sdp->state = SD_STOP;
 8000bec:	f886 8008 	strb.w	r8, [r6, #8]
 8000bf0:	ea4b 0b08 	orr.w	fp, fp, r8
 8000bf4:	f8c3 b024 	str.w	fp, [r3, #36]	; 0x24

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 8000bf8:	f8df b21c 	ldr.w	fp, [pc, #540]	; 8000e18 <main+0x458>
  iqp->q_counter = 0;
  iqp->q_buffer  = bp;
  iqp->q_rdptr   = bp;
  iqp->q_wrptr   = bp;
  iqp->q_top     = bp + size;
  iqp->q_notify  = infy;
 8000bfc:	62b5      	str	r5, [r6, #40]	; 0x28
 8000bfe:	f8db 3008 	ldr.w	r3, [fp, #8]
  iqp->q_link    = link;
 8000c02:	62f6      	str	r6, [r6, #44]	; 0x2c
 8000c04:	ea43 0308 	orr.w	r3, r3, r8
  oqp->q_buffer  = bp;
  oqp->q_rdptr   = bp;
  oqp->q_wrptr   = bp;
  oqp->q_top     = bp + size;
  oqp->q_notify  = onfy;
  oqp->q_link    = link;
 8000c08:	6536      	str	r6, [r6, #80]	; 0x50
 8000c0a:	f8cb 3008 	str.w	r3, [fp, #8]

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 8000c0e:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8000c12:	f8c3 c028 	str.w	ip, [r3, #40]	; 0x28
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 8000c16:	62d9      	str	r1, [r3, #44]	; 0x2c
  oqp->q_counter = size;
  oqp->q_buffer  = bp;
  oqp->q_rdptr   = bp;
  oqp->q_wrptr   = bp;
  oqp->q_top     = bp + size;
  oqp->q_notify  = onfy;
 8000c18:	496c      	ldr	r1, [pc, #432]	; (8000dcc <main+0x40c>)
  STM32_ST_TIM->CCMR1  = 0;
 8000c1a:	619d      	str	r5, [r3, #24]
 8000c1c:	64f1      	str	r1, [r6, #76]	; 0x4c
 */
void sd_lld_init(void) {

#if STM32_SERIAL_USE_USART1
  sdObjectInit(&SD1, NULL, notify1);
  SD1.usart = USART1;
 8000c1e:	496c      	ldr	r1, [pc, #432]	; (8000dd0 <main+0x410>)
  STM32_ST_TIM->CCR[0] = 0;
 8000c20:	635d      	str	r5, [r3, #52]	; 0x34
 8000c22:	6771      	str	r1, [r6, #116]	; 0x74
  STM32_ST_TIM->DIER   = 0;
 8000c24:	60dd      	str	r5, [r3, #12]
  STM32_ST_TIM->CR2    = 0;
 8000c26:	605d      	str	r5, [r3, #4]
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
 8000c28:	f8c3 8014 	str.w	r8, [r3, #20]
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;
 8000c2c:	f8c3 8000 	str.w	r8, [r3]
  chThdQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
  oqp->q_buffer  = bp;
  oqp->q_rdptr   = bp;
  oqp->q_wrptr   = bp;
  oqp->q_top     = bp + size;
 8000c30:	f106 0374 	add.w	r3, r6, #116	; 0x74
 8000c34:	6433      	str	r3, [r6, #64]	; 0x40
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8000c36:	f106 030c 	add.w	r3, r6, #12
 8000c3a:	60f3      	str	r3, [r6, #12]
  tqp->p_prev = (thread_t *)tqp;
 8000c3c:	6133      	str	r3, [r6, #16]
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {

  chThdQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
  iqp->q_buffer  = bp;
 8000c3e:	f106 0354 	add.w	r3, r6, #84	; 0x54
 8000c42:	61b3      	str	r3, [r6, #24]
  iqp->q_rdptr   = bp;
 8000c44:	6273      	str	r3, [r6, #36]	; 0x24
  iqp->q_wrptr   = bp;
 8000c46:	6233      	str	r3, [r6, #32]
  iqp->q_top     = bp + size;
 8000c48:	f106 0364 	add.w	r3, r6, #100	; 0x64
 8000c4c:	61f3      	str	r3, [r6, #28]
void chOQObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                    qnotify_t onfy, void *link) {

  chThdQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
  oqp->q_buffer  = bp;
 8000c4e:	63f3      	str	r3, [r6, #60]	; 0x3c
  oqp->q_rdptr   = bp;
 8000c50:	64b3      	str	r3, [r6, #72]	; 0x48
  oqp->q_wrptr   = bp;
 8000c52:	6473      	str	r3, [r6, #68]	; 0x44
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8000c54:	f106 0330 	add.w	r3, r6, #48	; 0x30
 * @brief   Port-related initialization code.
 */
static inline void port_init(void) {

  /* Initialization of the vector table and priority related settings.*/
  SCB->VTOR = CORTEX_VTOR_INIT;
 8000c58:	495e      	ldr	r1, [pc, #376]	; (8000dd4 <main+0x414>)
 8000c5a:	6333      	str	r3, [r6, #48]	; 0x30
  tqp->p_prev = (thread_t *)tqp;
 8000c5c:	6373      	str	r3, [r6, #52]	; 0x34

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8000c5e:	2380      	movs	r3, #128	; 0x80
 8000c60:	f882 331c 	strb.w	r3, [r2, #796]	; 0x31c
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8000c64:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
 8000c68:	f8c2 3180 	str.w	r3, [r2, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8000c6c:	6013      	str	r3, [r2, #0]
 8000c6e:	608d      	str	r5, [r1, #8]
__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8000c70:	68ca      	ldr	r2, [r1, #12]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk));             /* clear bits to change               */
  reg_value  =  (reg_value                                   |
 8000c72:	4b59      	ldr	r3, [pc, #356]	; (8000dd8 <main+0x418>)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk));             /* clear bits to change               */
 8000c74:	4014      	ands	r4, r2
  reg_value  =  (reg_value                                   |
 8000c76:	4323      	orrs	r3, r4

  /* Initializing priority grouping.*/
  NVIC_SetPriorityGrouping(CORTEX_PRIGROUP_INIT);

  /* DWT cycle counter enable, note, the M7 requires DWT unlocking.*/
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 8000c78:	4c58      	ldr	r4, [pc, #352]	; (8000ddc <main+0x41c>)
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8)                       );              /* Insert write key and priorty group */
  SCB->AIRCR =  reg_value;
 8000c7a:	60cb      	str	r3, [r1, #12]
 8000c7c:	68e3      	ldr	r3, [r4, #12]
#if CORTEX_MODEL == 7
  DWT->LAR = 0xC5ACCE55U;
#endif
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 8000c7e:	4a58      	ldr	r2, [pc, #352]	; (8000de0 <main+0x420>)

  /* Initializing priority grouping.*/
  NVIC_SetPriorityGrouping(CORTEX_PRIGROUP_INIT);

  /* DWT cycle counter enable, note, the M7 requires DWT unlocking.*/
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 8000c80:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8000c84:	60e3      	str	r3, [r4, #12]
#if CORTEX_MODEL == 7
  DWT->LAR = 0xC5ACCE55U;
#endif
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 8000c86:	6813      	ldr	r3, [r2, #0]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8000c88:	4c56      	ldr	r4, [pc, #344]	; (8000de4 <main+0x424>)
 8000c8a:	ea43 0308 	orr.w	r3, r3, r8
 8000c8e:	6013      	str	r3, [r2, #0]
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if((int32_t)IRQn < 0) {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000c90:	f04f 0b20 	mov.w	fp, #32
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.vt_next = (virtual_timer_t *)&ch.vtlist;
 8000c94:	f104 031c 	add.w	r3, r4, #28
 8000c98:	f881 e01f 	strb.w	lr, [r1, #31]

  tmp->best       = (rtcnt_t)-1;
  tmp->worst      = (rtcnt_t)0;
  tmp->last       = (rtcnt_t)0;
  tmp->n          = (ucnt_t)0;
  tmp->cumulative = (rttime_t)0;
 8000c9c:	2200      	movs	r2, #0
 8000c9e:	f881 b022 	strb.w	fp, [r1, #34]	; 0x22
 * @init
 */
void chTMObjectInit(time_measurement_t *tmp) {

  tmp->best       = (rtcnt_t)-1;
  tmp->worst      = (rtcnt_t)0;
 8000ca2:	e88d 0021 	stmia.w	sp, {r0, r5}
  ch.vtlist.vt_prev = (virtual_timer_t *)&ch.vtlist;
  ch.vtlist.vt_delta = (systime_t)-1;
 8000ca6:	84a0      	strh	r0, [r4, #36]	; 0x24
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.vt_next = (virtual_timer_t *)&ch.vtlist;
 8000ca8:	61e3      	str	r3, [r4, #28]
  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = (rtcnt_t)0;
  chTMObjectInit(&tm);
  chTMStartMeasurementX(&tm);
 8000caa:	4668      	mov	r0, sp
  ch.vtlist.vt_prev = (virtual_timer_t *)&ch.vtlist;
 8000cac:	6223      	str	r3, [r4, #32]
 8000cae:	6024      	str	r4, [r4, #0]

  tmp->best       = (rtcnt_t)-1;
  tmp->worst      = (rtcnt_t)0;
  tmp->last       = (rtcnt_t)0;
  tmp->n          = (ucnt_t)0;
  tmp->cumulative = (rttime_t)0;
 8000cb0:	2300      	movs	r3, #0
  tqp->p_prev = (thread_t *)tqp;
 8000cb2:	6064      	str	r4, [r4, #4]
 8000cb4:	e9cd 2304 	strd	r2, r3, [sp, #16]
 */
void chTMObjectInit(time_measurement_t *tmp) {

  tmp->best       = (rtcnt_t)-1;
  tmp->worst      = (rtcnt_t)0;
  tmp->last       = (rtcnt_t)0;
 8000cb8:	9502      	str	r5, [sp, #8]
  tmp->n          = (ucnt_t)0;
 8000cba:	9503      	str	r5, [sp, #12]
 * @notapi
 */
void _scheduler_init(void) {

  queue_init(&ch.rlist.r_queue);
  ch.rlist.r_prio = NOPRIO;
 8000cbc:	60a5      	str	r5, [r4, #8]
#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.r_newer = (thread_t *)&ch.rlist;
 8000cbe:	6124      	str	r4, [r4, #16]
  ch.rlist.r_older = (thread_t *)&ch.rlist;
 8000cc0:	6164      	str	r4, [r4, #20]
  ch.vtlist.vt_delta = (systime_t)-1;
#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.vt_systime = (systime_t)0;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  ch.vtlist.vt_lasttime = (systime_t)0;
 8000cc2:	84e5      	strh	r5, [r4, #38]	; 0x26
  time_measurement_t tm;

  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = (rtcnt_t)0;
 8000cc4:	6725      	str	r5, [r4, #112]	; 0x70
  chTMObjectInit(&tm);
  chTMStartMeasurementX(&tm);
 8000cc6:	f000 fc73 	bl	80015b0 <chTMStartMeasurementX.constprop.22>
  chTMStopMeasurementX(&tm);
 8000cca:	4668      	mov	r0, sp
 8000ccc:	f7ff fc20 	bl	8000510 <chTMStopMeasurementX>
 *
 * @notapi
 */
void _heap_init(void) {

  default_heap.h_provider = chCoreAlloc;
 8000cd0:	4a45      	ldr	r2, [pc, #276]	; (8000de8 <main+0x428>)
  ch.tm.offset = tm.last;
 8000cd2:	9b02      	ldr	r3, [sp, #8]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8000cd4:	f102 0c10 	add.w	ip, r2, #16
 8000cd8:	f8c2 c010 	str.w	ip, [r2, #16]
  tqp->p_prev = (thread_t *)tqp;
 8000cdc:	f8c2 c014 	str.w	ip, [r2, #20]
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
 8000ce0:	f04f 0c40 	mov.w	ip, #64	; 0x40
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 8000ce4:	f8d4 e014 	ldr.w	lr, [r4, #20]
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
 8000ce8:	f8c4 c034 	str.w	ip, [r4, #52]	; 0x34
  tp->p_flags = CH_FLAG_MODE_STATIC;
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
 8000cec:	f8c4 c068 	str.w	ip, [r4, #104]	; 0x68
 8000cf0:	f8df c128 	ldr.w	ip, [pc, #296]	; 8000e1c <main+0x45c>
 8000cf4:	6723      	str	r3, [r4, #112]	; 0x70
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  nextmem = (uint8_t *)MEM_ALIGN_NEXT(__heap_base__);
 8000cf6:	483d      	ldr	r0, [pc, #244]	; (8000dec <main+0x42c>)
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 8000cf8:	f104 032c 	add.w	r3, r4, #44	; 0x2c
  endmem = (uint8_t *)MEM_ALIGN_PREV(__heap_end__);
 8000cfc:	493c      	ldr	r1, [pc, #240]	; (8000df0 <main+0x430>)
 8000cfe:	f8c4 e040 	str.w	lr, [r4, #64]	; 0x40
 8000d02:	6195      	str	r5, [r2, #24]
 8000d04:	f8c2 c000 	str.w	ip, [r2]
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
  tp->p_flags = CH_FLAG_MODE_STATIC;
 8000d08:	f884 5049 	strb.w	r5, [r4, #73]	; 0x49
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
  tp->p_mtxlist = NULL;
 8000d0c:	6665      	str	r5, [r4, #100]	; 0x64
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->p_epending = (eventmask_t)0;
 8000d0e:	6625      	str	r5, [r4, #96]	; 0x60
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
 8000d10:	f884 804a 	strb.w	r8, [r4, #74]	; 0x4a
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
 8000d14:	6465      	str	r5, [r4, #68]	; 0x44
  REG_INSERT(tp);
 8000d16:	63e4      	str	r4, [r4, #60]	; 0x3c
  default_heap.h_free.h.u.next = NULL;
 8000d18:	6095      	str	r5, [r2, #8]
 8000d1a:	f8ce 3010 	str.w	r3, [lr, #16]
  default_heap.h_free.h.size = 0;
 8000d1e:	60d5      	str	r5, [r2, #12]
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  nextmem = (uint8_t *)MEM_ALIGN_NEXT(__heap_base__);
 8000d20:	f8df e0fc 	ldr.w	lr, [pc, #252]	; 8000e20 <main+0x460>
 8000d24:	6163      	str	r3, [r4, #20]
  _dbg_trace_init();
#endif

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
  setcurrp(_thread_init(&ch.mainthread, NORMALPRIO));
 8000d26:	61a3      	str	r3, [r4, #24]
  endmem = (uint8_t *)MEM_ALIGN_PREV(__heap_end__);
 8000d28:	4a32      	ldr	r2, [pc, #200]	; (8000df4 <main+0x434>)
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->p_next = (thread_t *)tlp;
 8000d2a:	f104 0350 	add.w	r3, r4, #80	; 0x50
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  nextmem = (uint8_t *)MEM_ALIGN_NEXT(__heap_base__);
 8000d2e:	f020 0007 	bic.w	r0, r0, #7
  endmem = (uint8_t *)MEM_ALIGN_PREV(__heap_end__);
 8000d32:	f021 0107 	bic.w	r1, r1, #7
 8000d36:	6523      	str	r3, [r4, #80]	; 0x50
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8000d38:	f104 0354 	add.w	r3, r4, #84	; 0x54
#else
  /* Now this instructions flow becomes the idle thread.*/
  setcurrp(_thread_init(&ch.mainthread, IDLEPRIO));
#endif

  currp->p_state = CH_STATE_CURRENT;
 8000d3c:	f884 8048 	strb.w	r8, [r4, #72]	; 0x48
 8000d40:	6563      	str	r3, [r4, #84]	; 0x54
  tqp->p_prev = (thread_t *)tqp;
 8000d42:	65a3      	str	r3, [r4, #88]	; 0x58
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  nextmem = (uint8_t *)MEM_ALIGN_NEXT(__heap_base__);
 8000d44:	f8ce 0000 	str.w	r0, [lr]
  endmem = (uint8_t *)MEM_ALIGN_PREV(__heap_end__);
 8000d48:	6011      	str	r1, [r2, #0]
 8000d4a:	f385 8811 	msr	BASEPRI, r5
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000d4e:	b662      	cpsie	i
 * @api
 */
static inline void chRegSetThreadName(const char *name) {

#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.r_current->p_name = name;
 8000d50:	4a29      	ldr	r2, [pc, #164]	; (8000df8 <main+0x438>)
 8000d52:	69a3      	ldr	r3, [r4, #24]
 8000d54:	619a      	str	r2, [r3, #24]

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8000d56:	f38b 8811 	msr	BASEPRI, fp

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 8000d5a:	f8df e0c8 	ldr.w	lr, [pc, #200]	; 8000e24 <main+0x464>
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 8000d5e:	6961      	ldr	r1, [r4, #20]

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 8000d60:	f8df c0c4 	ldr.w	ip, [pc, #196]	; 8000e28 <main+0x468>
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
 8000d64:	2002      	movs	r0, #2
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 8000d66:	f104 0278 	add.w	r2, r4, #120	; 0x78

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio) {
 8000d6a:	69a3      	ldr	r3, [r4, #24]

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 8000d6c:	f504 7b96 	add.w	fp, r4, #300	; 0x12c
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
 8000d70:	f884 0094 	strb.w	r0, [r4, #148]	; 0x94
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
 8000d74:	f8c4 8080 	str.w	r8, [r4, #128]	; 0x80
  tp->p_state = CH_STATE_WTSTART;
  tp->p_flags = CH_FLAG_MODE_STATIC;
 8000d78:	f884 5095 	strb.w	r5, [r4, #149]	; 0x95
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
 8000d7c:	f8c4 80b4 	str.w	r8, [r4, #180]	; 0xb4
  tp->p_mtxlist = NULL;
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->p_epending = (eventmask_t)0;
 8000d80:	f8c4 50ac 	str.w	r5, [r4, #172]	; 0xac
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
 8000d84:	f884 8096 	strb.w	r8, [r4, #150]	; 0x96

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 8000d88:	f8c4 e14c 	str.w	lr, [r4, #332]	; 0x14c
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 8000d8c:	f8c4 108c 	str.w	r1, [r4, #140]	; 0x8c

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 8000d90:	f8c4 5130 	str.w	r5, [r4, #304]	; 0x130
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
  tp->p_mtxlist = NULL;
 8000d94:	f8c4 50b0 	str.w	r5, [r4, #176]	; 0xb0
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
 8000d98:	f8c4 5090 	str.w	r5, [r4, #144]	; 0x90
  REG_INSERT(tp);
 8000d9c:	f8c4 4088 	str.w	r4, [r4, #136]	; 0x88

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 8000da0:	f8c4 b084 	str.w	fp, [r4, #132]	; 0x84
 8000da4:	f8c4 c12c 	str.w	ip, [r4, #300]	; 0x12c
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 8000da8:	610a      	str	r2, [r1, #16]
 8000daa:	e03f      	b.n	8000e2c <main+0x46c>
 8000dac:	40026000 	.word	0x40026000
 8000db0:	40023800 	.word	0x40023800
 8000db4:	200009e8 	.word	0x200009e8
 8000db8:	40020800 	.word	0x40020800
 8000dbc:	05555556 	.word	0x05555556
 8000dc0:	40021000 	.word	0x40021000
 8000dc4:	20000988 	.word	0x20000988
 8000dc8:	e000e100 	.word	0xe000e100
 8000dcc:	08000291 	.word	0x08000291
 8000dd0:	40013800 	.word	0x40013800
 8000dd4:	e000ed00 	.word	0xe000ed00
 8000dd8:	05fa0300 	.word	0x05fa0300
 8000ddc:	e000edf0 	.word	0xe000edf0
 8000de0:	e0001000 	.word	0xe0001000
 8000de4:	20000800 	.word	0x20000800
 8000de8:	200009c8 	.word	0x200009c8
 8000dec:	20000a67 	.word	0x20000a67
 8000df0:	20004000 	.word	0x20004000
 8000df4:	200009bc 	.word	0x200009bc
 8000df8:	08001830 	.word	0x08001830
 8000dfc:	65555a68 	.word	0x65555a68
 8000e00:	0300f3f0 	.word	0x0300f3f0
 8000e04:	54550505 	.word	0x54550505
 8000e08:	01005280 	.word	0x01005280
 8000e0c:	40020c00 	.word	0x40020c00
 8000e10:	08001720 	.word	0x08001720
 8000e14:	08001700 	.word	0x08001700
 8000e18:	e0042000 	.word	0xe0042000
 8000e1c:	08000251 	.word	0x08000251
 8000e20:	200009c4 	.word	0x200009c4
 8000e24:	08000221 	.word	0x08000221
 8000e28:	08000241 	.word	0x08000241
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  /* Storing the message to be retrieved by the target thread when it will
     restart execution.*/
  ntp->p_u.rdymsg = msg;
 8000e2c:	f8c4 5098 	str.w	r5, [r4, #152]	; 0x98

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio) {
 8000e30:	6899      	ldr	r1, [r3, #8]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8000e32:	f104 00a0 	add.w	r0, r4, #160	; 0xa0
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->p_next = (thread_t *)tlp;
 8000e36:	f104 0e9c 	add.w	lr, r4, #156	; 0x9c
 8000e3a:	6162      	str	r2, [r4, #20]
 8000e3c:	f8c4 e09c 	str.w	lr, [r4, #156]	; 0x9c
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8000e40:	f8c4 00a0 	str.w	r0, [r4, #160]	; 0xa0
  tqp->p_prev = (thread_t *)tqp;
 8000e44:	f8c4 00a4 	str.w	r0, [r4, #164]	; 0xa4
 8000e48:	2900      	cmp	r1, #0
 8000e4a:	d05c      	beq.n	8000f06 <main+0x546>
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
  cp = (thread_t *)&ch.rlist.r_queue;
 8000e4c:	4623      	mov	r3, r4
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 8000e4e:	f884 5094 	strb.w	r5, [r4, #148]	; 0x94
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
 8000e52:	681b      	ldr	r3, [r3, #0]
  } while (cp->p_prio >= tp->p_prio);
 8000e54:	6899      	ldr	r1, [r3, #8]
 8000e56:	2900      	cmp	r1, #0
 8000e58:	d1fb      	bne.n	8000e52 <main+0x492>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
 8000e5a:	67a3      	str	r3, [r4, #120]	; 0x78
  tp->p_prev = cp->p_prev;
 8000e5c:	6858      	ldr	r0, [r3, #4]
 8000e5e:	67e0      	str	r0, [r4, #124]	; 0x7c
  tp->p_prev->p_next = tp;
 8000e60:	6002      	str	r2, [r0, #0]
  cp->p_prev = tp;
 8000e62:	605a      	str	r2, [r3, #4]
 8000e64:	f381 8811 	msr	BASEPRI, r1
 * @xclass
 */
static inline void chRegSetThreadNameX(thread_t *tp, const char *name) {

#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = name;
 8000e68:	4b59      	ldr	r3, [pc, #356]	; (8000fd0 <main+0x610>)
 8000e6a:	2220      	movs	r2, #32
 8000e6c:	f8c4 3090 	str.w	r3, [r4, #144]	; 0x90
 8000e70:	f382 8811 	msr	BASEPRI, r2
void sd_lld_start(SerialDriver *sdp, const SerialConfig *config) {

  if (config == NULL)
    config = &default_config;

  if (sdp->state == SD_STOP) {
 8000e74:	7a33      	ldrb	r3, [r6, #8]
 8000e76:	2b01      	cmp	r3, #1
 8000e78:	f000 809d 	beq.w	8000fb6 <main+0x5f6>
#if STM32_HAS_USART6
  if ((sdp->usart == USART1) || (sdp->usart == USART6))
#else
  if (sdp->usart == USART1)
#endif
    u->BRR = STM32_PCLK2 / config->speed;
 8000e7c:	f240 3241 	movw	r2, #833	; 0x341
 *
 * @param[in] sdp       pointer to a @p SerialDriver object
 * @param[in] config    the architecture-dependent serial driver configuration
 */
static void usart_init(SerialDriver *sdp, const SerialConfig *config) {
  USART_TypeDef *u = sdp->usart;
 8000e80:	6f73      	ldr	r3, [r6, #116]	; 0x74
    u->BRR = STM32_PCLK2 / config->speed;
  else
    u->BRR = STM32_PCLK1 / config->speed;

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 8000e82:	f244 0040 	movw	r0, #16448	; 0x4040
#if STM32_HAS_USART6
  if ((sdp->usart == USART1) || (sdp->usart == USART6))
#else
  if (sdp->usart == USART1)
#endif
    u->BRR = STM32_PCLK2 / config->speed;
 8000e86:	609a      	str	r2, [r3, #8]
    u->BRR = STM32_PCLK1 / config->speed;

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
  u->CR3 = config->cr3 | USART_CR3_EIE;
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
 8000e88:	f242 122c 	movw	r2, #8492	; 0x212c
  else
    u->BRR = STM32_PCLK1 / config->speed;

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
  u->CR3 = config->cr3 | USART_CR3_EIE;
 8000e8c:	2101      	movs	r1, #1
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
                         USART_CR1_RXNEIE | USART_CR1_TE |
                         USART_CR1_RE;
  u->SR = 0;
 8000e8e:	2400      	movs	r4, #0
    u->BRR = STM32_PCLK2 / config->speed;
  else
    u->BRR = STM32_PCLK1 / config->speed;

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 8000e90:	6118      	str	r0, [r3, #16]
  u->CR3 = config->cr3 | USART_CR3_EIE;
 8000e92:	6159      	str	r1, [r3, #20]
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
 8000e94:	60da      	str	r2, [r3, #12]
                         USART_CR1_RXNEIE | USART_CR1_TE |
                         USART_CR1_RE;
  u->SR = 0;
 8000e96:	601c      	str	r4, [r3, #0]

  osalSysLock();
  osalDbgAssert((sdp->state == SD_STOP) || (sdp->state == SD_READY),
                "invalid state");
  sd_lld_start(sdp, config);
  sdp->state = SD_READY;
 8000e98:	2202      	movs	r2, #2
  (void)u->SR;  /* SR reset step 1.*/
 8000e9a:	6819      	ldr	r1, [r3, #0]
  (void)u->DR;  /* SR reset step 2.*/
 8000e9c:	685b      	ldr	r3, [r3, #4]
 8000e9e:	7232      	strb	r2, [r6, #8]
 8000ea0:	f384 8811 	msr	BASEPRI, r4
  /*
   * Activates the serial driver 1 using the driver default configuration.
   * PA9(TX) and PA10(RX) are routed to USART1.
   */
  sdStart(&SD1, NULL);
  palSetPadMode(GPIOA, 9, PAL_MODE_ALTERNATE(7));
 8000ea4:	f44f 7000 	mov.w	r0, #512	; 0x200
 8000ea8:	f000 fbc2 	bl	8001630 <_pal_lld_setgroupmode.constprop.2>
  palSetPadMode(GPIOA, 10, PAL_MODE_ALTERNATE(7));
 8000eac:	f44f 6080 	mov.w	r0, #1024	; 0x400
 8000eb0:	f000 fbbe 	bl	8001630 <_pal_lld_setgroupmode.constprop.2>
 8000eb4:	2320      	movs	r3, #32
 8000eb6:	f383 8811 	msr	BASEPRI, r3
 * @notapi
 */
void adc_lld_start(ADCDriver *adcp) {

  /* If in stopped state then enables the ADC and DMA clocks.*/
  if (adcp->state == ADC_STOP) {
 8000eba:	783a      	ldrb	r2, [r7, #0]
  osalDbgCheck(adcp != NULL);

  osalSysLock();
  osalDbgAssert((adcp->state == ADC_STOP) || (adcp->state == ADC_READY),
                "invalid state");
  adcp->config = config;
 8000ebc:	607c      	str	r4, [r7, #4]
 8000ebe:	2a01      	cmp	r2, #1
 8000ec0:	4c44      	ldr	r4, [pc, #272]	; (8000fd4 <main+0x614>)
 8000ec2:	d022      	beq.n	8000f0a <main+0x54a>
  adc_lld_start(adcp);
  adcp->state = ADC_READY;
 8000ec4:	2302      	movs	r3, #2
 8000ec6:	703b      	strb	r3, [r7, #0]
 8000ec8:	2300      	movs	r3, #0
 8000eca:	f383 8811 	msr	BASEPRI, r3
	  palSetPad(GPIOB, 15);
	  palSetPad(GPIOB, 10);
	  palSetPad(GPIOB, 11);
	  palSetPad(GPIOB, 1);
	  palSetPad(GPIOB, 2);*/
	  palSetPad(GPIOB, 12);
 8000ece:	f44f 5780 	mov.w	r7, #4096	; 0x1000
 8000ed2:	46b8      	mov	r8, r7
 8000ed4:	4e40      	ldr	r6, [pc, #256]	; (8000fd8 <main+0x618>)
 8000ed6:	f8a6 8018 	strh.w	r8, [r6, #24]
 8000eda:	2520      	movs	r5, #32
 8000edc:	f385 8811 	msr	BASEPRI, r5
 */
static inline void chThdSleepS(systime_t time) {

  chDbgCheck(time != TIME_IMMEDIATE);

  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, time);
 8000ee0:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 8000ee4:	2008      	movs	r0, #8
 8000ee6:	f7ff fb93 	bl	8000610 <chSchGoSleepTimeoutS>
 8000eea:	2400      	movs	r4, #0
 8000eec:	f384 8811 	msr	BASEPRI, r4
	  palClearPad(GPIOB, 15);
	  palClearPad(GPIOB, 10);
	  palClearPad(GPIOB, 11);
	  palClearPad(GPIOB, 1);
	  palClearPad(GPIOB, 2);*/
	  palClearPad(GPIOB, 12);
 8000ef0:	8377      	strh	r7, [r6, #26]
 8000ef2:	f385 8811 	msr	BASEPRI, r5
 8000ef6:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 8000efa:	2008      	movs	r0, #8
 8000efc:	f7ff fb88 	bl	8000610 <chSchGoSleepTimeoutS>
 8000f00:	f384 8811 	msr	BASEPRI, r4
 8000f04:	e7e7      	b.n	8000ed6 <main+0x516>
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 8000f06:	7719      	strb	r1, [r3, #28]
 8000f08:	e7fe      	b.n	8000f08 <main+0x548>
#if STM32_ADC_USE_ADC1
    if (&ADCD1 == adcp) {
      bool b = dmaStreamAllocate(adcp->dmastp,
 8000f0a:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
                       void *param) {

  osalDbgCheck(dmastp != NULL);

  /* Checks if the stream is already taken.*/
  if ((dma_streams_mask & (1U << dmastp->selfindex)) != 0U)
 8000f0c:	f8d9 1000 	ldr.w	r1, [r9]
 8000f10:	7c58      	ldrb	r0, [r3, #17]
 8000f12:	4082      	lsls	r2, r0
 8000f14:	420a      	tst	r2, r1
 8000f16:	d14c      	bne.n	8000fb2 <main+0x5f2>
    return true;

  /* Installs the DMA handler.*/
  _stm32_dma_isr_redir[dmastp->selfindex].dma_func  = func;
  _stm32_dma_isr_redir[dmastp->selfindex].dma_param = param;
 8000f18:	eb0a 02c0 	add.w	r2, sl, r0, lsl #3
  /* Checks if the stream is already taken.*/
  if ((dma_streams_mask & (1U << dmastp->selfindex)) != 0U)
    return true;

  /* Installs the DMA handler.*/
  _stm32_dma_isr_redir[dmastp->selfindex].dma_func  = func;
 8000f1c:	4d2f      	ldr	r5, [pc, #188]	; (8000fdc <main+0x61c>)
  _stm32_dma_isr_redir[dmastp->selfindex].dma_param = param;
 8000f1e:	6054      	str	r4, [r2, #4]

  /* Enabling DMA clocks required by the current streams set.*/
  if ((dma_streams_mask & STM32_DMA1_STREAMS_MASK) == 0U) {
 8000f20:	064a      	lsls	r2, r1, #25
  /* Checks if the stream is already taken.*/
  if ((dma_streams_mask & (1U << dmastp->selfindex)) != 0U)
    return true;

  /* Installs the DMA handler.*/
  _stm32_dma_isr_redir[dmastp->selfindex].dma_func  = func;
 8000f22:	f84a 5030 	str.w	r5, [sl, r0, lsl #3]
  _stm32_dma_isr_redir[dmastp->selfindex].dma_param = param;

  /* Enabling DMA clocks required by the current streams set.*/
  if ((dma_streams_mask & STM32_DMA1_STREAMS_MASK) == 0U) {
 8000f26:	d104      	bne.n	8000f32 <main+0x572>
    rccEnableDMA1(false);
 8000f28:	482d      	ldr	r0, [pc, #180]	; (8000fe0 <main+0x620>)
 8000f2a:	69c2      	ldr	r2, [r0, #28]
 8000f2c:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 8000f30:	61c2      	str	r2, [r0, #28]
    rccEnableDMA2(false);
  }
#endif

  /* Putting the stream in a safe state.*/
  dmaStreamDisable(dmastp);
 8000f32:	685a      	ldr	r2, [r3, #4]
 8000f34:	681d      	ldr	r5, [r3, #0]
 8000f36:	6814      	ldr	r4, [r2, #0]
 8000f38:	200f      	movs	r0, #15
 8000f3a:	f024 040f 	bic.w	r4, r4, #15
 8000f3e:	6014      	str	r4, [r2, #0]
 8000f40:	7c1e      	ldrb	r6, [r3, #16]
  dmastp->channel->CCR = STM32_DMA_CCR_RESET_VALUE;

  /* Enables the associated IRQ vector if not alread enabled and if a
     callback is defined.*/
  if (((dma_streams_mask & dmastp->cmask) == 0U) &&
 8000f42:	689c      	ldr	r4, [r3, #8]
    rccEnableDMA2(false);
  }
#endif

  /* Putting the stream in a safe state.*/
  dmaStreamDisable(dmastp);
 8000f44:	40b0      	lsls	r0, r6
 8000f46:	6068      	str	r0, [r5, #4]
  dmastp->channel->CCR = STM32_DMA_CCR_RESET_VALUE;

  /* Enables the associated IRQ vector if not alread enabled and if a
     callback is defined.*/
  if (((dma_streams_mask & dmastp->cmask) == 0U) &&
 8000f48:	4221      	tst	r1, r4
  }
#endif

  /* Putting the stream in a safe state.*/
  dmaStreamDisable(dmastp);
  dmastp->channel->CCR = STM32_DMA_CCR_RESET_VALUE;
 8000f4a:	f04f 0000 	mov.w	r0, #0
 8000f4e:	6010      	str	r0, [r2, #0]

  /* Enables the associated IRQ vector if not alread enabled and if a
     callback is defined.*/
  if (((dma_streams_mask & dmastp->cmask) == 0U) &&
 8000f50:	d116      	bne.n	8000f80 <main+0x5c0>
      (func != NULL)) {
    nvicEnableVector(dmastp->vector, priority);
 8000f52:	7c98      	ldrb	r0, [r3, #18]
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8000f54:	2401      	movs	r4, #1
 8000f56:	0942      	lsrs	r2, r0, #5
 8000f58:	0092      	lsls	r2, r2, #2

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8000f5a:	f100 4560 	add.w	r5, r0, #3758096384	; 0xe0000000
 8000f5e:	f102 4260 	add.w	r2, r2, #3758096384	; 0xe0000000
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8000f62:	f000 001f 	and.w	r0, r0, #31
 8000f66:	f502 4261 	add.w	r2, r2, #57600	; 0xe100
 8000f6a:	fa04 f000 	lsl.w	r0, r4, r0

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8000f6e:	2660      	movs	r6, #96	; 0x60
 8000f70:	f505 4561 	add.w	r5, r5, #57600	; 0xe100
 8000f74:	f885 6300 	strb.w	r6, [r5, #768]	; 0x300
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8000f78:	f8c2 0180 	str.w	r0, [r2, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8000f7c:	6010      	str	r0, [r2, #0]
 8000f7e:	685a      	ldr	r2, [r3, #4]
  }

  /* Marks the stream as allocated.*/
  dma_streams_mask |= (1U << dmastp->selfindex);
 8000f80:	7c58      	ldrb	r0, [r3, #17]
 8000f82:	2301      	movs	r3, #1
 8000f84:	4083      	lsls	r3, r0
 8000f86:	4319      	orrs	r1, r3
 8000f88:	f8c9 1000 	str.w	r1, [r9]
                                 STM32_ADC_ADC1_DMA_IRQ_PRIORITY,
                                 (stm32_dmaisr_t)adc_lld_serve_rx_interrupt,
                                 (void *)adcp);
      osalDbgAssert(!b, "stream already allocated");
      dmaStreamSetPeripheral(adcp->dmastp, &ADC1->DR);
 8000f8c:	4b15      	ldr	r3, [pc, #84]	; (8000fe4 <main+0x624>)
      rccEnableADC1(FALSE);
 8000f8e:	4914      	ldr	r1, [pc, #80]	; (8000fe0 <main+0x620>)
      bool b = dmaStreamAllocate(adcp->dmastp,
                                 STM32_ADC_ADC1_DMA_IRQ_PRIORITY,
                                 (stm32_dmaisr_t)adc_lld_serve_rx_interrupt,
                                 (void *)adcp);
      osalDbgAssert(!b, "stream already allocated");
      dmaStreamSetPeripheral(adcp->dmastp, &ADC1->DR);
 8000f90:	6093      	str	r3, [r2, #8]
      rccEnableADC1(FALSE);
 8000f92:	6a0b      	ldr	r3, [r1, #32]
    }
#endif /* STM32_ADC_USE_ADC1 */

    ADC->CCR = (ADC->CCR & ADC_CCR_TSVREFE) | (STM32_ADC_ADCPRE << 16);
 8000f94:	4814      	ldr	r0, [pc, #80]	; (8000fe8 <main+0x628>)
                                 STM32_ADC_ADC1_DMA_IRQ_PRIORITY,
                                 (stm32_dmaisr_t)adc_lld_serve_rx_interrupt,
                                 (void *)adcp);
      osalDbgAssert(!b, "stream already allocated");
      dmaStreamSetPeripheral(adcp->dmastp, &ADC1->DR);
      rccEnableADC1(FALSE);
 8000f96:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8000f9a:	620b      	str	r3, [r1, #32]
    }
#endif /* STM32_ADC_USE_ADC1 */

    ADC->CCR = (ADC->CCR & ADC_CCR_TSVREFE) | (STM32_ADC_ADCPRE << 16);
 8000f9c:	6842      	ldr	r2, [r0, #4]

    /* ADC initial setup, starting the analog part here in order to reduce
       the latency when starting a conversion.*/
    adcp->adc->CR1 = 0;
 8000f9e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8000fa0:	2100      	movs	r1, #0
      dmaStreamSetPeripheral(adcp->dmastp, &ADC1->DR);
      rccEnableADC1(FALSE);
    }
#endif /* STM32_ADC_USE_ADC1 */

    ADC->CCR = (ADC->CCR & ADC_CCR_TSVREFE) | (STM32_ADC_ADCPRE << 16);
 8000fa2:	f402 0200 	and.w	r2, r2, #8388608	; 0x800000

    /* ADC initial setup, starting the analog part here in order to reduce
       the latency when starting a conversion.*/
    adcp->adc->CR1 = 0;
    adcp->adc->CR2 = 0;
    adcp->adc->CR2 = ADC_CR2_ADON;
 8000fa6:	2401      	movs	r4, #1
      dmaStreamSetPeripheral(adcp->dmastp, &ADC1->DR);
      rccEnableADC1(FALSE);
    }
#endif /* STM32_ADC_USE_ADC1 */

    ADC->CCR = (ADC->CCR & ADC_CCR_TSVREFE) | (STM32_ADC_ADCPRE << 16);
 8000fa8:	6042      	str	r2, [r0, #4]

    /* ADC initial setup, starting the analog part here in order to reduce
       the latency when starting a conversion.*/
    adcp->adc->CR1 = 0;
 8000faa:	6059      	str	r1, [r3, #4]
    adcp->adc->CR2 = 0;
 8000fac:	6099      	str	r1, [r3, #8]
    adcp->adc->CR2 = ADC_CR2_ADON;
 8000fae:	609c      	str	r4, [r3, #8]
 8000fb0:	e788      	b.n	8000ec4 <main+0x504>
 8000fb2:	685a      	ldr	r2, [r3, #4]
 8000fb4:	e7ea      	b.n	8000f8c <main+0x5cc>
    config = &default_config;

  if (sdp->state == SD_STOP) {
#if STM32_SERIAL_USE_USART1
    if (&SD1 == sdp) {
      rccEnableUSART1(FALSE);
 8000fb6:	480a      	ldr	r0, [pc, #40]	; (8000fe0 <main+0x620>)

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8000fb8:	4b0c      	ldr	r3, [pc, #48]	; (8000fec <main+0x62c>)
 8000fba:	6a01      	ldr	r1, [r0, #32]
 8000fbc:	24c0      	movs	r4, #192	; 0xc0
 8000fbe:	f441 4180 	orr.w	r1, r1, #16384	; 0x4000
 8000fc2:	6201      	str	r1, [r0, #32]
 8000fc4:	f883 4325 	strb.w	r4, [r3, #805]	; 0x325
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8000fc8:	f8c3 2184 	str.w	r2, [r3, #388]	; 0x184
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8000fcc:	605a      	str	r2, [r3, #4]
 8000fce:	e755      	b.n	8000e7c <main+0x4bc>
 8000fd0:	08001850 	.word	0x08001850
 8000fd4:	20000988 	.word	0x20000988
 8000fd8:	40020400 	.word	0x40020400
 8000fdc:	080013b1 	.word	0x080013b1
 8000fe0:	40023800 	.word	0x40023800
 8000fe4:	40012458 	.word	0x40012458
 8000fe8:	40012700 	.word	0x40012700
 8000fec:	e000e100 	.word	0xe000e100

08000ff0 <__early_init>:
 */
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* PWR clock enable.*/
  RCC->APB1ENR = RCC_APB1ENR_PWREN;
 8000ff0:	4b3b      	ldr	r3, [pc, #236]	; (80010e0 <__early_init+0xf0>)
 8000ff2:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000

  /* Core voltage setup.*/
  while ((PWR->CSR & PWR_CSR_VOSF) != 0)
 8000ff6:	493b      	ldr	r1, [pc, #236]	; (80010e4 <__early_init+0xf4>)
 */
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* PWR clock enable.*/
  RCC->APB1ENR = RCC_APB1ENR_PWREN;
 8000ff8:	625a      	str	r2, [r3, #36]	; 0x24

  /* Core voltage setup.*/
  while ((PWR->CSR & PWR_CSR_VOSF) != 0)
 8000ffa:	684b      	ldr	r3, [r1, #4]
 8000ffc:	4a39      	ldr	r2, [pc, #228]	; (80010e4 <__early_init+0xf4>)
 8000ffe:	06db      	lsls	r3, r3, #27
 8001000:	d4fb      	bmi.n	8000ffa <__early_init+0xa>
    ;                           /* Waits until regulator is stable.         */
  PWR->CR = STM32_VOS;
  while ((PWR->CSR & PWR_CSR_VOSF) != 0)
 8001002:	4611      	mov	r1, r2
  RCC->APB1ENR = RCC_APB1ENR_PWREN;

  /* Core voltage setup.*/
  while ((PWR->CSR & PWR_CSR_VOSF) != 0)
    ;                           /* Waits until regulator is stable.         */
  PWR->CR = STM32_VOS;
 8001004:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8001008:	6013      	str	r3, [r2, #0]
  while ((PWR->CSR & PWR_CSR_VOSF) != 0)
 800100a:	684b      	ldr	r3, [r1, #4]
 800100c:	f013 0310 	ands.w	r3, r3, #16
 8001010:	d1fb      	bne.n	800100a <__early_init+0x1a>
    ;                           /* Waits until regulator is stable.         */

  /* Initial clocks setup and wait for MSI stabilization, the MSI clock is
     always enabled because it is the fallback clock when PLL the fails.
     Trim fields are not altered from reset values.*/
  RCC->CFGR  = 0;
 8001012:	4a33      	ldr	r2, [pc, #204]	; (80010e0 <__early_init+0xf0>)
  RCC->ICSCR = (RCC->ICSCR & ~STM32_MSIRANGE_MASK) | STM32_MSIRANGE;
  RCC->CR    = RCC_CR_MSION;
 8001014:	f44f 7080 	mov.w	r0, #256	; 0x100
  while ((RCC->CR & RCC_CR_MSIRDY) == 0)
 8001018:	4611      	mov	r1, r2
    ;                           /* Waits until regulator is stable.         */

  /* Initial clocks setup and wait for MSI stabilization, the MSI clock is
     always enabled because it is the fallback clock when PLL the fails.
     Trim fields are not altered from reset values.*/
  RCC->CFGR  = 0;
 800101a:	6093      	str	r3, [r2, #8]
  RCC->ICSCR = (RCC->ICSCR & ~STM32_MSIRANGE_MASK) | STM32_MSIRANGE;
 800101c:	6853      	ldr	r3, [r2, #4]
 800101e:	f423 4360 	bic.w	r3, r3, #57344	; 0xe000
 8001022:	f443 4320 	orr.w	r3, r3, #40960	; 0xa000
 8001026:	6053      	str	r3, [r2, #4]
  RCC->CR    = RCC_CR_MSION;
 8001028:	6010      	str	r0, [r2, #0]
  while ((RCC->CR & RCC_CR_MSIRDY) == 0)
 800102a:	680b      	ldr	r3, [r1, #0]
 800102c:	4a2c      	ldr	r2, [pc, #176]	; (80010e0 <__early_init+0xf0>)
 800102e:	0598      	lsls	r0, r3, #22
 8001030:	d5fb      	bpl.n	800102a <__early_init+0x3a>
    ;                           /* Waits until MSI is stable.               */

#if STM32_HSI_ENABLED
  /* HSI activation.*/
  RCC->CR |= RCC_CR_HSION;
  while ((RCC->CR & RCC_CR_HSIRDY) == 0)
 8001032:	4611      	mov	r1, r2
  while ((RCC->CR & RCC_CR_MSIRDY) == 0)
    ;                           /* Waits until MSI is stable.               */

#if STM32_HSI_ENABLED
  /* HSI activation.*/
  RCC->CR |= RCC_CR_HSION;
 8001034:	6813      	ldr	r3, [r2, #0]
 8001036:	f043 0301 	orr.w	r3, r3, #1
 800103a:	6013      	str	r3, [r2, #0]
  while ((RCC->CR & RCC_CR_HSIRDY) == 0)
 800103c:	680b      	ldr	r3, [r1, #0]
 800103e:	4a28      	ldr	r2, [pc, #160]	; (80010e0 <__early_init+0xf0>)
 8001040:	079b      	lsls	r3, r3, #30
 8001042:	d5fb      	bpl.n	800103c <__early_init+0x4c>
#endif

#if STM32_LSI_ENABLED
  /* LSI activation.*/
  RCC->CSR |= RCC_CSR_LSION;
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
 8001044:	4611      	mov	r1, r2
    ;                           /* Waits until HSE is stable.               */
#endif

#if STM32_LSI_ENABLED
  /* LSI activation.*/
  RCC->CSR |= RCC_CSR_LSION;
 8001046:	6b53      	ldr	r3, [r2, #52]	; 0x34
 8001048:	f043 0301 	orr.w	r3, r3, #1
 800104c:	6353      	str	r3, [r2, #52]	; 0x34
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
 800104e:	6b4b      	ldr	r3, [r1, #52]	; 0x34
 8001050:	4a23      	ldr	r2, [pc, #140]	; (80010e0 <__early_init+0xf0>)
 8001052:	0798      	lsls	r0, r3, #30
 8001054:	d5fb      	bpl.n	800104e <__early_init+0x5e>
    ;                           /* Waits until LSI is stable.               */
#endif

#if STM32_LSE_ENABLED
  /* LSE activation, have to unlock the register.*/
  if ((RCC->CSR & RCC_CSR_LSEON) == 0) {
 8001056:	6b53      	ldr	r3, [r2, #52]	; 0x34
 8001058:	05db      	lsls	r3, r3, #23
 800105a:	d40c      	bmi.n	8001076 <__early_init+0x86>
    PWR->CR |= PWR_CR_DBP;
 800105c:	4b21      	ldr	r3, [pc, #132]	; (80010e4 <__early_init+0xf4>)
 800105e:	6819      	ldr	r1, [r3, #0]
 8001060:	f441 7180 	orr.w	r1, r1, #256	; 0x100
 8001064:	6019      	str	r1, [r3, #0]
    RCC->CSR |= RCC_CSR_LSEON;
 8001066:	6b51      	ldr	r1, [r2, #52]	; 0x34
 8001068:	f441 7180 	orr.w	r1, r1, #256	; 0x100
 800106c:	6351      	str	r1, [r2, #52]	; 0x34
    PWR->CR &= ~PWR_CR_DBP;
 800106e:	681a      	ldr	r2, [r3, #0]
 8001070:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 8001074:	601a      	str	r2, [r3, #0]
  }
  while ((RCC->CSR & RCC_CSR_LSERDY) == 0)
 8001076:	491a      	ldr	r1, [pc, #104]	; (80010e0 <__early_init+0xf0>)
 8001078:	6b4b      	ldr	r3, [r1, #52]	; 0x34
 800107a:	4a19      	ldr	r2, [pc, #100]	; (80010e0 <__early_init+0xf0>)
 800107c:	0598      	lsls	r0, r3, #22
 800107e:	d5fb      	bpl.n	8001078 <__early_init+0x88>

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->CFGR |= STM32_PLLDIV | STM32_PLLMUL | STM32_PLLSRC;
  RCC->CR   |= RCC_CR_PLLON;
  while (!(RCC->CR & RCC_CR_PLLRDY))
 8001080:	4611      	mov	r1, r2
    ;                           /* Waits until LSE is stable.               */
#endif

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->CFGR |= STM32_PLLDIV | STM32_PLLMUL | STM32_PLLSRC;
 8001082:	6893      	ldr	r3, [r2, #8]
 8001084:	f443 0308 	orr.w	r3, r3, #8912896	; 0x880000
 8001088:	6093      	str	r3, [r2, #8]
  RCC->CR   |= RCC_CR_PLLON;
 800108a:	6813      	ldr	r3, [r2, #0]
 800108c:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8001090:	6013      	str	r3, [r2, #0]
  while (!(RCC->CR & RCC_CR_PLLRDY))
 8001092:	680b      	ldr	r3, [r1, #0]
 8001094:	4a12      	ldr	r2, [pc, #72]	; (80010e0 <__early_init+0xf0>)
 8001096:	019b      	lsls	r3, r3, #6
 8001098:	d5fb      	bpl.n	8001092 <__early_init+0xa2>
#endif

  /* Switching to the configured clock source if it is different from MSI.*/
#if (STM32_SW != STM32_SW_MSI)
  RCC->CFGR |= STM32_SW;        /* Switches on the selected clock source.   */
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 800109a:	4611      	mov	r1, r2
  while (!(RCC->CR & RCC_CR_PLLRDY))
    ;                           /* Waits until PLL is stable.               */
#endif

  /* Other clock-related settings (dividers, MCO etc).*/
  RCC->CR   |= STM32_RTCPRE;
 800109c:	6813      	ldr	r3, [r2, #0]
/**
 * @brief   Early initialization code.
 * @details This initialization must be performed just after stack setup
 *          and before any other initialization.
 */
void __early_init(void) {
 800109e:	b430      	push	{r4, r5}
 80010a0:	6013      	str	r3, [r2, #0]
  RCC->CFGR |= STM32_MCOPRE | STM32_MCOSEL |
 80010a2:	6893      	ldr	r3, [r2, #8]
               STM32_PPRE2 | STM32_PPRE1 | STM32_HPRE;
  RCC->CSR  |= STM32_RTCSEL;

  /* Flash setup and final clock selection.*/
#if defined(STM32_FLASHBITS1)
  FLASH->ACR = STM32_FLASHBITS1;
 80010a4:	4810      	ldr	r0, [pc, #64]	; (80010e8 <__early_init+0xf8>)
    ;                           /* Waits until PLL is stable.               */
#endif

  /* Other clock-related settings (dividers, MCO etc).*/
  RCC->CR   |= STM32_RTCPRE;
  RCC->CFGR |= STM32_MCOPRE | STM32_MCOSEL |
 80010a6:	6093      	str	r3, [r2, #8]
               STM32_PPRE2 | STM32_PPRE1 | STM32_HPRE;
  RCC->CSR  |= STM32_RTCSEL;
 80010a8:	6b53      	ldr	r3, [r2, #52]	; 0x34

  /* Flash setup and final clock selection.*/
#if defined(STM32_FLASHBITS1)
  FLASH->ACR = STM32_FLASHBITS1;
 80010aa:	2504      	movs	r5, #4

  /* Other clock-related settings (dividers, MCO etc).*/
  RCC->CR   |= STM32_RTCPRE;
  RCC->CFGR |= STM32_MCOPRE | STM32_MCOSEL |
               STM32_PPRE2 | STM32_PPRE1 | STM32_HPRE;
  RCC->CSR  |= STM32_RTCSEL;
 80010ac:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
  /* Flash setup and final clock selection.*/
#if defined(STM32_FLASHBITS1)
  FLASH->ACR = STM32_FLASHBITS1;
#endif
#if defined(STM32_FLASHBITS2)
  FLASH->ACR = STM32_FLASHBITS2;
 80010b0:	2407      	movs	r4, #7

  /* Other clock-related settings (dividers, MCO etc).*/
  RCC->CR   |= STM32_RTCPRE;
  RCC->CFGR |= STM32_MCOPRE | STM32_MCOSEL |
               STM32_PPRE2 | STM32_PPRE1 | STM32_HPRE;
  RCC->CSR  |= STM32_RTCSEL;
 80010b2:	6353      	str	r3, [r2, #52]	; 0x34

  /* Flash setup and final clock selection.*/
#if defined(STM32_FLASHBITS1)
  FLASH->ACR = STM32_FLASHBITS1;
 80010b4:	6005      	str	r5, [r0, #0]
#endif
#if defined(STM32_FLASHBITS2)
  FLASH->ACR = STM32_FLASHBITS2;
 80010b6:	6004      	str	r4, [r0, #0]
#endif

  /* Switching to the configured clock source if it is different from MSI.*/
#if (STM32_SW != STM32_SW_MSI)
  RCC->CFGR |= STM32_SW;        /* Switches on the selected clock source.   */
 80010b8:	6893      	ldr	r3, [r2, #8]
 80010ba:	f043 0303 	orr.w	r3, r3, #3
 80010be:	6093      	str	r3, [r2, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 80010c0:	688b      	ldr	r3, [r1, #8]
 80010c2:	4a07      	ldr	r2, [pc, #28]	; (80010e0 <__early_init+0xf0>)
 80010c4:	f003 030c 	and.w	r3, r3, #12
 80010c8:	2b0c      	cmp	r3, #12
 80010ca:	d1f9      	bne.n	80010c0 <__early_init+0xd0>
#endif
#endif /* STM32_NO_INIT */

  /* SYSCFG clock enabled here because it is a multi-functional unit shared
     among multiple drivers.*/
  rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, TRUE);
 80010cc:	6a13      	ldr	r3, [r2, #32]

  stm32_clock_init();
}
 80010ce:	bc30      	pop	{r4, r5}
 80010d0:	f043 0301 	orr.w	r3, r3, #1
 80010d4:	6213      	str	r3, [r2, #32]
 80010d6:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
 80010d8:	f043 0301 	orr.w	r3, r3, #1
 80010dc:	62d3      	str	r3, [r2, #44]	; 0x2c
 80010de:	4770      	bx	lr
 80010e0:	40023800 	.word	0x40023800
 80010e4:	40007000 	.word	0x40007000
 80010e8:	40023c00 	.word	0x40023c00
 80010ec:	00000000 	.word	0x00000000

080010f0 <chSchDoReschedule>:
 * @special
 */
void chSchDoRescheduleAhead(void) {
  thread_t *otp, *cp;

  otp = currp;
 80010f0:	4a0d      	ldr	r2, [pc, #52]	; (8001128 <chSchDoReschedule+0x38>)
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoReschedule(void) {
 80010f2:	b430      	push	{r4, r5}
  tp->p_prev->p_next = tp;
  tqp->p_prev = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;
 80010f4:	6810      	ldr	r0, [r2, #0]
 * @special
 */
void chSchDoRescheduleAhead(void) {
  thread_t *otp, *cp;

  otp = currp;
 80010f6:	6994      	ldr	r4, [r2, #24]

  tqp->p_next = tp->p_next;
 80010f8:	6803      	ldr	r3, [r0, #0]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
  if (otp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 80010fa:	2101      	movs	r1, #1
  tqp->p_next->p_prev = (thread_t *)tqp;
 80010fc:	605a      	str	r2, [r3, #4]

  otp->p_state = CH_STATE_READY;
 80010fe:	2500      	movs	r5, #0
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
  if (otp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 8001100:	7701      	strb	r1, [r0, #28]
 8001102:	68a1      	ldr	r1, [r4, #8]
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 8001104:	6013      	str	r3, [r2, #0]
void chSchDoRescheduleAhead(void) {
  thread_t *otp, *cp;

  otp = currp;
  /* Picks the first thread from the ready queue and makes it current.*/
  setcurrp(queue_fifo_remove(&ch.rlist.r_queue));
 8001106:	6190      	str	r0, [r2, #24]
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;

  otp->p_state = CH_STATE_READY;
 8001108:	7725      	strb	r5, [r4, #28]
 800110a:	e000      	b.n	800110e <chSchDoReschedule+0x1e>
 800110c:	681b      	ldr	r3, [r3, #0]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio > otp->p_prio);
 800110e:	689a      	ldr	r2, [r3, #8]
 8001110:	428a      	cmp	r2, r1
 8001112:	d8fb      	bhi.n	800110c <chSchDoReschedule+0x1c>
  /* Insertion on p_prev.*/
  otp->p_next = cp;
  otp->p_prev = cp->p_prev;
 8001114:	685a      	ldr	r2, [r3, #4]
  otp->p_prev->p_next = otp;
  cp->p_prev = otp;

  chSysSwitch(currp, otp);
 8001116:	4621      	mov	r1, r4
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio > otp->p_prio);
  /* Insertion on p_prev.*/
  otp->p_next = cp;
 8001118:	6023      	str	r3, [r4, #0]
  otp->p_prev = cp->p_prev;
 800111a:	6062      	str	r2, [r4, #4]
  otp->p_prev->p_next = otp;
 800111c:	6014      	str	r4, [r2, #0]
  cp->p_prev = otp;
 800111e:	605c      	str	r4, [r3, #4]
#else /* !(CH_CFG_TIME_QUANTUM > 0) */
  /* If the round-robin mechanism is disabled then the thread goes always
     ahead of its peers.*/
  chSchDoRescheduleAhead();
#endif /* !(CH_CFG_TIME_QUANTUM > 0) */
}
 8001120:	bc30      	pop	{r4, r5}
  otp->p_next = cp;
  otp->p_prev = cp->p_prev;
  otp->p_prev->p_next = otp;
  cp->p_prev = otp;

  chSysSwitch(currp, otp);
 8001122:	f7ff b875 	b.w	8000210 <_port_switch>
 8001126:	bf00      	nop
 8001128:	20000800 	.word	0x20000800
 800112c:	00000000 	.word	0x00000000

08001130 <chSchReadyI>:
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @iclass
 */
thread_t *chSchReadyI(thread_t *tp) {
 8001130:	b410      	push	{r4}
 8001132:	4604      	mov	r4, r0
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 8001134:	2200      	movs	r2, #0
 8001136:	6881      	ldr	r1, [r0, #8]
  cp = (thread_t *)&ch.rlist.r_queue;
 8001138:	4b06      	ldr	r3, [pc, #24]	; (8001154 <chSchReadyI+0x24>)
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 800113a:	7702      	strb	r2, [r0, #28]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
 800113c:	681b      	ldr	r3, [r3, #0]
  } while (cp->p_prio >= tp->p_prio);
 800113e:	689a      	ldr	r2, [r3, #8]
 8001140:	428a      	cmp	r2, r1
 8001142:	d2fb      	bcs.n	800113c <chSchReadyI+0xc>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 8001144:	685a      	ldr	r2, [r3, #4]
  tp->p_prev->p_next = tp;
  cp->p_prev = tp;

  return tp;
}
 8001146:	4620      	mov	r0, r4
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
 8001148:	6023      	str	r3, [r4, #0]
  tp->p_prev = cp->p_prev;
 800114a:	6062      	str	r2, [r4, #4]
  tp->p_prev->p_next = tp;
 800114c:	6014      	str	r4, [r2, #0]
  cp->p_prev = tp;
 800114e:	605c      	str	r4, [r3, #4]

  return tp;
}
 8001150:	bc10      	pop	{r4}
 8001152:	4770      	bx	lr
 8001154:	20000800 	.word	0x20000800
	...

08001160 <VectorD4>:
/**
 * @brief   USART1 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_USART1_HANDLER) {
 8001160:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 * @brief   Common IRQ handler.
 *
 * @param[in] sdp       communication channel associated to the USART
 */
static void serve_interrupt(SerialDriver *sdp) {
  USART_TypeDef *u = sdp->usart;
 8001164:	4d6b      	ldr	r5, [pc, #428]	; (8001314 <VectorD4+0x1b4>)
/**
 * @brief   USART1 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_USART1_HANDLER) {
 8001166:	b082      	sub	sp, #8
 * @brief   Common IRQ handler.
 *
 * @param[in] sdp       communication channel associated to the USART
 */
static void serve_interrupt(SerialDriver *sdp) {
  USART_TypeDef *u = sdp->usart;
 8001168:	6f6e      	ldr	r6, [r5, #116]	; 0x74
  uint16_t cr1 = u->CR1;
 800116a:	f8d6 a00c 	ldr.w	sl, [r6, #12]
  uint16_t sr = u->SR;
 800116e:	6833      	ldr	r3, [r6, #0]

  /* Special case, LIN break detection.*/
  if (sr & USART_SR_LBD) {
 8001170:	05da      	lsls	r2, r3, #23
 * @param[in] sdp       communication channel associated to the USART
 */
static void serve_interrupt(SerialDriver *sdp) {
  USART_TypeDef *u = sdp->usart;
  uint16_t cr1 = u->CR1;
  uint16_t sr = u->SR;
 8001172:	b29c      	uxth	r4, r3

  /* Special case, LIN break detection.*/
  if (sr & USART_SR_LBD) {
 8001174:	f100 8082 	bmi.w	800127c <VectorD4+0x11c>
 8001178:	2320      	movs	r3, #32
 800117a:	f383 8811 	msr	BASEPRI, r3
    osalSysUnlockFromISR();
  }

  /* Data available.*/
  osalSysLockFromISR();
  while (sr & (USART_SR_RXNE | USART_SR_ORE | USART_SR_NE | USART_SR_FE |
 800117e:	f014 0f2f 	tst.w	r4, #47	; 0x2f
 8001182:	d049      	beq.n	8001218 <VectorD4+0xb8>
static inline bool chIQIsFullI(input_queue_t *iqp) {

  chDbgCheckClassI();

  /*lint -save -e9007 [13.5] No side effects.*/
  return (bool)((iqp->q_wrptr == iqp->q_rdptr) && (iqp->q_counter != 0U));
 8001184:	4f63      	ldr	r7, [pc, #396]	; (8001314 <VectorD4+0x1b4>)

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->p_state == CH_STATE_QUEUED, "invalid state");

  tp->p_u.rdymsg = msg;
 8001186:	f04f 0900 	mov.w	r9, #0
 *
 * @iclass
 */
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {

  if (queue_notempty(tqp)) {
 800118a:	f107 080c 	add.w	r8, r7, #12
 800118e:	e007      	b.n	80011a0 <VectorD4+0x40>

    /* Error condition detection.*/
    if (sr & (USART_SR_ORE | USART_SR_NE | USART_SR_FE  | USART_SR_PE))
      set_error(sdp, sr);
    b = u->DR;
    if (sr & USART_SR_RXNE)
 8001190:	06a1      	lsls	r1, r4, #26
    uint8_t b;

    /* Error condition detection.*/
    if (sr & (USART_SR_ORE | USART_SR_NE | USART_SR_FE  | USART_SR_PE))
      set_error(sdp, sr);
    b = u->DR;
 8001192:	6873      	ldr	r3, [r6, #4]
    if (sr & USART_SR_RXNE)
 8001194:	d41c      	bmi.n	80011d0 <VectorD4+0x70>
      sdIncomingDataI(sdp, b);
    sr = u->SR;
 8001196:	6834      	ldr	r4, [r6, #0]
 8001198:	b2a4      	uxth	r4, r4
    osalSysUnlockFromISR();
  }

  /* Data available.*/
  osalSysLockFromISR();
  while (sr & (USART_SR_RXNE | USART_SR_ORE | USART_SR_NE | USART_SR_FE |
 800119a:	f014 0f2f 	tst.w	r4, #47	; 0x2f
 800119e:	d03b      	beq.n	8001218 <VectorD4+0xb8>
               USART_SR_PE)) {
    uint8_t b;

    /* Error condition detection.*/
    if (sr & (USART_SR_ORE | USART_SR_NE | USART_SR_FE  | USART_SR_PE))
 80011a0:	0723      	lsls	r3, r4, #28
 80011a2:	d0f5      	beq.n	8001190 <VectorD4+0x30>
 */
static void set_error(SerialDriver *sdp, uint16_t sr) {
  eventflags_t sts = 0;

  if (sr & USART_SR_ORE)
    sts |= SD_OVERRUN_ERROR;
 80011a4:	f014 0f08 	tst.w	r4, #8
 80011a8:	bf0c      	ite	eq
 80011aa:	2000      	moveq	r0, #0
 80011ac:	2080      	movne	r0, #128	; 0x80
  if (sr & USART_SR_PE)
 80011ae:	07e1      	lsls	r1, r4, #31
    sts |= SD_PARITY_ERROR;
 80011b0:	bf48      	it	mi
 80011b2:	f040 0020 	orrmi.w	r0, r0, #32
  if (sr & USART_SR_FE)
 80011b6:	07a2      	lsls	r2, r4, #30
    sts |= SD_FRAMING_ERROR;
 80011b8:	bf48      	it	mi
 80011ba:	f040 0040 	orrmi.w	r0, r0, #64	; 0x40
  if (sr & USART_SR_NE)
 80011be:	0763      	lsls	r3, r4, #29
    sts |= SD_NOISE_ERROR;
 80011c0:	bf48      	it	mi
 80011c2:	f440 7080 	orrmi.w	r0, r0, #256	; 0x100
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {

  chEvtBroadcastFlagsI(esp, flags);
 80011c6:	f000 f9fb 	bl	80015c0 <chEvtBroadcastFlagsI.constprop.18>

    /* Error condition detection.*/
    if (sr & (USART_SR_ORE | USART_SR_NE | USART_SR_FE  | USART_SR_PE))
      set_error(sdp, sr);
    b = u->DR;
    if (sr & USART_SR_RXNE)
 80011ca:	06a1      	lsls	r1, r4, #26
    uint8_t b;

    /* Error condition detection.*/
    if (sr & (USART_SR_ORE | USART_SR_NE | USART_SR_FE  | USART_SR_PE))
      set_error(sdp, sr);
    b = u->DR;
 80011cc:	6873      	ldr	r3, [r6, #4]
    if (sr & USART_SR_RXNE)
 80011ce:	d5e2      	bpl.n	8001196 <VectorD4+0x36>
 */
static inline bool chIQIsEmptyI(input_queue_t *iqp) {

  chDbgCheckClassI();

  return (bool)(chQSpaceI(iqp) == 0U);
 80011d0:	696a      	ldr	r2, [r5, #20]
void sdIncomingDataI(SerialDriver *sdp, uint8_t b) {

  osalDbgCheckClassI();
  osalDbgCheck(sdp != NULL);

  if (iqIsEmptyI(&sdp->iqueue))
 80011d2:	2a00      	cmp	r2, #0
 80011d4:	d042      	beq.n	800125c <VectorD4+0xfc>
static inline bool chIQIsFullI(input_queue_t *iqp) {

  chDbgCheckClassI();

  /*lint -save -e9007 [13.5] No side effects.*/
  return (bool)((iqp->q_wrptr == iqp->q_rdptr) && (iqp->q_counter != 0U));
 80011d6:	6a29      	ldr	r1, [r5, #32]
 80011d8:	6a6a      	ldr	r2, [r5, #36]	; 0x24
 80011da:	4291      	cmp	r1, r2
 80011dc:	d047      	beq.n	800126e <VectorD4+0x10e>

  if (chIQIsFullI(iqp)) {
    return Q_FULL;
  }

  iqp->q_counter++;
 80011de:	696a      	ldr	r2, [r5, #20]
  *iqp->q_wrptr++ = b;
 80011e0:	1c48      	adds	r0, r1, #1

  if (chIQIsFullI(iqp)) {
    return Q_FULL;
  }

  iqp->q_counter++;
 80011e2:	3201      	adds	r2, #1
 80011e4:	616a      	str	r2, [r5, #20]
  *iqp->q_wrptr++ = b;
 80011e6:	6228      	str	r0, [r5, #32]
 80011e8:	700b      	strb	r3, [r1, #0]
  if (iqp->q_wrptr >= iqp->q_top) {
 80011ea:	6a2a      	ldr	r2, [r5, #32]
 80011ec:	69eb      	ldr	r3, [r5, #28]
 80011ee:	429a      	cmp	r2, r3
 80011f0:	d301      	bcc.n	80011f6 <VectorD4+0x96>
    iqp->q_wrptr = iqp->q_buffer;
 80011f2:	69bb      	ldr	r3, [r7, #24]
 80011f4:	623b      	str	r3, [r7, #32]
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 80011f6:	68eb      	ldr	r3, [r5, #12]
 80011f8:	4543      	cmp	r3, r8
 80011fa:	d0cc      	beq.n	8001196 <VectorD4+0x36>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 80011fc:	681a      	ldr	r2, [r3, #0]
  (void) chSchReadyI(tp);
 80011fe:	4618      	mov	r0, r3
 8001200:	60fa      	str	r2, [r7, #12]
  tqp->p_next->p_prev = (thread_t *)tqp;
 8001202:	f8c2 8004 	str.w	r8, [r2, #4]

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->p_state == CH_STATE_QUEUED, "invalid state");

  tp->p_u.rdymsg = msg;
 8001206:	f8c3 9020 	str.w	r9, [r3, #32]
  (void) chSchReadyI(tp);
 800120a:	f7ff ff91 	bl	8001130 <chSchReadyI>
      sdIncomingDataI(sdp, b);
    sr = u->SR;
 800120e:	6834      	ldr	r4, [r6, #0]
 8001210:	b2a4      	uxth	r4, r4
    osalSysUnlockFromISR();
  }

  /* Data available.*/
  osalSysLockFromISR();
  while (sr & (USART_SR_RXNE | USART_SR_ORE | USART_SR_NE | USART_SR_FE |
 8001212:	f014 0f2f 	tst.w	r4, #47	; 0x2f
 8001216:	d1c3      	bne.n	80011a0 <VectorD4+0x40>
 8001218:	2300      	movs	r3, #0
 800121a:	f383 8811 	msr	BASEPRI, r3
    sr = u->SR;
  }
  osalSysUnlockFromISR();

  /* Transmission buffer empty.*/
  if ((cr1 & USART_CR1_TXEIE) && (sr & USART_SR_TXE)) {
 800121e:	f01a 0f80 	tst.w	sl, #128	; 0x80
 8001222:	d001      	beq.n	8001228 <VectorD4+0xc8>
 8001224:	0622      	lsls	r2, r4, #24
 8001226:	d437      	bmi.n	8001298 <VectorD4+0x138>
      u->DR = b;
    osalSysUnlockFromISR();
  }

  /* Physical transmission end.*/
  if (sr & USART_SR_TC) {
 8001228:	0663      	lsls	r3, r4, #25
 800122a:	d512      	bpl.n	8001252 <VectorD4+0xf2>
 800122c:	2320      	movs	r3, #32
 800122e:	f383 8811 	msr	BASEPRI, r3
static inline bool chOQIsEmptyI(output_queue_t *oqp) {

  chDbgCheckClassI();

  /*lint -save -e9007 [13.5] No side effects.*/
  return (bool)((oqp->q_wrptr == oqp->q_rdptr) && (oqp->q_counter != 0U));
 8001232:	6c6a      	ldr	r2, [r5, #68]	; 0x44
 8001234:	6cab      	ldr	r3, [r5, #72]	; 0x48
 8001236:	4937      	ldr	r1, [pc, #220]	; (8001314 <VectorD4+0x1b4>)
 8001238:	429a      	cmp	r2, r3
 800123a:	d056      	beq.n	80012ea <VectorD4+0x18a>
    osalSysLockFromISR();
    if (oqIsEmptyI(&sdp->oqueue))
      chnAddFlagsI(sdp, CHN_TRANSMISSION_END);
    u->CR1 = cr1 & ~USART_CR1_TCIE;
 800123c:	f64f 73bf 	movw	r3, #65471	; 0xffbf
    u->SR = ~USART_SR_TC;
 8001240:	f06f 0240 	mvn.w	r2, #64	; 0x40
  /* Physical transmission end.*/
  if (sr & USART_SR_TC) {
    osalSysLockFromISR();
    if (oqIsEmptyI(&sdp->oqueue))
      chnAddFlagsI(sdp, CHN_TRANSMISSION_END);
    u->CR1 = cr1 & ~USART_CR1_TCIE;
 8001244:	ea0a 0303 	and.w	r3, sl, r3
 8001248:	60f3      	str	r3, [r6, #12]
 800124a:	2300      	movs	r3, #0
    u->SR = ~USART_SR_TC;
 800124c:	6032      	str	r2, [r6, #0]
 800124e:	f383 8811 	msr	BASEPRI, r3
  OSAL_IRQ_PROLOGUE();

  serve_interrupt(&SD1);

  OSAL_IRQ_EPILOGUE();
}
 8001252:	b002      	add	sp, #8
 8001254:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}

  OSAL_IRQ_PROLOGUE();

  serve_interrupt(&SD1);

  OSAL_IRQ_EPILOGUE();
 8001258:	f7ff b822 	b.w	80002a0 <_port_irq_epilogue>
 800125c:	2004      	movs	r0, #4
 800125e:	9301      	str	r3, [sp, #4]
 8001260:	f000 f9ae 	bl	80015c0 <chEvtBroadcastFlagsI.constprop.18>
static inline bool chIQIsFullI(input_queue_t *iqp) {

  chDbgCheckClassI();

  /*lint -save -e9007 [13.5] No side effects.*/
  return (bool)((iqp->q_wrptr == iqp->q_rdptr) && (iqp->q_counter != 0U));
 8001264:	6a29      	ldr	r1, [r5, #32]
 8001266:	6a6a      	ldr	r2, [r5, #36]	; 0x24
 8001268:	9b01      	ldr	r3, [sp, #4]
 800126a:	4291      	cmp	r1, r2
 800126c:	d1b7      	bne.n	80011de <VectorD4+0x7e>
 800126e:	697a      	ldr	r2, [r7, #20]
 8001270:	2a00      	cmp	r2, #0
 8001272:	d0b4      	beq.n	80011de <VectorD4+0x7e>
 8001274:	2080      	movs	r0, #128	; 0x80
 8001276:	f000 f9a3 	bl	80015c0 <chEvtBroadcastFlagsI.constprop.18>
 800127a:	e78c      	b.n	8001196 <VectorD4+0x36>
 800127c:	2320      	movs	r3, #32
 800127e:	f383 8811 	msr	BASEPRI, r3
 8001282:	f44f 7000 	mov.w	r0, #512	; 0x200
 8001286:	f000 f99b 	bl	80015c0 <chEvtBroadcastFlagsI.constprop.18>

  /* Special case, LIN break detection.*/
  if (sr & USART_SR_LBD) {
    osalSysLockFromISR();
    chnAddFlagsI(sdp, SD_BREAK_DETECTED);
    u->SR = ~USART_SR_LBD;
 800128a:	f46f 7380 	mvn.w	r3, #256	; 0x100
 800128e:	6033      	str	r3, [r6, #0]
 8001290:	2300      	movs	r3, #0
 8001292:	f383 8811 	msr	BASEPRI, r3
 8001296:	e76f      	b.n	8001178 <VectorD4+0x18>
 8001298:	2320      	movs	r3, #32
 800129a:	f383 8811 	msr	BASEPRI, r3
static inline bool chOQIsEmptyI(output_queue_t *oqp) {

  chDbgCheckClassI();

  /*lint -save -e9007 [13.5] No side effects.*/
  return (bool)((oqp->q_wrptr == oqp->q_rdptr) && (oqp->q_counter != 0U));
 800129e:	6cab      	ldr	r3, [r5, #72]	; 0x48
 80012a0:	6c6a      	ldr	r2, [r5, #68]	; 0x44
 80012a2:	491c      	ldr	r1, [pc, #112]	; (8001314 <VectorD4+0x1b4>)
 80012a4:	429a      	cmp	r2, r3
 80012a6:	d027      	beq.n	80012f8 <VectorD4+0x198>

  if (chOQIsEmptyI(oqp)) {
    return Q_EMPTY;
  }

  oqp->q_counter++;
 80012a8:	6baa      	ldr	r2, [r5, #56]	; 0x38
  b = *oqp->q_rdptr++;
  if (oqp->q_rdptr >= oqp->q_top) {
 80012aa:	6c28      	ldr	r0, [r5, #64]	; 0x40
  if (chOQIsEmptyI(oqp)) {
    return Q_EMPTY;
  }

  oqp->q_counter++;
  b = *oqp->q_rdptr++;
 80012ac:	1c59      	adds	r1, r3, #1

  if (chOQIsEmptyI(oqp)) {
    return Q_EMPTY;
  }

  oqp->q_counter++;
 80012ae:	3201      	adds	r2, #1
 80012b0:	63aa      	str	r2, [r5, #56]	; 0x38
  b = *oqp->q_rdptr++;
 80012b2:	64a9      	str	r1, [r5, #72]	; 0x48
  if (oqp->q_rdptr >= oqp->q_top) {
 80012b4:	4281      	cmp	r1, r0
  if (chOQIsEmptyI(oqp)) {
    return Q_EMPTY;
  }

  oqp->q_counter++;
  b = *oqp->q_rdptr++;
 80012b6:	781f      	ldrb	r7, [r3, #0]

  if (chOQIsEmptyI(oqp)) {
    return Q_EMPTY;
  }

  oqp->q_counter++;
 80012b8:	4b16      	ldr	r3, [pc, #88]	; (8001314 <VectorD4+0x1b4>)
  b = *oqp->q_rdptr++;
  if (oqp->q_rdptr >= oqp->q_top) {
 80012ba:	d301      	bcc.n	80012c0 <VectorD4+0x160>
    oqp->q_rdptr = oqp->q_buffer;
 80012bc:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 80012be:	649a      	str	r2, [r3, #72]	; 0x48
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 80012c0:	4914      	ldr	r1, [pc, #80]	; (8001314 <VectorD4+0x1b4>)
 80012c2:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 80012c4:	f101 0230 	add.w	r2, r1, #48	; 0x30
 80012c8:	4293      	cmp	r3, r2
 80012ca:	d009      	beq.n	80012e0 <VectorD4+0x180>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 80012cc:	6818      	ldr	r0, [r3, #0]

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->p_state == CH_STATE_QUEUED, "invalid state");

  tp->p_u.rdymsg = msg;
 80012ce:	f04f 0e00 	mov.w	lr, #0
 80012d2:	6308      	str	r0, [r1, #48]	; 0x30
  tqp->p_next->p_prev = (thread_t *)tqp;
 80012d4:	6042      	str	r2, [r0, #4]
  (void) chSchReadyI(tp);
 80012d6:	4618      	mov	r0, r3

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->p_state == CH_STATE_QUEUED, "invalid state");

  tp->p_u.rdymsg = msg;
 80012d8:	f8c3 e020 	str.w	lr, [r3, #32]
  (void) chSchReadyI(tp);
 80012dc:	f7ff ff28 	bl	8001130 <chSchReadyI>
    if (b < Q_OK) {
      chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
      u->CR1 = (cr1 & ~USART_CR1_TXEIE) | USART_CR1_TCIE;
    }
    else
      u->DR = b;
 80012e0:	6077      	str	r7, [r6, #4]
 80012e2:	2300      	movs	r3, #0
 80012e4:	f383 8811 	msr	BASEPRI, r3
 80012e8:	e79e      	b.n	8001228 <VectorD4+0xc8>
 80012ea:	6b8b      	ldr	r3, [r1, #56]	; 0x38
 80012ec:	2b00      	cmp	r3, #0
 80012ee:	d0a5      	beq.n	800123c <VectorD4+0xdc>
 80012f0:	2010      	movs	r0, #16
 80012f2:	f000 f965 	bl	80015c0 <chEvtBroadcastFlagsI.constprop.18>
 80012f6:	e7a1      	b.n	800123c <VectorD4+0xdc>
 80012f8:	6b8a      	ldr	r2, [r1, #56]	; 0x38
 80012fa:	2a00      	cmp	r2, #0
 80012fc:	d0d4      	beq.n	80012a8 <VectorD4+0x148>
 80012fe:	2008      	movs	r0, #8
 8001300:	f000 f95e 	bl	80015c0 <chEvtBroadcastFlagsI.constprop.18>
    msg_t b;
    osalSysLockFromISR();
    b = oqGetI(&sdp->oqueue);
    if (b < Q_OK) {
      chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
      u->CR1 = (cr1 & ~USART_CR1_TXEIE) | USART_CR1_TCIE;
 8001304:	f64f 733f 	movw	r3, #65343	; 0xff3f
 8001308:	ea0a 0303 	and.w	r3, sl, r3
 800130c:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8001310:	60f3      	str	r3, [r6, #12]
 8001312:	e7e6      	b.n	80012e2 <VectorD4+0x182>
 8001314:	200009e8 	.word	0x200009e8
	...

08001320 <Vector88>:
OSAL_IRQ_HANDLER(Vector88) {
  uint32_t sr;

  OSAL_IRQ_PROLOGUE();

  sr = ADC1->SR;
 8001320:	4b1f      	ldr	r3, [pc, #124]	; (80013a0 <Vector88+0x80>)
  ADC1->SR = 0;
 8001322:	2200      	movs	r2, #0
OSAL_IRQ_HANDLER(Vector88) {
  uint32_t sr;

  OSAL_IRQ_PROLOGUE();

  sr = ADC1->SR;
 8001324:	6819      	ldr	r1, [r3, #0]
  ADC1->SR = 0;
 8001326:	601a      	str	r2, [r3, #0]
  /* Note, an overflow may occur after the conversion ended before the driver
     is able to stop the ADC, this is why the DMA channel is checked too.*/
  if ((sr & ADC_SR_OVR) && (dmaStreamGetTransactionSize(ADCD1.dmastp) > 0)) {
 8001328:	068b      	lsls	r3, r1, #26
 800132a:	d537      	bpl.n	800139c <Vector88+0x7c>
/**
 * @brief   ADC interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector88) {
 800132c:	b570      	push	{r4, r5, r6, lr}

  sr = ADC1->SR;
  ADC1->SR = 0;
  /* Note, an overflow may occur after the conversion ended before the driver
     is able to stop the ADC, this is why the DMA channel is checked too.*/
  if ((sr & ADC_SR_OVR) && (dmaStreamGetTransactionSize(ADCD1.dmastp) > 0)) {
 800132e:	4c1d      	ldr	r4, [pc, #116]	; (80013a4 <Vector88+0x84>)
 8001330:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8001332:	6859      	ldr	r1, [r3, #4]
 8001334:	6848      	ldr	r0, [r1, #4]
 8001336:	2800      	cmp	r0, #0
 8001338:	d02c      	beq.n	8001394 <Vector88+0x74>
    /* ADC overflow condition, this could happen only if the DMA is unable
       to read data fast enough.*/
    if (ADCD1.grpp != NULL)
 800133a:	6925      	ldr	r5, [r4, #16]
 800133c:	b355      	cbz	r5, 8001394 <Vector88+0x74>
 *
 * @notapi
 */
void adc_lld_stop_conversion(ADCDriver *adcp) {

  dmaStreamDisable(adcp->dmastp);
 800133e:	6808      	ldr	r0, [r1, #0]
     is able to stop the ADC, this is why the DMA channel is checked too.*/
  if ((sr & ADC_SR_OVR) && (dmaStreamGetTransactionSize(ADCD1.dmastp) > 0)) {
    /* ADC overflow condition, this could happen only if the DMA is unable
       to read data fast enough.*/
    if (ADCD1.grpp != NULL)
      _adc_isr_error_code(&ADCD1, ADC_ERR_OVERFLOW);
 8001340:	68ad      	ldr	r5, [r5, #8]
 *
 * @notapi
 */
void adc_lld_stop_conversion(ADCDriver *adcp) {

  dmaStreamDisable(adcp->dmastp);
 8001342:	f020 000f 	bic.w	r0, r0, #15
 8001346:	6008      	str	r0, [r1, #0]
 8001348:	7c18      	ldrb	r0, [r3, #16]
 800134a:	681e      	ldr	r6, [r3, #0]
 800134c:	210f      	movs	r1, #15
  adcp->adc->CR1 = 0;
 800134e:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 *
 * @notapi
 */
void adc_lld_stop_conversion(ADCDriver *adcp) {

  dmaStreamDisable(adcp->dmastp);
 8001350:	fa01 f000 	lsl.w	r0, r1, r0
  adcp->adc->CR1 = 0;
  adcp->adc->CR2 = 0;
  adcp->adc->CR2 = ADC_CR2_ADON;
 8001354:	2101      	movs	r1, #1
 *
 * @notapi
 */
void adc_lld_stop_conversion(ADCDriver *adcp) {

  dmaStreamDisable(adcp->dmastp);
 8001356:	6070      	str	r0, [r6, #4]
  adcp->adc->CR1 = 0;
 8001358:	605a      	str	r2, [r3, #4]
  adcp->adc->CR2 = 0;
 800135a:	609a      	str	r2, [r3, #8]
  adcp->adc->CR2 = ADC_CR2_ADON;
 800135c:	6099      	str	r1, [r3, #8]
     is able to stop the ADC, this is why the DMA channel is checked too.*/
  if ((sr & ADC_SR_OVR) && (dmaStreamGetTransactionSize(ADCD1.dmastp) > 0)) {
    /* ADC overflow condition, this could happen only if the DMA is unable
       to read data fast enough.*/
    if (ADCD1.grpp != NULL)
      _adc_isr_error_code(&ADCD1, ADC_ERR_OVERFLOW);
 800135e:	b145      	cbz	r5, 8001372 <Vector88+0x52>
 8001360:	2305      	movs	r3, #5
 8001362:	7023      	strb	r3, [r4, #0]
 8001364:	4620      	mov	r0, r4
 8001366:	47a8      	blx	r5
 8001368:	7823      	ldrb	r3, [r4, #0]
 800136a:	2b05      	cmp	r3, #5
 800136c:	bf04      	itt	eq
 800136e:	2302      	moveq	r3, #2
 8001370:	7023      	strbeq	r3, [r4, #0]
 8001372:	2300      	movs	r3, #0
 8001374:	6123      	str	r3, [r4, #16]
 8001376:	490b      	ldr	r1, [pc, #44]	; (80013a4 <Vector88+0x84>)
 8001378:	2220      	movs	r2, #32
 800137a:	f382 8811 	msr	BASEPRI, r2
 *
 * @iclass
 */
void chThdResumeI(thread_reference_t *trp, msg_t msg) {

  if (*trp != NULL) {
 800137e:	6960      	ldr	r0, [r4, #20]
 8001380:	b128      	cbz	r0, 800138e <Vector88+0x6e>

    chDbgAssert(tp->p_state == CH_STATE_SUSPENDED,
                "not THD_STATE_SUSPENDED");

    *trp = NULL;
    tp->p_u.rdymsg = msg;
 8001382:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8001386:	6202      	str	r2, [r0, #32]
    thread_t *tp = *trp;

    chDbgAssert(tp->p_state == CH_STATE_SUSPENDED,
                "not THD_STATE_SUSPENDED");

    *trp = NULL;
 8001388:	614b      	str	r3, [r1, #20]
    tp->p_u.rdymsg = msg;
    (void) chSchReadyI(tp);
 800138a:	f7ff fed1 	bl	8001130 <chSchReadyI>
 800138e:	2300      	movs	r3, #0
 8001390:	f383 8811 	msr	BASEPRI, r3
  }
  /* TODO: Add here analog watchdog handling.*/

  OSAL_IRQ_EPILOGUE();
}
 8001394:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    if (ADCD1.grpp != NULL)
      _adc_isr_error_code(&ADCD1, ADC_ERR_OVERFLOW);
  }
  /* TODO: Add here analog watchdog handling.*/

  OSAL_IRQ_EPILOGUE();
 8001398:	f7fe bf82 	b.w	80002a0 <_port_irq_epilogue>
 800139c:	f7fe bf80 	b.w	80002a0 <_port_irq_epilogue>
 80013a0:	40012400 	.word	0x40012400
 80013a4:	20000988 	.word	0x20000988
	...

080013b0 <adc_lld_serve_rx_interrupt>:
 * @brief   ADC DMA ISR service routine.
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 * @param[in] flags     pre-shifted content of the ISR register
 */
static void adc_lld_serve_rx_interrupt(ADCDriver *adcp, uint32_t flags) {
 80013b0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}

  /* DMA errors handling.*/
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 80013b4:	070e      	lsls	r6, r1, #28
 * @brief   ADC DMA ISR service routine.
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 * @param[in] flags     pre-shifted content of the ISR register
 */
static void adc_lld_serve_rx_interrupt(ADCDriver *adcp, uint32_t flags) {
 80013b6:	4604      	mov	r4, r0

  /* DMA errors handling.*/
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 80013b8:	d52e      	bpl.n	8001418 <adc_lld_serve_rx_interrupt+0x68>
 *
 * @notapi
 */
void adc_lld_stop_conversion(ADCDriver *adcp) {

  dmaStreamDisable(adcp->dmastp);
 80013ba:	6ac3      	ldr	r3, [r0, #44]	; 0x2c

  /* DMA errors handling.*/
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
    /* DMA, this could help only if the DMA tries to access an unmapped
       address space or violates alignment rules.*/
    _adc_isr_error_code(adcp, ADC_ERR_DMAFAILURE);
 80013bc:	6905      	ldr	r5, [r0, #16]
 *
 * @notapi
 */
void adc_lld_stop_conversion(ADCDriver *adcp) {

  dmaStreamDisable(adcp->dmastp);
 80013be:	6859      	ldr	r1, [r3, #4]

  /* DMA errors handling.*/
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
    /* DMA, this could help only if the DMA tries to access an unmapped
       address space or violates alignment rules.*/
    _adc_isr_error_code(adcp, ADC_ERR_DMAFAILURE);
 80013c0:	68ad      	ldr	r5, [r5, #8]
 *
 * @notapi
 */
void adc_lld_stop_conversion(ADCDriver *adcp) {

  dmaStreamDisable(adcp->dmastp);
 80013c2:	680a      	ldr	r2, [r1, #0]
 80013c4:	681f      	ldr	r7, [r3, #0]
 80013c6:	f022 020f 	bic.w	r2, r2, #15
 80013ca:	600a      	str	r2, [r1, #0]
 80013cc:	7c19      	ldrb	r1, [r3, #16]
 80013ce:	220f      	movs	r2, #15
  adcp->adc->CR1 = 0;
 80013d0:	6a83      	ldr	r3, [r0, #40]	; 0x28
 *
 * @notapi
 */
void adc_lld_stop_conversion(ADCDriver *adcp) {

  dmaStreamDisable(adcp->dmastp);
 80013d2:	408a      	lsls	r2, r1
  adcp->adc->CR1 = 0;
  adcp->adc->CR2 = 0;
  adcp->adc->CR2 = ADC_CR2_ADON;
 80013d4:	2601      	movs	r6, #1
 * @notapi
 */
void adc_lld_stop_conversion(ADCDriver *adcp) {

  dmaStreamDisable(adcp->dmastp);
  adcp->adc->CR1 = 0;
 80013d6:	2100      	movs	r1, #0
 *
 * @notapi
 */
void adc_lld_stop_conversion(ADCDriver *adcp) {

  dmaStreamDisable(adcp->dmastp);
 80013d8:	607a      	str	r2, [r7, #4]
  adcp->adc->CR1 = 0;
 80013da:	6059      	str	r1, [r3, #4]
  adcp->adc->CR2 = 0;
 80013dc:	6099      	str	r1, [r3, #8]
  adcp->adc->CR2 = ADC_CR2_ADON;
 80013de:	609e      	str	r6, [r3, #8]

  /* DMA errors handling.*/
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
    /* DMA, this could help only if the DMA tries to access an unmapped
       address space or violates alignment rules.*/
    _adc_isr_error_code(adcp, ADC_ERR_DMAFAILURE);
 80013e0:	b13d      	cbz	r5, 80013f2 <adc_lld_serve_rx_interrupt+0x42>
 80013e2:	2305      	movs	r3, #5
 80013e4:	7003      	strb	r3, [r0, #0]
 80013e6:	47a8      	blx	r5
 80013e8:	7823      	ldrb	r3, [r4, #0]
 80013ea:	2b05      	cmp	r3, #5
 80013ec:	bf04      	itt	eq
 80013ee:	2302      	moveq	r3, #2
 80013f0:	7023      	strbeq	r3, [r4, #0]
 80013f2:	2200      	movs	r2, #0
 80013f4:	6122      	str	r2, [r4, #16]
 80013f6:	2320      	movs	r3, #32
 80013f8:	f383 8811 	msr	BASEPRI, r3
 *
 * @iclass
 */
void chThdResumeI(thread_reference_t *trp, msg_t msg) {

  if (*trp != NULL) {
 80013fc:	6963      	ldr	r3, [r4, #20]
 80013fe:	b133      	cbz	r3, 800140e <adc_lld_serve_rx_interrupt+0x5e>

    chDbgAssert(tp->p_state == CH_STATE_SUSPENDED,
                "not THD_STATE_SUSPENDED");

    *trp = NULL;
    tp->p_u.rdymsg = msg;
 8001400:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    thread_t *tp = *trp;

    chDbgAssert(tp->p_state == CH_STATE_SUSPENDED,
                "not THD_STATE_SUSPENDED");

    *trp = NULL;
 8001404:	6162      	str	r2, [r4, #20]
    tp->p_u.rdymsg = msg;
    (void) chSchReadyI(tp);
 8001406:	4618      	mov	r0, r3

    chDbgAssert(tp->p_state == CH_STATE_SUSPENDED,
                "not THD_STATE_SUSPENDED");

    *trp = NULL;
    tp->p_u.rdymsg = msg;
 8001408:	6219      	str	r1, [r3, #32]
    (void) chSchReadyI(tp);
 800140a:	f7ff fe91 	bl	8001130 <chSchReadyI>
 800140e:	2300      	movs	r3, #0
 8001410:	f383 8811 	msr	BASEPRI, r3
 8001414:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  }
  else {
    /* It is possible that the conversion group has already be reset by the
       ADC error handler, in this case this interrupt is spurious.*/
    if (adcp->grpp != NULL) {
 8001418:	6903      	ldr	r3, [r0, #16]
 800141a:	b1ab      	cbz	r3, 8001448 <adc_lld_serve_rx_interrupt+0x98>
      if ((flags & STM32_DMA_ISR_TCIF) != 0) {
 800141c:	078d      	lsls	r5, r1, #30
 800141e:	d511      	bpl.n	8001444 <adc_lld_serve_rx_interrupt+0x94>
        /* Transfer complete processing.*/
        _adc_isr_full_code(adcp);
 8001420:	781a      	ldrb	r2, [r3, #0]
 8001422:	b1e2      	cbz	r2, 800145e <adc_lld_serve_rx_interrupt+0xae>
 8001424:	685d      	ldr	r5, [r3, #4]
 8001426:	b17d      	cbz	r5, 8001448 <adc_lld_serve_rx_interrupt+0x98>
 8001428:	68c2      	ldr	r2, [r0, #12]
 800142a:	2a01      	cmp	r2, #1
 800142c:	d943      	bls.n	80014b6 <adc_lld_serve_rx_interrupt+0x106>
 800142e:	885b      	ldrh	r3, [r3, #2]
 8001430:	0852      	lsrs	r2, r2, #1
 8001432:	fb02 f303 	mul.w	r3, r2, r3
 8001436:	6881      	ldr	r1, [r0, #8]
 8001438:	eb01 0143 	add.w	r1, r1, r3, lsl #1
 800143c:	462b      	mov	r3, r5
        /* Half transfer processing.*/
        _adc_isr_half_code(adcp);
      }
    }
  }
}
 800143e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    /* It is possible that the conversion group has already be reset by the
       ADC error handler, in this case this interrupt is spurious.*/
    if (adcp->grpp != NULL) {
      if ((flags & STM32_DMA_ISR_TCIF) != 0) {
        /* Transfer complete processing.*/
        _adc_isr_full_code(adcp);
 8001442:	4718      	bx	r3
      }
      else if ((flags & STM32_DMA_ISR_HTIF) != 0) {
 8001444:	074a      	lsls	r2, r1, #29
 8001446:	d401      	bmi.n	800144c <adc_lld_serve_rx_interrupt+0x9c>
 8001448:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        /* Half transfer processing.*/
        _adc_isr_half_code(adcp);
 800144c:	685b      	ldr	r3, [r3, #4]
 800144e:	2b00      	cmp	r3, #0
 8001450:	d0fa      	beq.n	8001448 <adc_lld_serve_rx_interrupt+0x98>
      }
    }
  }
}
 8001452:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
        /* Transfer complete processing.*/
        _adc_isr_full_code(adcp);
      }
      else if ((flags & STM32_DMA_ISR_HTIF) != 0) {
        /* Half transfer processing.*/
        _adc_isr_half_code(adcp);
 8001456:	68c2      	ldr	r2, [r0, #12]
 8001458:	6881      	ldr	r1, [r0, #8]
 800145a:	0852      	lsrs	r2, r2, #1
 800145c:	4718      	bx	r3
 *
 * @notapi
 */
void adc_lld_stop_conversion(ADCDriver *adcp) {

  dmaStreamDisable(adcp->dmastp);
 800145e:	6ac1      	ldr	r1, [r0, #44]	; 0x2c
    /* It is possible that the conversion group has already be reset by the
       ADC error handler, in this case this interrupt is spurious.*/
    if (adcp->grpp != NULL) {
      if ((flags & STM32_DMA_ISR_TCIF) != 0) {
        /* Transfer complete processing.*/
        _adc_isr_full_code(adcp);
 8001460:	685d      	ldr	r5, [r3, #4]
 *
 * @notapi
 */
void adc_lld_stop_conversion(ADCDriver *adcp) {

  dmaStreamDisable(adcp->dmastp);
 8001462:	684e      	ldr	r6, [r1, #4]
 8001464:	680f      	ldr	r7, [r1, #0]
 8001466:	6833      	ldr	r3, [r6, #0]
 8001468:	f023 030f 	bic.w	r3, r3, #15
 800146c:	6033      	str	r3, [r6, #0]
 800146e:	7c0e      	ldrb	r6, [r1, #16]
  adcp->adc->CR1 = 0;
 8001470:	6a83      	ldr	r3, [r0, #40]	; 0x28
 *
 * @notapi
 */
void adc_lld_stop_conversion(ADCDriver *adcp) {

  dmaStreamDisable(adcp->dmastp);
 8001472:	210f      	movs	r1, #15
 8001474:	40b1      	lsls	r1, r6
  adcp->adc->CR1 = 0;
  adcp->adc->CR2 = 0;
  adcp->adc->CR2 = ADC_CR2_ADON;
 8001476:	2601      	movs	r6, #1
 *
 * @notapi
 */
void adc_lld_stop_conversion(ADCDriver *adcp) {

  dmaStreamDisable(adcp->dmastp);
 8001478:	6079      	str	r1, [r7, #4]
  adcp->adc->CR1 = 0;
 800147a:	605a      	str	r2, [r3, #4]
  adcp->adc->CR2 = 0;
 800147c:	609a      	str	r2, [r3, #8]
  adcp->adc->CR2 = ADC_CR2_ADON;
 800147e:	609e      	str	r6, [r3, #8]
    /* It is possible that the conversion group has already be reset by the
       ADC error handler, in this case this interrupt is spurious.*/
    if (adcp->grpp != NULL) {
      if ((flags & STM32_DMA_ISR_TCIF) != 0) {
        /* Transfer complete processing.*/
        _adc_isr_full_code(adcp);
 8001480:	b1a5      	cbz	r5, 80014ac <adc_lld_serve_rx_interrupt+0xfc>
 8001482:	2304      	movs	r3, #4
 8001484:	7003      	strb	r3, [r0, #0]
 8001486:	68c2      	ldr	r2, [r0, #12]
 8001488:	6881      	ldr	r1, [r0, #8]
 800148a:	47a8      	blx	r5
 800148c:	7823      	ldrb	r3, [r4, #0]
 800148e:	2b04      	cmp	r3, #4
 8001490:	d00c      	beq.n	80014ac <adc_lld_serve_rx_interrupt+0xfc>
 8001492:	2320      	movs	r3, #32
 8001494:	f383 8811 	msr	BASEPRI, r3
 *
 * @iclass
 */
void chThdResumeI(thread_reference_t *trp, msg_t msg) {

  if (*trp != NULL) {
 8001498:	6963      	ldr	r3, [r4, #20]
 800149a:	2b00      	cmp	r3, #0
 800149c:	d0b7      	beq.n	800140e <adc_lld_serve_rx_interrupt+0x5e>
    thread_t *tp = *trp;

    chDbgAssert(tp->p_state == CH_STATE_SUSPENDED,
                "not THD_STATE_SUSPENDED");

    *trp = NULL;
 800149e:	2200      	movs	r2, #0
 80014a0:	6162      	str	r2, [r4, #20]
    tp->p_u.rdymsg = msg;
    (void) chSchReadyI(tp);
 80014a2:	4618      	mov	r0, r3

    chDbgAssert(tp->p_state == CH_STATE_SUSPENDED,
                "not THD_STATE_SUSPENDED");

    *trp = NULL;
    tp->p_u.rdymsg = msg;
 80014a4:	621a      	str	r2, [r3, #32]
    (void) chSchReadyI(tp);
 80014a6:	f7ff fe43 	bl	8001130 <chSchReadyI>
 80014aa:	e7b0      	b.n	800140e <adc_lld_serve_rx_interrupt+0x5e>
 80014ac:	2202      	movs	r2, #2
 80014ae:	2300      	movs	r3, #0
 80014b0:	7022      	strb	r2, [r4, #0]
 80014b2:	6123      	str	r3, [r4, #16]
 80014b4:	e7ed      	b.n	8001492 <adc_lld_serve_rx_interrupt+0xe2>
 80014b6:	462b      	mov	r3, r5
        /* Half transfer processing.*/
        _adc_isr_half_code(adcp);
      }
    }
  }
}
 80014b8:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    /* It is possible that the conversion group has already be reset by the
       ADC error handler, in this case this interrupt is spurious.*/
    if (adcp->grpp != NULL) {
      if ((flags & STM32_DMA_ISR_TCIF) != 0) {
        /* Transfer complete processing.*/
        _adc_isr_full_code(adcp);
 80014bc:	6881      	ldr	r1, [r0, #8]
 80014be:	4718      	bx	r3

080014c0 <chThdExit>:
 *
 * @param[in] msg       thread exit code
 *
 * @api
 */
void chThdExit(msg_t msg) {
 80014c0:	b538      	push	{r3, r4, r5, lr}
 80014c2:	2220      	movs	r2, #32
 80014c4:	4603      	mov	r3, r0
 80014c6:	f382 8811 	msr	BASEPRI, r2
 * @param[in] msg       thread exit code
 *
 * @sclass
 */
void chThdExitS(msg_t msg) {
  thread_t *tp = currp;
 80014ca:	4a0e      	ldr	r2, [pc, #56]	; (8001504 <chThdExit+0x44>)
 80014cc:	6994      	ldr	r4, [r2, #24]
 *
 * @notapi
 */
static inline bool list_notempty(threads_list_t *tlp) {

  return (bool)(tlp->p_next != (thread_t *)tlp);
 80014ce:	6a60      	ldr	r0, [r4, #36]	; 0x24
  tp->p_u.exitcode = msg;
#if defined(CH_CFG_THREAD_EXIT_HOOK)
  CH_CFG_THREAD_EXIT_HOOK(tp);
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  while (list_notempty(&tp->p_waiting)) {
 80014d0:	f104 0524 	add.w	r5, r4, #36	; 0x24
 80014d4:	4285      	cmp	r5, r0
 * @sclass
 */
void chThdExitS(msg_t msg) {
  thread_t *tp = currp;

  tp->p_u.exitcode = msg;
 80014d6:	6223      	str	r3, [r4, #32]
#if defined(CH_CFG_THREAD_EXIT_HOOK)
  CH_CFG_THREAD_EXIT_HOOK(tp);
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  while (list_notempty(&tp->p_waiting)) {
 80014d8:	d006      	beq.n	80014e8 <chThdExit+0x28>
}

static inline thread_t *list_remove(threads_list_t *tlp) {

  thread_t *tp = tlp->p_next;
  tlp->p_next = tp->p_next;
 80014da:	6803      	ldr	r3, [r0, #0]
 80014dc:	6263      	str	r3, [r4, #36]	; 0x24
    (void) chSchReadyI(list_remove(&tp->p_waiting));
 80014de:	f7ff fe27 	bl	8001130 <chSchReadyI>
 *
 * @notapi
 */
static inline bool list_notempty(threads_list_t *tlp) {

  return (bool)(tlp->p_next != (thread_t *)tlp);
 80014e2:	6a60      	ldr	r0, [r4, #36]	; 0x24
  tp->p_u.exitcode = msg;
#if defined(CH_CFG_THREAD_EXIT_HOOK)
  CH_CFG_THREAD_EXIT_HOOK(tp);
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  while (list_notempty(&tp->p_waiting)) {
 80014e4:	42a8      	cmp	r0, r5
 80014e6:	d1f8      	bne.n	80014da <chThdExit+0x1a>
  }
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  /* Static threads are immediately removed from the registry because
     there is no memory to recover.*/
  if ((tp->p_flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC) {
 80014e8:	7f63      	ldrb	r3, [r4, #29]
 80014ea:	079b      	lsls	r3, r3, #30
 80014ec:	d104      	bne.n	80014f8 <chThdExit+0x38>
    REG_REMOVE(tp);
 80014ee:	6922      	ldr	r2, [r4, #16]
 80014f0:	6963      	ldr	r3, [r4, #20]
 80014f2:	611a      	str	r2, [r3, #16]
 80014f4:	6922      	ldr	r2, [r4, #16]
 80014f6:	6153      	str	r3, [r2, #20]
  }
#endif
  chSchGoSleepS(CH_STATE_FINAL);
 80014f8:	200f      	movs	r0, #15
void chThdExit(msg_t msg) {

  chSysLock();
  chThdExitS(msg);
  /* The thread never returns here.*/
}
 80014fa:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
     there is no memory to recover.*/
  if ((tp->p_flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC) {
    REG_REMOVE(tp);
  }
#endif
  chSchGoSleepS(CH_STATE_FINAL);
 80014fe:	f7ff b86f 	b.w	80005e0 <chSchGoSleepS>
 8001502:	bf00      	nop
 8001504:	20000800 	.word	0x20000800
	...

08001510 <__init_ram_areas>:
}

/**
 * @brief   Performs the initialization of the various RAM areas.
 */
void __init_ram_areas(void) {
 8001510:	b5f0      	push	{r4, r5, r6, r7, lr}
 8001512:	4f13      	ldr	r7, [pc, #76]	; (8001560 <__init_ram_areas+0x50>)
 8001514:	4d13      	ldr	r5, [pc, #76]	; (8001564 <__init_ram_areas+0x54>)
 8001516:	4c14      	ldr	r4, [pc, #80]	; (8001568 <__init_ram_areas+0x58>)
 8001518:	4b14      	ldr	r3, [pc, #80]	; (800156c <__init_ram_areas+0x5c>)
 800151a:	4915      	ldr	r1, [pc, #84]	; (8001570 <__init_ram_areas+0x60>)
 800151c:	f107 0e70 	add.w	lr, r7, #112	; 0x70
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
      *p = 0;
 8001520:	2600      	movs	r6, #0
  do {
    uint32_t *tp = rap->init_text_area;
    uint32_t *p = rap->init_area;

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
 8001522:	429c      	cmp	r4, r3
 8001524:	d911      	bls.n	800154a <__init_ram_areas+0x3a>
 8001526:	461a      	mov	r2, r3
 8001528:	3904      	subs	r1, #4
      *p = *tp;
 800152a:	f851 0f04 	ldr.w	r0, [r1, #4]!
 800152e:	f842 0b04 	str.w	r0, [r2], #4
  do {
    uint32_t *tp = rap->init_text_area;
    uint32_t *p = rap->init_area;

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
 8001532:	4294      	cmp	r4, r2
 8001534:	d8f9      	bhi.n	800152a <__init_ram_areas+0x1a>
 8001536:	43da      	mvns	r2, r3
 8001538:	4414      	add	r4, r2
 800153a:	f024 0403 	bic.w	r4, r4, #3
 800153e:	3404      	adds	r4, #4
 8001540:	4423      	add	r3, r4
      p++;
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
 8001542:	429d      	cmp	r5, r3
 8001544:	d903      	bls.n	800154e <__init_ram_areas+0x3e>
      *p = 0;
 8001546:	f843 6b04 	str.w	r6, [r3], #4
      p++;
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
 800154a:	429d      	cmp	r5, r3
 800154c:	d8fb      	bhi.n	8001546 <__init_ram_areas+0x36>
      *p = 0;
      p++;
    }
    rap++;
  }
  while (rap < &ram_areas[CRT1_AREAS_NUMBER]);
 800154e:	4577      	cmp	r7, lr
 8001550:	d005      	beq.n	800155e <__init_ram_areas+0x4e>
 8001552:	6939      	ldr	r1, [r7, #16]
 8001554:	697b      	ldr	r3, [r7, #20]
 8001556:	69bc      	ldr	r4, [r7, #24]
 8001558:	69fd      	ldr	r5, [r7, #28]
 800155a:	3710      	adds	r7, #16
 800155c:	e7e1      	b.n	8001522 <__init_ram_areas+0x12>
 800155e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8001560:	080017b0 	.word	0x080017b0
 8001564:	20000a60 	.word	0x20000a60
 8001568:	20000a60 	.word	0x20000a60
 800156c:	20000a60 	.word	0x20000a60
 8001570:	08001858 	.word	0x08001858
	...

08001580 <__default_exit>:
 */
#if !defined(__DOXYGEN__)
__attribute__((noreturn, weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __default_exit(void) {
 8001580:	e7fe      	b.n	8001580 <__default_exit>
 8001582:	bf00      	nop
	...

08001590 <__late_init>:
 8001590:	4770      	bx	lr
 8001592:	bf00      	nop
	...

080015a0 <__core_init>:
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __core_init(void) {
 80015a0:	4770      	bx	lr
 80015a2:	bf00      	nop
	...

080015b0 <chTMStartMeasurementX.constprop.22>:
 *
 * @return              The realtime counter value.
 */
static inline rtcnt_t port_rt_get_counter_value(void) {

  return DWT->CYCCNT;
 80015b0:	4b01      	ldr	r3, [pc, #4]	; (80015b8 <chTMStartMeasurementX.constprop.22+0x8>)
 80015b2:	685b      	ldr	r3, [r3, #4]
 *
 * @xclass
 */
NOINLINE void chTMStartMeasurementX(time_measurement_t *tmp) {

  tmp->last = chSysGetRealtimeCounterX();
 80015b4:	6083      	str	r3, [r0, #8]
 80015b6:	4770      	bx	lr
 80015b8:	e0001000 	.word	0xe0001000
 80015bc:	00000000 	.word	0x00000000

080015c0 <chEvtBroadcastFlagsI.constprop.18>:
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
 80015c0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  event_listener_t *elp;

  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->es_next;
 80015c2:	4f17      	ldr	r7, [pc, #92]	; (8001620 <chEvtBroadcastFlagsI.constprop.18+0x60>)
 80015c4:	f857 4f04 	ldr.w	r4, [r7, #4]!
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 80015c8:	42bc      	cmp	r4, r7
 80015ca:	d020      	beq.n	800160e <chEvtBroadcastFlagsI.constprop.18+0x4e>
 80015cc:	4605      	mov	r5, r0
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
      ((tp->p_state == CH_STATE_WTANDEVT) &&
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask))) {
    tp->p_u.rdymsg = MSG_OK;
 80015ce:	2600      	movs	r6, #0
 80015d0:	e002      	b.n	80015d8 <chEvtBroadcastFlagsI.constprop.18+0x18>
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
        ((elp->el_flags & elp->el_wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->el_listener, elp->el_events);
    }
    elp = elp->el_next;
 80015d2:	6824      	ldr	r4, [r4, #0]
  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->es_next;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 80015d4:	42bc      	cmp	r4, r7
 80015d6:	d01a      	beq.n	800160e <chEvtBroadcastFlagsI.constprop.18+0x4e>
  /*lint -restore*/
    elp->el_flags |= flags;
 80015d8:	68e3      	ldr	r3, [r4, #12]
 80015da:	432b      	orrs	r3, r5
 80015dc:	60e3      	str	r3, [r4, #12]
    /* When flags == 0 the thread will always be signaled because the
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
 80015de:	b115      	cbz	r5, 80015e6 <chEvtBroadcastFlagsI.constprop.18+0x26>
 80015e0:	6922      	ldr	r2, [r4, #16]
 80015e2:	4213      	tst	r3, r2
 80015e4:	d0f5      	beq.n	80015d2 <chEvtBroadcastFlagsI.constprop.18+0x12>
        ((elp->el_flags & elp->el_wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->el_listener, elp->el_events);
 80015e6:	6860      	ldr	r0, [r4, #4]
void chEvtSignalI(thread_t *tp, eventmask_t events) {

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
 80015e8:	68a1      	ldr	r1, [r4, #8]
 80015ea:	6b43      	ldr	r3, [r0, #52]	; 0x34
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 80015ec:	7f02      	ldrb	r2, [r0, #28]
void chEvtSignalI(thread_t *tp, eventmask_t events) {

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
 80015ee:	430b      	orrs	r3, r1
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 80015f0:	2a0a      	cmp	r2, #10
void chEvtSignalI(thread_t *tp, eventmask_t events) {

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
 80015f2:	6343      	str	r3, [r0, #52]	; 0x34
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 80015f4:	d00c      	beq.n	8001610 <chEvtBroadcastFlagsI.constprop.18+0x50>
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
 80015f6:	2a0b      	cmp	r2, #11
 80015f8:	d1eb      	bne.n	80015d2 <chEvtBroadcastFlagsI.constprop.18+0x12>
      ((tp->p_state == CH_STATE_WTANDEVT) &&
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask))) {
 80015fa:	6a02      	ldr	r2, [r0, #32]

  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
      ((tp->p_state == CH_STATE_WTANDEVT) &&
 80015fc:	ea32 0303 	bics.w	r3, r2, r3
 8001600:	d1e7      	bne.n	80015d2 <chEvtBroadcastFlagsI.constprop.18+0x12>
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask))) {
    tp->p_u.rdymsg = MSG_OK;
 8001602:	6206      	str	r6, [r0, #32]
    (void) chSchReadyI(tp);
 8001604:	f7ff fd94 	bl	8001130 <chSchReadyI>
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
        ((elp->el_flags & elp->el_wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->el_listener, elp->el_events);
    }
    elp = elp->el_next;
 8001608:	6824      	ldr	r4, [r4, #0]
  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->es_next;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 800160a:	42bc      	cmp	r4, r7
 800160c:	d1e4      	bne.n	80015d8 <chEvtBroadcastFlagsI.constprop.18+0x18>
 800160e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 8001610:	6a02      	ldr	r2, [r0, #32]
 8001612:	4213      	tst	r3, r2
 8001614:	d0dd      	beq.n	80015d2 <chEvtBroadcastFlagsI.constprop.18+0x12>
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
      ((tp->p_state == CH_STATE_WTANDEVT) &&
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask))) {
    tp->p_u.rdymsg = MSG_OK;
 8001616:	6206      	str	r6, [r0, #32]
    (void) chSchReadyI(tp);
 8001618:	f7ff fd8a 	bl	8001130 <chSchReadyI>
 800161c:	e7f4      	b.n	8001608 <chEvtBroadcastFlagsI.constprop.18+0x48>
 800161e:	bf00      	nop
 8001620:	200009e8 	.word	0x200009e8
	...

08001630 <_pal_lld_setgroupmode.constprop.2>:
 * @param[in] mask      the group mask
 * @param[in] mode      the mode
 *
 * @notapi
 */
void _pal_lld_setgroupmode(ioportid_t port,
 8001630:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}

      altrmask = altr << ((bit & 7) * 4);
      m1 = 1 << bit;
      m2 = 3 << (bit * 2);
      m4 = 15 << ((bit & 7) * 4);
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
 8001634:	4b2f      	ldr	r3, [pc, #188]	; (80016f4 <_pal_lld_setgroupmode.constprop.2+0xc4>)
  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
  uint32_t otyper  = (mode & PAL_STM32_OTYPE_MASK) >> 2;
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
  uint32_t pupdr   = (mode & PAL_STM32_PUPDR_MASK) >> 5;
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
  uint32_t bit     = 0;
 8001636:	2400      	movs	r4, #0
 */
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {

  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
 8001638:	2502      	movs	r5, #2
  uint32_t bit     = 0;
  while (true) {
    if ((mask & 1) != 0) {
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
 800163a:	f04f 0c07 	mov.w	ip, #7
      m1 = 1 << bit;
      m2 = 3 << (bit * 2);
      m4 = 15 << ((bit & 7) * 4);
 800163e:	f04f 0e0f 	mov.w	lr, #15
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
 8001642:	2701      	movs	r7, #1
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 8001644:	2603      	movs	r6, #3
 8001646:	e009      	b.n	800165c <_pal_lld_setgroupmode.constprop.2+0x2c>
      else {
        /* If going into a non-alternate mode then the mode is switched
           before setting the alternate mode in order to avoid glitches.*/
        port->MODER   = (port->MODER & ~m2) | moder;
        if (bit < 8)
          port->AFRL = (port->AFRL & ~m4) | altrmask;
 8001648:	6a19      	ldr	r1, [r3, #32]
 800164a:	ea21 0202 	bic.w	r2, r1, r2
 800164e:	ea42 0208 	orr.w	r2, r2, r8
 8001652:	621a      	str	r2, [r3, #32]
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
      }
    }
    mask >>= 1;
    if (!mask)
 8001654:	0840      	lsrs	r0, r0, #1
 8001656:	d033      	beq.n	80016c0 <_pal_lld_setgroupmode.constprop.2+0x90>
      return;
    otyper <<= 1;
    ospeedr <<= 2;
    pupdr <<= 2;
    moder <<= 2;
 8001658:	00ad      	lsls	r5, r5, #2
    bit++;
 800165a:	3401      	adds	r4, #1
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
  uint32_t pupdr   = (mode & PAL_STM32_PUPDR_MASK) >> 5;
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
  uint32_t bit     = 0;
  while (true) {
    if ((mask & 1) != 0) {
 800165c:	07c2      	lsls	r2, r0, #31
 800165e:	d5f9      	bpl.n	8001654 <_pal_lld_setgroupmode.constprop.2+0x24>
      altrmask = altr << ((bit & 7) * 4);
      m1 = 1 << bit;
      m2 = 3 << (bit * 2);
      m4 = 15 << ((bit & 7) * 4);
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 8001660:	0061      	lsls	r1, r4, #1
 8001662:	fa06 f101 	lsl.w	r1, r6, r1
 8001666:	43c9      	mvns	r1, r1

      altrmask = altr << ((bit & 7) * 4);
      m1 = 1 << bit;
      m2 = 3 << (bit * 2);
      m4 = 15 << ((bit & 7) * 4);
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
 8001668:	685a      	ldr	r2, [r3, #4]
 800166a:	fa07 f804 	lsl.w	r8, r7, r4
 800166e:	ea22 0208 	bic.w	r2, r2, r8
 8001672:	605a      	str	r2, [r3, #4]
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 8001674:	f8d3 8008 	ldr.w	r8, [r3, #8]
  uint32_t bit     = 0;
  while (true) {
    if ((mask & 1) != 0) {
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
 8001678:	f004 0207 	and.w	r2, r4, #7
      m1 = 1 << bit;
      m2 = 3 << (bit * 2);
      m4 = 15 << ((bit & 7) * 4);
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 800167c:	ea08 0801 	and.w	r8, r8, r1
 8001680:	f8c3 8008 	str.w	r8, [r3, #8]
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
 8001684:	f8d3 800c 	ldr.w	r8, [r3, #12]
  uint32_t bit     = 0;
  while (true) {
    if ((mask & 1) != 0) {
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
 8001688:	0092      	lsls	r2, r2, #2
      m1 = 1 << bit;
      m2 = 3 << (bit * 2);
      m4 = 15 << ((bit & 7) * 4);
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
 800168a:	ea01 0808 	and.w	r8, r1, r8
      if (moder == PAL_STM32_MODE_ALTERNATE) {
 800168e:	2d02      	cmp	r5, #2
      m1 = 1 << bit;
      m2 = 3 << (bit * 2);
      m4 = 15 << ((bit & 7) * 4);
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
 8001690:	f8c3 800c 	str.w	r8, [r3, #12]
  uint32_t bit     = 0;
  while (true) {
    if ((mask & 1) != 0) {
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
 8001694:	fa0c f802 	lsl.w	r8, ip, r2
      m1 = 1 << bit;
      m2 = 3 << (bit * 2);
      m4 = 15 << ((bit & 7) * 4);
 8001698:	fa0e f202 	lsl.w	r2, lr, r2
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
      if (moder == PAL_STM32_MODE_ALTERNATE) {
 800169c:	d012      	beq.n	80016c4 <_pal_lld_setgroupmode.constprop.2+0x94>
        port->MODER   = (port->MODER & ~m2) | moder;
      }
      else {
        /* If going into a non-alternate mode then the mode is switched
           before setting the alternate mode in order to avoid glitches.*/
        port->MODER   = (port->MODER & ~m2) | moder;
 800169e:	f8d3 9000 	ldr.w	r9, [r3]
        if (bit < 8)
 80016a2:	2c07      	cmp	r4, #7
        port->MODER   = (port->MODER & ~m2) | moder;
      }
      else {
        /* If going into a non-alternate mode then the mode is switched
           before setting the alternate mode in order to avoid glitches.*/
        port->MODER   = (port->MODER & ~m2) | moder;
 80016a4:	ea01 0109 	and.w	r1, r1, r9
 80016a8:	ea41 0105 	orr.w	r1, r1, r5
 80016ac:	6019      	str	r1, [r3, #0]
        if (bit < 8)
 80016ae:	d9cb      	bls.n	8001648 <_pal_lld_setgroupmode.constprop.2+0x18>
          port->AFRL = (port->AFRL & ~m4) | altrmask;
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
 80016b0:	6a59      	ldr	r1, [r3, #36]	; 0x24
      }
    }
    mask >>= 1;
    if (!mask)
 80016b2:	0840      	lsrs	r0, r0, #1
           before setting the alternate mode in order to avoid glitches.*/
        port->MODER   = (port->MODER & ~m2) | moder;
        if (bit < 8)
          port->AFRL = (port->AFRL & ~m4) | altrmask;
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
 80016b4:	ea21 0202 	bic.w	r2, r1, r2
 80016b8:	ea42 0208 	orr.w	r2, r2, r8
 80016bc:	625a      	str	r2, [r3, #36]	; 0x24
      }
    }
    mask >>= 1;
    if (!mask)
 80016be:	d1cb      	bne.n	8001658 <_pal_lld_setgroupmode.constprop.2+0x28>
 80016c0:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
      if (moder == PAL_STM32_MODE_ALTERNATE) {
        /* If going in alternate mode then the alternate number is set
           before switching mode in order to avoid glitches.*/
        if (bit < 8)
 80016c4:	2c07      	cmp	r4, #7
 80016c6:	d80c      	bhi.n	80016e2 <_pal_lld_setgroupmode.constprop.2+0xb2>
          port->AFRL = (port->AFRL & ~m4) | altrmask;
 80016c8:	f8d3 9020 	ldr.w	r9, [r3, #32]
 80016cc:	ea29 0202 	bic.w	r2, r9, r2
 80016d0:	ea42 0208 	orr.w	r2, r2, r8
 80016d4:	621a      	str	r2, [r3, #32]
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
        port->MODER   = (port->MODER & ~m2) | moder;
 80016d6:	681a      	ldr	r2, [r3, #0]
 80016d8:	4011      	ands	r1, r2
 80016da:	f041 0102 	orr.w	r1, r1, #2
 80016de:	6019      	str	r1, [r3, #0]
 80016e0:	e7b8      	b.n	8001654 <_pal_lld_setgroupmode.constprop.2+0x24>
        /* If going in alternate mode then the alternate number is set
           before switching mode in order to avoid glitches.*/
        if (bit < 8)
          port->AFRL = (port->AFRL & ~m4) | altrmask;
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
 80016e2:	f8d3 9024 	ldr.w	r9, [r3, #36]	; 0x24
 80016e6:	ea29 0202 	bic.w	r2, r9, r2
 80016ea:	ea42 0208 	orr.w	r2, r2, r8
 80016ee:	625a      	str	r2, [r3, #36]	; 0x24
 80016f0:	e7f1      	b.n	80016d6 <_pal_lld_setgroupmode.constprop.2+0xa6>
 80016f2:	bf00      	nop
 80016f4:	40020000 	.word	0x40020000
	...

08001700 <vmt>:
 8001700:	08000821 08000941 080008a1 080009b1     !...A...........
 8001710:	08000891 080009a1 08000811 08000931     ............1...

08001720 <_stm32_dma_streams>:
 8001720:	40026000 40026008 00000001 00000000     .`.@.`.@........
 8001730:	000b0000 40026000 4002601c 00000002     .....`.@.`.@....
 8001740:	00000000 000c0104 40026000 40026030     .........`.@0`.@
 8001750:	00000004 00000000 000d0208 40026000     .............`.@
 8001760:	40026044 00000008 00000000 000e030c     D`.@............
 8001770:	40026000 40026058 00000010 00000000     .`.@X`.@........
 8001780:	000f0410 40026000 4002606c 00000020     .....`.@l`.@ ...
 8001790:	00000000 00100514 40026000 40026080     .........`.@.`.@
 80017a0:	00000040 00000000 00110618 00000000     @...............

080017b0 <ram_areas>:
 80017b0:	08001858 20000a60 20000a60 20000a60     X...`.. `.. `.. 
 80017c0:	08001858 00000000 00000000 00000000     X...............
 80017d0:	08001858 00000000 00000000 00000000     X...............
 80017e0:	08001858 00000000 00000000 00000000     X...............
 80017f0:	08001858 00000000 00000000 00000000     X...............
 8001800:	08001858 00000000 00000000 00000000     X...............
 8001810:	08001858 00000000 00000000 00000000     X...............
 8001820:	08001858 00000000 00000000 00000000     X...............

08001830 <ch_debug>:
 8001830:	6e69616d 18431600 08440204 1814100c     main..C...D.....
 8001840:	1e1d1c00 00000000 00000000 00000000     ................
 8001850:	656c6469 00000000                       idle....
