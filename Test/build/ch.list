
build/ch.elf:     file format elf32-littlearm


Disassembly of section .text:

08000140 <Reset_Handler>:
 8000140:	b672      	cpsid	i
 8000142:	4823      	ldr	r0, [pc, #140]	; (80001d0 <endfiniloop+0x6>)
 8000144:	f380 8809 	msr	PSP, r0
 8000148:	2002      	movs	r0, #2
 800014a:	f380 8814 	msr	CONTROL, r0
 800014e:	f3bf 8f6f 	isb	sy
 8000152:	f000 ff75 	bl	8001040 <__core_init>
 8000156:	f000 fa6b 	bl	8000630 <__early_init>
 800015a:	f04f 3055 	mov.w	r0, #1431655765	; 0x55555555
 800015e:	491d      	ldr	r1, [pc, #116]	; (80001d4 <endfiniloop+0xa>)
 8000160:	4a1d      	ldr	r2, [pc, #116]	; (80001d8 <endfiniloop+0xe>)

08000162 <msloop>:
 8000162:	4291      	cmp	r1, r2
 8000164:	bf3c      	itt	cc
 8000166:	f841 0b04 	strcc.w	r0, [r1], #4
 800016a:	e7fa      	bcc.n	8000162 <msloop>
 800016c:	491b      	ldr	r1, [pc, #108]	; (80001dc <endfiniloop+0x12>)
 800016e:	4a18      	ldr	r2, [pc, #96]	; (80001d0 <endfiniloop+0x6>)

08000170 <psloop>:
 8000170:	4291      	cmp	r1, r2
 8000172:	bf3c      	itt	cc
 8000174:	f841 0b04 	strcc.w	r0, [r1], #4
 8000178:	e7fa      	bcc.n	8000170 <psloop>
 800017a:	4919      	ldr	r1, [pc, #100]	; (80001e0 <endfiniloop+0x16>)
 800017c:	4a19      	ldr	r2, [pc, #100]	; (80001e4 <endfiniloop+0x1a>)
 800017e:	4b1a      	ldr	r3, [pc, #104]	; (80001e8 <endfiniloop+0x1e>)

08000180 <dloop>:
 8000180:	429a      	cmp	r2, r3
 8000182:	bf3e      	ittt	cc
 8000184:	f851 0b04 	ldrcc.w	r0, [r1], #4
 8000188:	f842 0b04 	strcc.w	r0, [r2], #4
 800018c:	e7f8      	bcc.n	8000180 <dloop>
 800018e:	2000      	movs	r0, #0
 8000190:	4916      	ldr	r1, [pc, #88]	; (80001ec <endfiniloop+0x22>)
 8000192:	4a17      	ldr	r2, [pc, #92]	; (80001f0 <endfiniloop+0x26>)

08000194 <bloop>:
 8000194:	4291      	cmp	r1, r2
 8000196:	bf3c      	itt	cc
 8000198:	f841 0b04 	strcc.w	r0, [r1], #4
 800019c:	e7fa      	bcc.n	8000194 <bloop>
 800019e:	f000 ff07 	bl	8000fb0 <__init_ram_areas>
 80001a2:	f000 ff45 	bl	8001030 <__late_init>
 80001a6:	4c13      	ldr	r4, [pc, #76]	; (80001f4 <endfiniloop+0x2a>)
 80001a8:	4d13      	ldr	r5, [pc, #76]	; (80001f8 <endfiniloop+0x2e>)

080001aa <initloop>:
 80001aa:	42ac      	cmp	r4, r5
 80001ac:	da03      	bge.n	80001b6 <endinitloop>
 80001ae:	f854 1b04 	ldr.w	r1, [r4], #4
 80001b2:	4788      	blx	r1
 80001b4:	e7f9      	b.n	80001aa <initloop>

080001b6 <endinitloop>:
 80001b6:	f001 fa3b 	bl	8001630 <main>
 80001ba:	4c10      	ldr	r4, [pc, #64]	; (80001fc <endfiniloop+0x32>)
 80001bc:	4d10      	ldr	r5, [pc, #64]	; (8000200 <endfiniloop+0x36>)

080001be <finiloop>:
 80001be:	42ac      	cmp	r4, r5
 80001c0:	da03      	bge.n	80001ca <endfiniloop>
 80001c2:	f854 1b04 	ldr.w	r1, [r4], #4
 80001c6:	4788      	blx	r1
 80001c8:	e7f9      	b.n	80001be <finiloop>

080001ca <endfiniloop>:
 80001ca:	f000 bf29 	b.w	8001020 <__default_exit>
 80001ce:	0000      	.short	0x0000
 80001d0:	20000800 	.word	0x20000800
 80001d4:	20000000 	.word	0x20000000
 80001d8:	20000400 	.word	0x20000400
 80001dc:	20000400 	.word	0x20000400
 80001e0:	080020a0 	.word	0x080020a0
 80001e4:	20000800 	.word	0x20000800
 80001e8:	20000818 	.word	0x20000818
 80001ec:	20000818 	.word	0x20000818
 80001f0:	20000d68 	.word	0x20000d68
 80001f4:	08000140 	.word	0x08000140
 80001f8:	08000140 	.word	0x08000140
 80001fc:	08000140 	.word	0x08000140
 8000200:	08000140 	.word	0x08000140
	...

08000210 <_port_switch>:
 8000210:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8000214:	f8c1 d00c 	str.w	sp, [r1, #12]
 8000218:	68c3      	ldr	r3, [r0, #12]
 800021a:	469d      	mov	sp, r3
 800021c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08000220 <_port_thread_start>:
 8000220:	2300      	movs	r3, #0
 8000222:	f383 8811 	msr	BASEPRI, r3
 8000226:	4628      	mov	r0, r5
 8000228:	47a0      	blx	r4
 800022a:	2000      	movs	r0, #0
 800022c:	f000 fe98 	bl	8000f60 <chThdExit>

08000230 <_port_switch_from_isr>:
 8000230:	f000 fac6 	bl	80007c0 <chSchDoReschedule>

08000234 <_port_exit_from_isr>:
 8000234:	df00      	svc	0
 8000236:	e7fe      	b.n	8000236 <_port_exit_from_isr+0x2>
	...

08000240 <notify1.lto_priv.36>:

#if STM32_SERIAL_USE_USART1 || defined(__DOXYGEN__)
static void notify1(io_queue_t *qp) {

  (void)qp;
  USART1->CR1 |= USART_CR1_TXEIE;
 8000240:	4a02      	ldr	r2, [pc, #8]	; (800024c <notify1.lto_priv.36+0xc>)
 8000242:	68d3      	ldr	r3, [r2, #12]
 8000244:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8000248:	60d3      	str	r3, [r2, #12]
 800024a:	4770      	bx	lr
 800024c:	40013800 	.word	0x40013800

08000250 <_port_irq_epilogue>:

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8000250:	2320      	movs	r3, #32
 8000252:	f383 8811 	msr	BASEPRI, r3
 * @brief   Exception exit redirection to _port_switch_from_isr().
 */
void _port_irq_epilogue(void) {

  port_lock_from_isr();
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
 8000256:	4b0f      	ldr	r3, [pc, #60]	; (8000294 <_port_irq_epilogue+0x44>)
 8000258:	685b      	ldr	r3, [r3, #4]
 800025a:	f413 6300 	ands.w	r3, r3, #2048	; 0x800
 800025e:	d102      	bne.n	8000266 <_port_irq_epilogue+0x16>
 8000260:	f383 8811 	msr	BASEPRI, r3
 8000264:	4770      	bx	lr
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 8000266:	f3ef 8309 	mrs	r3, PSP
    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;

    /* Setting up a fake XPSR register value.*/
    ctxp->xpsr = (regarm_t)0x01000000;
 800026a:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
 800026e:	f843 2c04 	str.w	r2, [r3, #-4]

    \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 8000272:	f1a3 0220 	sub.w	r2, r3, #32
 8000276:	f382 8809 	msr	PSP, r2
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
  tprio_t p1 = firstprio(&ch.rlist.r_queue);
 800027a:	4a07      	ldr	r2, [pc, #28]	; (8000298 <_port_irq_epilogue+0x48>)
 800027c:	6811      	ldr	r1, [r2, #0]
  tprio_t p2 = currp->p_prio;
 800027e:	6992      	ldr	r2, [r2, #24]
    /* Writing back the modified PSP value.*/
    __set_PSP((uint32_t)ctxp);

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
 8000280:	6889      	ldr	r1, [r1, #8]
 8000282:	6892      	ldr	r2, [r2, #8]
 8000284:	4291      	cmp	r1, r2
      /* Preemption is required we need to enforce a context switch.*/
      ctxp->pc = (regarm_t)_port_switch_from_isr;
 8000286:	bf8c      	ite	hi
 8000288:	4a04      	ldrhi	r2, [pc, #16]	; (800029c <_port_irq_epilogue+0x4c>)
    }
    else {
      /* Preemption not required, we just need to exit the exception
         atomically.*/
      ctxp->pc = (regarm_t)_port_exit_from_isr;
 800028a:	4a05      	ldrls	r2, [pc, #20]	; (80002a0 <_port_irq_epilogue+0x50>)
 800028c:	f843 2c08 	str.w	r2, [r3, #-8]
 8000290:	4770      	bx	lr
 8000292:	bf00      	nop
 8000294:	e000ed00 	.word	0xe000ed00
 8000298:	20000c18 	.word	0x20000c18
 800029c:	08000231 	.word	0x08000231
 80002a0:	08000234 	.word	0x08000234
	...

080002b0 <VectorB0>:
 * @brief   TIM2 interrupt handler.
 * @details This interrupt is used for system tick in free running mode.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(ST_HANDLER) {
 80002b0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  OSAL_IRQ_PROLOGUE();

  /* Note, under rare circumstances an interrupt can remain latched even if
     the timer SR register has been cleared, in those cases the interrupt
     is simply ignored.*/
  if ((STM32_ST_TIM->SR & TIM_SR_CC1IF) != 0U) {
 80002b4:	f04f 4480 	mov.w	r4, #1073741824	; 0x40000000
 80002b8:	6923      	ldr	r3, [r4, #16]
 80002ba:	079b      	lsls	r3, r3, #30
 80002bc:	d403      	bmi.n	80002c6 <VectorB0+0x16>
    osalOsTimerHandlerI();
    osalSysUnlockFromISR();
  }

  OSAL_IRQ_EPILOGUE();
}
 80002be:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    osalSysLockFromISR();
    osalOsTimerHandlerI();
    osalSysUnlockFromISR();
  }

  OSAL_IRQ_EPILOGUE();
 80002c2:	f7ff bfc5 	b.w	8000250 <_port_irq_epilogue>

  /* Note, under rare circumstances an interrupt can remain latched even if
     the timer SR register has been cleared, in those cases the interrupt
     is simply ignored.*/
  if ((STM32_ST_TIM->SR & TIM_SR_CC1IF) != 0U) {
    STM32_ST_TIM->SR = 0U;
 80002c6:	2700      	movs	r7, #0
 80002c8:	6127      	str	r7, [r4, #16]

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 80002ca:	2520      	movs	r5, #32
 80002cc:	f385 8811 	msr	BASEPRI, r5
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  virtual_timer_t *vtp;
  systime_t now, delta;

  /* First timer to be processed.*/
  vtp = ch.vtlist.vt_next;
 80002d0:	4e1e      	ldr	r6, [pc, #120]	; (800034c <VectorB0+0x9c>)
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 80002d2:	6a62      	ldr	r2, [r4, #36]	; 0x24

  /* All timers within the time window are triggered and removed,
     note that the loop is stopped by the timers header having
     "ch.vtlist.vt_delta == (systime_t)-1" which is greater than
     all deltas.*/
  while (vtp->vt_delta <= (systime_t)(now - ch.vtlist.vt_lasttime)) {
 80002d4:	f8b6 e026 	ldrh.w	lr, [r6, #38]	; 0x26
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  virtual_timer_t *vtp;
  systime_t now, delta;

  /* First timer to be processed.*/
  vtp = ch.vtlist.vt_next;
 80002d8:	69f3      	ldr	r3, [r6, #28]
 80002da:	b290      	uxth	r0, r2

  /* All timers within the time window are triggered and removed,
     note that the loop is stopped by the timers header having
     "ch.vtlist.vt_delta == (systime_t)-1" which is greater than
     all deltas.*/
  while (vtp->vt_delta <= (systime_t)(now - ch.vtlist.vt_lasttime)) {
 80002dc:	ebce 0100 	rsb	r1, lr, r0
 80002e0:	891a      	ldrh	r2, [r3, #8]
 80002e2:	b289      	uxth	r1, r1
 80002e4:	4291      	cmp	r1, r2
 80002e6:	f106 081c 	add.w	r8, r6, #28
 80002ea:	d31b      	bcc.n	8000324 <VectorB0+0x74>
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.vt_lasttime += vtp->vt_delta;

    vtp->vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
 80002ec:	6819      	ldr	r1, [r3, #0]
     all deltas.*/
  while (vtp->vt_delta <= (systime_t)(now - ch.vtlist.vt_lasttime)) {
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.vt_lasttime += vtp->vt_delta;
 80002ee:	4472      	add	r2, lr
    ch.vtlist.vt_next = vtp->vt_next;
    fn = vtp->vt_func;
    vtp->vt_func = NULL;

    /* if the list becomes empty then the timer is stopped.*/
    if (ch.vtlist.vt_next == (virtual_timer_t *)&ch.vtlist) {
 80002f0:	4541      	cmp	r1, r8
     all deltas.*/
  while (vtp->vt_delta <= (systime_t)(now - ch.vtlist.vt_lasttime)) {
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.vt_lasttime += vtp->vt_delta;
 80002f2:	84f2      	strh	r2, [r6, #38]	; 0x26

    vtp->vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
    ch.vtlist.vt_next = vtp->vt_next;
    fn = vtp->vt_func;
 80002f4:	68da      	ldr	r2, [r3, #12]
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.vt_lasttime += vtp->vt_delta;

    vtp->vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
 80002f6:	f8c1 8004 	str.w	r8, [r1, #4]
    ch.vtlist.vt_next = vtp->vt_next;
 80002fa:	61f1      	str	r1, [r6, #28]
    fn = vtp->vt_func;
    vtp->vt_func = NULL;
 80002fc:	60df      	str	r7, [r3, #12]
 *
 * @notapi
 */
static inline void st_lld_stop_alarm(void) {

  STM32_ST_TIM->DIER = 0;
 80002fe:	bf08      	it	eq
 8000300:	60e7      	streq	r7, [r4, #12]
 8000302:	f387 8811 	msr	BASEPRI, r7
       and in order to give a preemption chance to higher priority
       interrupts.*/
    chSysUnlockFromISR();

    /* The callback is invoked outside the kernel critical zone.*/
    fn(vtp->vt_par);
 8000306:	6918      	ldr	r0, [r3, #16]
 8000308:	4790      	blx	r2
 800030a:	f385 8811 	msr	BASEPRI, r5
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 800030e:	6a62      	ldr	r2, [r4, #36]	; 0x24

  /* All timers within the time window are triggered and removed,
     note that the loop is stopped by the timers header having
     "ch.vtlist.vt_delta == (systime_t)-1" which is greater than
     all deltas.*/
  while (vtp->vt_delta <= (systime_t)(now - ch.vtlist.vt_lasttime)) {
 8000310:	f8b6 e026 	ldrh.w	lr, [r6, #38]	; 0x26
       of the list.*/
    chSysLockFromISR();

    /* Next element in the list, the current time could have advanced so
       recalculating the time window.*/
    vtp = ch.vtlist.vt_next;
 8000314:	69f3      	ldr	r3, [r6, #28]
 8000316:	b290      	uxth	r0, r2

  /* All timers within the time window are triggered and removed,
     note that the loop is stopped by the timers header having
     "ch.vtlist.vt_delta == (systime_t)-1" which is greater than
     all deltas.*/
  while (vtp->vt_delta <= (systime_t)(now - ch.vtlist.vt_lasttime)) {
 8000318:	ebce 0100 	rsb	r1, lr, r0
 800031c:	891a      	ldrh	r2, [r3, #8]
 800031e:	b289      	uxth	r1, r1
 8000320:	428a      	cmp	r2, r1
 8000322:	d9e3      	bls.n	80002ec <VectorB0+0x3c>
    vtp = ch.vtlist.vt_next;
    now = chVTGetSystemTimeX();
  }

  /* if the list is empty, nothing else to do.*/
  if (ch.vtlist.vt_next == (virtual_timer_t *)&ch.vtlist) {
 8000324:	4543      	cmp	r3, r8
 8000326:	d00a      	beq.n	800033e <VectorB0+0x8e>
    return;
  }

  /* Recalculating the next alarm time.*/
  delta = ch.vtlist.vt_lasttime + vtp->vt_delta - now;
 8000328:	4472      	add	r2, lr
 800032a:	1a12      	subs	r2, r2, r0
 800032c:	b292      	uxth	r2, r2
  if (delta < (systime_t)CH_CFG_ST_TIMEDELTA) {
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
 800032e:	2a01      	cmp	r2, #1
 8000330:	bf98      	it	ls
 8000332:	2202      	movls	r2, #2
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8000334:	4402      	add	r2, r0
 8000336:	b292      	uxth	r2, r2
 8000338:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800033c:	635a      	str	r2, [r3, #52]	; 0x34
 800033e:	2300      	movs	r3, #0
 8000340:	f383 8811 	msr	BASEPRI, r3
    osalOsTimerHandlerI();
    osalSysUnlockFromISR();
  }

  OSAL_IRQ_EPILOGUE();
}
 8000344:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    osalSysLockFromISR();
    osalOsTimerHandlerI();
    osalSysUnlockFromISR();
  }

  OSAL_IRQ_EPILOGUE();
 8000348:	f7ff bf82 	b.w	8000250 <_port_irq_epilogue>
 800034c:	20000c18 	.word	0x20000c18

08000350 <Vector84>:
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH7_HANDLER) {

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM7);
 8000350:	4b09      	ldr	r3, [pc, #36]	; (8000378 <Vector84+0x28>)
 8000352:	6819      	ldr	r1, [r3, #0]
 8000354:	f3c1 6103 	ubfx	r1, r1, #24, #4
 8000358:	b159      	cbz	r1, 8000372 <Vector84+0x22>
 800035a:	4808      	ldr	r0, [pc, #32]	; (800037c <Vector84+0x2c>)
/**
 * @brief   DMA1 stream 7 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH7_HANDLER) {
 800035c:	b510      	push	{r4, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM7);
 800035e:	6b04      	ldr	r4, [r0, #48]	; 0x30
 8000360:	060a      	lsls	r2, r1, #24
 8000362:	605a      	str	r2, [r3, #4]
 8000364:	b10c      	cbz	r4, 800036a <Vector84+0x1a>
 8000366:	6b40      	ldr	r0, [r0, #52]	; 0x34
 8000368:	47a0      	blx	r4

  OSAL_IRQ_EPILOGUE();
}
 800036a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM7);

  OSAL_IRQ_EPILOGUE();
 800036e:	f7ff bf6f 	b.w	8000250 <_port_irq_epilogue>
 8000372:	f7ff bf6d 	b.w	8000250 <_port_irq_epilogue>
 8000376:	bf00      	nop
 8000378:	40026000 	.word	0x40026000
 800037c:	20000870 	.word	0x20000870

08000380 <Vector80>:
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH6_HANDLER) {

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM6);
 8000380:	4b09      	ldr	r3, [pc, #36]	; (80003a8 <Vector80+0x28>)
 8000382:	6819      	ldr	r1, [r3, #0]
 8000384:	f3c1 5103 	ubfx	r1, r1, #20, #4
 8000388:	b159      	cbz	r1, 80003a2 <Vector80+0x22>
 800038a:	4808      	ldr	r0, [pc, #32]	; (80003ac <Vector80+0x2c>)
/**
 * @brief   DMA1 stream 6 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH6_HANDLER) {
 800038c:	b510      	push	{r4, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM6);
 800038e:	6a84      	ldr	r4, [r0, #40]	; 0x28
 8000390:	050a      	lsls	r2, r1, #20
 8000392:	605a      	str	r2, [r3, #4]
 8000394:	b10c      	cbz	r4, 800039a <Vector80+0x1a>
 8000396:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
 8000398:	47a0      	blx	r4

  OSAL_IRQ_EPILOGUE();
}
 800039a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM6);

  OSAL_IRQ_EPILOGUE();
 800039e:	f7ff bf57 	b.w	8000250 <_port_irq_epilogue>
 80003a2:	f7ff bf55 	b.w	8000250 <_port_irq_epilogue>
 80003a6:	bf00      	nop
 80003a8:	40026000 	.word	0x40026000
 80003ac:	20000870 	.word	0x20000870

080003b0 <Vector7C>:
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH5_HANDLER) {

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM5);
 80003b0:	4b09      	ldr	r3, [pc, #36]	; (80003d8 <Vector7C+0x28>)
 80003b2:	6819      	ldr	r1, [r3, #0]
 80003b4:	f3c1 4103 	ubfx	r1, r1, #16, #4
 80003b8:	b159      	cbz	r1, 80003d2 <Vector7C+0x22>
 80003ba:	4808      	ldr	r0, [pc, #32]	; (80003dc <Vector7C+0x2c>)
/**
 * @brief   DMA1 stream 5 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH5_HANDLER) {
 80003bc:	b510      	push	{r4, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM5);
 80003be:	6a04      	ldr	r4, [r0, #32]
 80003c0:	040a      	lsls	r2, r1, #16
 80003c2:	605a      	str	r2, [r3, #4]
 80003c4:	b10c      	cbz	r4, 80003ca <Vector7C+0x1a>
 80003c6:	6a40      	ldr	r0, [r0, #36]	; 0x24
 80003c8:	47a0      	blx	r4

  OSAL_IRQ_EPILOGUE();
}
 80003ca:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM5);

  OSAL_IRQ_EPILOGUE();
 80003ce:	f7ff bf3f 	b.w	8000250 <_port_irq_epilogue>
 80003d2:	f7ff bf3d 	b.w	8000250 <_port_irq_epilogue>
 80003d6:	bf00      	nop
 80003d8:	40026000 	.word	0x40026000
 80003dc:	20000870 	.word	0x20000870

080003e0 <Vector78>:
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH4_HANDLER) {

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM4);
 80003e0:	4b09      	ldr	r3, [pc, #36]	; (8000408 <Vector78+0x28>)
 80003e2:	6819      	ldr	r1, [r3, #0]
 80003e4:	f3c1 3103 	ubfx	r1, r1, #12, #4
 80003e8:	b159      	cbz	r1, 8000402 <Vector78+0x22>
 80003ea:	4808      	ldr	r0, [pc, #32]	; (800040c <Vector78+0x2c>)
/**
 * @brief   DMA1 stream 4 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH4_HANDLER) {
 80003ec:	b510      	push	{r4, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM4);
 80003ee:	6984      	ldr	r4, [r0, #24]
 80003f0:	030a      	lsls	r2, r1, #12
 80003f2:	605a      	str	r2, [r3, #4]
 80003f4:	b10c      	cbz	r4, 80003fa <Vector78+0x1a>
 80003f6:	69c0      	ldr	r0, [r0, #28]
 80003f8:	47a0      	blx	r4

  OSAL_IRQ_EPILOGUE();
}
 80003fa:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM4);

  OSAL_IRQ_EPILOGUE();
 80003fe:	f7ff bf27 	b.w	8000250 <_port_irq_epilogue>
 8000402:	f7ff bf25 	b.w	8000250 <_port_irq_epilogue>
 8000406:	bf00      	nop
 8000408:	40026000 	.word	0x40026000
 800040c:	20000870 	.word	0x20000870

08000410 <Vector74>:
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH3_HANDLER) {

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM3);
 8000410:	4b09      	ldr	r3, [pc, #36]	; (8000438 <Vector74+0x28>)
 8000412:	6819      	ldr	r1, [r3, #0]
 8000414:	f3c1 2103 	ubfx	r1, r1, #8, #4
 8000418:	b159      	cbz	r1, 8000432 <Vector74+0x22>
 800041a:	4808      	ldr	r0, [pc, #32]	; (800043c <Vector74+0x2c>)
/**
 * @brief   DMA1 stream 3 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH3_HANDLER) {
 800041c:	b510      	push	{r4, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM3);
 800041e:	6904      	ldr	r4, [r0, #16]
 8000420:	020a      	lsls	r2, r1, #8
 8000422:	605a      	str	r2, [r3, #4]
 8000424:	b10c      	cbz	r4, 800042a <Vector74+0x1a>
 8000426:	6940      	ldr	r0, [r0, #20]
 8000428:	47a0      	blx	r4

  OSAL_IRQ_EPILOGUE();
}
 800042a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM3);

  OSAL_IRQ_EPILOGUE();
 800042e:	f7ff bf0f 	b.w	8000250 <_port_irq_epilogue>
 8000432:	f7ff bf0d 	b.w	8000250 <_port_irq_epilogue>
 8000436:	bf00      	nop
 8000438:	40026000 	.word	0x40026000
 800043c:	20000870 	.word	0x20000870

08000440 <Vector70>:
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH2_HANDLER) {

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM2);
 8000440:	4b09      	ldr	r3, [pc, #36]	; (8000468 <Vector70+0x28>)
 8000442:	6819      	ldr	r1, [r3, #0]
 8000444:	f3c1 1103 	ubfx	r1, r1, #4, #4
 8000448:	b159      	cbz	r1, 8000462 <Vector70+0x22>
 800044a:	4808      	ldr	r0, [pc, #32]	; (800046c <Vector70+0x2c>)
/**
 * @brief   DMA1 stream 2 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH2_HANDLER) {
 800044c:	b510      	push	{r4, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM2);
 800044e:	6884      	ldr	r4, [r0, #8]
 8000450:	010a      	lsls	r2, r1, #4
 8000452:	605a      	str	r2, [r3, #4]
 8000454:	b10c      	cbz	r4, 800045a <Vector70+0x1a>
 8000456:	68c0      	ldr	r0, [r0, #12]
 8000458:	47a0      	blx	r4

  OSAL_IRQ_EPILOGUE();
}
 800045a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM2);

  OSAL_IRQ_EPILOGUE();
 800045e:	f7ff bef7 	b.w	8000250 <_port_irq_epilogue>
 8000462:	f7ff bef5 	b.w	8000250 <_port_irq_epilogue>
 8000466:	bf00      	nop
 8000468:	40026000 	.word	0x40026000
 800046c:	20000870 	.word	0x20000870

08000470 <Vector6C>:
/**
 * @brief   DMA1 stream 1 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH1_HANDLER) {
 8000470:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM1);
 8000472:	4b07      	ldr	r3, [pc, #28]	; (8000490 <Vector6C+0x20>)
 8000474:	6819      	ldr	r1, [r3, #0]
 8000476:	f011 010f 	ands.w	r1, r1, #15
 800047a:	d005      	beq.n	8000488 <Vector6C+0x18>
 800047c:	4a05      	ldr	r2, [pc, #20]	; (8000494 <Vector6C+0x24>)
 800047e:	6059      	str	r1, [r3, #4]
 8000480:	6813      	ldr	r3, [r2, #0]
 8000482:	b10b      	cbz	r3, 8000488 <Vector6C+0x18>
 8000484:	6850      	ldr	r0, [r2, #4]
 8000486:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
}
 8000488:	e8bd 4008 	ldmia.w	sp!, {r3, lr}

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM1);

  OSAL_IRQ_EPILOGUE();
 800048c:	f7ff bee0 	b.w	8000250 <_port_irq_epilogue>
 8000490:	40026000 	.word	0x40026000
 8000494:	20000870 	.word	0x20000870
	...

080004a0 <SVC_Handler>:
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 80004a0:	f3ef 8309 	mrs	r3, PSP

    \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 80004a4:	3320      	adds	r3, #32
 80004a6:	f383 8809 	msr	PSP, r3

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 80004aa:	2300      	movs	r3, #0
 80004ac:	f383 8811 	msr	BASEPRI, r3
 80004b0:	4770      	bx	lr
 80004b2:	bf00      	nop
	...

080004c0 <chCoreAlloc>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @api
 */
void *chCoreAlloc(size_t size) {
 80004c0:	b410      	push	{r4}
 80004c2:	2320      	movs	r3, #32
 80004c4:	f383 8811 	msr	BASEPRI, r3

  chDbgCheckClassI();

  size = MEM_ALIGN_NEXT(size);
  /*lint -save -e9033 [10.8] The cast is safe.*/
  if ((size_t)(endmem - nextmem) < size) {
 80004c8:	4c09      	ldr	r4, [pc, #36]	; (80004f0 <chCoreAlloc+0x30>)
 80004ca:	4b0a      	ldr	r3, [pc, #40]	; (80004f4 <chCoreAlloc+0x34>)
 80004cc:	6822      	ldr	r2, [r4, #0]
 80004ce:	6819      	ldr	r1, [r3, #0]
void *chCoreAllocI(size_t size) {
  void *p;

  chDbgCheckClassI();

  size = MEM_ALIGN_NEXT(size);
 80004d0:	1dc3      	adds	r3, r0, #7
 80004d2:	f023 0307 	bic.w	r3, r3, #7
  /*lint -save -e9033 [10.8] The cast is safe.*/
  if ((size_t)(endmem - nextmem) < size) {
 80004d6:	1a89      	subs	r1, r1, r2
 80004d8:	428b      	cmp	r3, r1
  /*lint -restore*/
    return NULL;
  }
  p = nextmem;
  nextmem += size;
 80004da:	bf9d      	ittte	ls
 80004dc:	189b      	addls	r3, r3, r2
 80004de:	6023      	strls	r3, [r4, #0]

  return p;
 80004e0:	4610      	movls	r0, r2

  size = MEM_ALIGN_NEXT(size);
  /*lint -save -e9033 [10.8] The cast is safe.*/
  if ((size_t)(endmem - nextmem) < size) {
  /*lint -restore*/
    return NULL;
 80004e2:	2000      	movhi	r0, #0
 80004e4:	2300      	movs	r3, #0
 80004e6:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  p = chCoreAllocI(size);
  chSysUnlock();

  return p;
}
 80004ea:	bc10      	pop	{r4}
 80004ec:	4770      	bx	lr
 80004ee:	bf00      	nop
 80004f0:	2000086c 	.word	0x2000086c
 80004f4:	20000818 	.word	0x20000818
	...

08000500 <wakeup>:
}

/*
 * Timeout wakeup callback.
 */
static void wakeup(void *p) {
 8000500:	b410      	push	{r4}
 8000502:	2320      	movs	r3, #32
 8000504:	f383 8811 	msr	BASEPRI, r3
  thread_t *tp = (thread_t *)p;

  chSysLockFromISR();
  switch (tp->p_state) {
 8000508:	7f03      	ldrb	r3, [r0, #28]
 800050a:	2b07      	cmp	r3, #7
 800050c:	d80e      	bhi.n	800052c <wakeup+0x2c>
 800050e:	e8df f003 	tbb	[pc, r3]
 8000512:	0d26      	.short	0x0d26
 8000514:	0408220d 	.word	0x0408220d
 8000518:	080d      	.short	0x080d
  case CH_STATE_SUSPENDED:
    *tp->p_u.wttrp = NULL;
    break;
#if CH_CFG_USE_SEMAPHORES == TRUE
  case CH_STATE_WTSEM:
    chSemFastSignalI(tp->p_u.wtsemp);
 800051a:	6a02      	ldr	r2, [r0, #32]
 */
static inline void chSemFastSignalI(semaphore_t *sp) {

  chDbgCheckClassI();

  sp->s_cnt++;
 800051c:	6893      	ldr	r3, [r2, #8]
 800051e:	3301      	adds	r3, #1
 8000520:	6093      	str	r3, [r2, #8]
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->p_prev->p_next = tp->p_next;
 8000522:	e890 000c 	ldmia.w	r0, {r2, r3}
 8000526:	601a      	str	r2, [r3, #0]
  tp->p_next->p_prev = tp->p_prev;
 8000528:	6802      	ldr	r2, [r0, #0]
 800052a:	6053      	str	r3, [r2, #4]
    break;
  default:
    /* Any other state, nothing to do.*/
    break;
  }
  tp->p_u.rdymsg = MSG_TIMEOUT;
 800052c:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 8000530:	2200      	movs	r2, #0
 8000532:	6881      	ldr	r1, [r0, #8]
  cp = (thread_t *)&ch.rlist.r_queue;
 8000534:	4b0c      	ldr	r3, [pc, #48]	; (8000568 <wakeup+0x68>)
    break;
  default:
    /* Any other state, nothing to do.*/
    break;
  }
  tp->p_u.rdymsg = MSG_TIMEOUT;
 8000536:	6204      	str	r4, [r0, #32]
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 8000538:	7702      	strb	r2, [r0, #28]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
 800053a:	681b      	ldr	r3, [r3, #0]
  } while (cp->p_prio >= tp->p_prio);
 800053c:	689a      	ldr	r2, [r3, #8]
 800053e:	428a      	cmp	r2, r1
 8000540:	d2fb      	bcs.n	800053a <wakeup+0x3a>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 8000542:	685a      	ldr	r2, [r3, #4]
 8000544:	2100      	movs	r1, #0
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
 8000546:	6003      	str	r3, [r0, #0]
  tp->p_prev = cp->p_prev;
 8000548:	6042      	str	r2, [r0, #4]
  tp->p_prev->p_next = tp;
 800054a:	6010      	str	r0, [r2, #0]
  cp->p_prev = tp;
 800054c:	6058      	str	r0, [r3, #4]
 800054e:	f381 8811 	msr	BASEPRI, r1
    break;
  }
  tp->p_u.rdymsg = MSG_TIMEOUT;
  (void) chSchReadyI(tp);
  chSysUnlockFromISR();
}
 8000552:	bc10      	pop	{r4}
 8000554:	4770      	bx	lr
    /* Handling the special case where the thread has been made ready by
       another thread with higher priority.*/
    chSysUnlockFromISR();
    return;
  case CH_STATE_SUSPENDED:
    *tp->p_u.wttrp = NULL;
 8000556:	6a03      	ldr	r3, [r0, #32]
 8000558:	2200      	movs	r2, #0
 800055a:	601a      	str	r2, [r3, #0]
 800055c:	e7e6      	b.n	800052c <wakeup+0x2c>
 800055e:	2300      	movs	r3, #0
 8000560:	f383 8811 	msr	BASEPRI, r3
    break;
  }
  tp->p_u.rdymsg = MSG_TIMEOUT;
  (void) chSchReadyI(tp);
  chSysUnlockFromISR();
}
 8000564:	bc10      	pop	{r4}
 8000566:	4770      	bx	lr
 8000568:	20000c18 	.word	0x20000c18
 800056c:	00000000 	.word	0x00000000

08000570 <_idle_thread.lto_priv.35>:
 *          that this thread is executed only if there are no other ready
 *          threads in the system.
 *
 * @param[in] p         the thread parameter, unused in this scenario
 */
static void _idle_thread(void *p) {
 8000570:	e7fe      	b.n	8000570 <_idle_thread.lto_priv.35>
 8000572:	bf00      	nop
	...

08000580 <BusFault_Handler>:
 *          This function simply stops the system into an infinite loop.
 *
 * @notapi
 */
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void _unhandled_exception(void) {
 8000580:	e7fe      	b.n	8000580 <BusFault_Handler>
 8000582:	bf00      	nop
	...

08000590 <test_println>:
/**
 * @brief   Prints a line.
 *
 * @param[in] msgp      the message
 */
void test_println(const char *msgp) {
 8000590:	b570      	push	{r4, r5, r6, lr}
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 8000592:	7801      	ldrb	r1, [r0, #0]
 8000594:	b189      	cbz	r1, 80005ba <test_println+0x2a>
 8000596:	4604      	mov	r4, r0
 8000598:	4d09      	ldr	r5, [pc, #36]	; (80005c0 <test_println+0x30>)
    chSequentialStreamPut(chp, *msgp++);
 800059a:	6828      	ldr	r0, [r5, #0]
 800059c:	6803      	ldr	r3, [r0, #0]
 800059e:	689b      	ldr	r3, [r3, #8]
 80005a0:	4798      	blx	r3
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 80005a2:	f814 1f01 	ldrb.w	r1, [r4, #1]!
 80005a6:	2900      	cmp	r1, #0
 80005a8:	d1f7      	bne.n	800059a <test_println+0xa>
 * @param[in] msgp      the message
 */
void test_println(const char *msgp) {

  test_print(msgp);
  chSequentialStreamWrite(chp, (const uint8_t *)"\r\n", 2);
 80005aa:	6828      	ldr	r0, [r5, #0]
 80005ac:	2202      	movs	r2, #2
 80005ae:	6803      	ldr	r3, [r0, #0]
 80005b0:	4904      	ldr	r1, [pc, #16]	; (80005c4 <test_println+0x34>)
 80005b2:	681b      	ldr	r3, [r3, #0]
}
 80005b4:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 * @param[in] msgp      the message
 */
void test_println(const char *msgp) {

  test_print(msgp);
  chSequentialStreamWrite(chp, (const uint8_t *)"\r\n", 2);
 80005b8:	4718      	bx	r3
 80005ba:	4d01      	ldr	r5, [pc, #4]	; (80005c0 <test_println+0x30>)
 80005bc:	e7f5      	b.n	80005aa <test_println+0x1a>
 80005be:	bf00      	nop
 80005c0:	20000864 	.word	0x20000864
 80005c4:	08001e10 	.word	0x08001e10
	...

080005d0 <test_printn>:
 * @param[in] n         the number to be printed
 */
void test_printn(uint32_t n) {
  char buf[16], *p;

  if (!n)
 80005d0:	b310      	cbz	r0, 8000618 <test_printn+0x48>
/**
 * @brief   Prints a decimal unsigned number.
 *
 * @param[in] n         the number to be printed
 */
void test_printn(uint32_t n) {
 80005d2:	b570      	push	{r4, r5, r6, lr}
 80005d4:	b084      	sub	sp, #16
  char buf[16], *p;

  if (!n)
 80005d6:	466d      	mov	r5, sp
 80005d8:	466c      	mov	r4, sp
    chSequentialStreamPut(chp, '0');
  else {
    p = buf;
    while (n)
      *p++ = (n % 10) + '0', n /= 10;
 80005da:	4a12      	ldr	r2, [pc, #72]	; (8000624 <test_printn+0x54>)
 80005dc:	fba2 1300 	umull	r1, r3, r2, r0
 80005e0:	08db      	lsrs	r3, r3, #3
 80005e2:	eb03 0183 	add.w	r1, r3, r3, lsl #2
 80005e6:	eba0 0041 	sub.w	r0, r0, r1, lsl #1
 80005ea:	f100 0130 	add.w	r1, r0, #48	; 0x30
 80005ee:	b2c9      	uxtb	r1, r1
 80005f0:	f804 1b01 	strb.w	r1, [r4], #1

  if (!n)
    chSequentialStreamPut(chp, '0');
  else {
    p = buf;
    while (n)
 80005f4:	4618      	mov	r0, r3
 80005f6:	2b00      	cmp	r3, #0
 80005f8:	d1f0      	bne.n	80005dc <test_printn+0xc>
      *p++ = (n % 10) + '0', n /= 10;
    while (p > buf)
 80005fa:	42ac      	cmp	r4, r5
 80005fc:	d90a      	bls.n	8000614 <test_printn+0x44>
 80005fe:	4e0a      	ldr	r6, [pc, #40]	; (8000628 <test_printn+0x58>)
 8000600:	3c01      	subs	r4, #1
 8000602:	e001      	b.n	8000608 <test_printn+0x38>
 8000604:	f814 1d01 	ldrb.w	r1, [r4, #-1]!
      chSequentialStreamPut(chp, *--p);
 8000608:	6830      	ldr	r0, [r6, #0]
 800060a:	6803      	ldr	r3, [r0, #0]
 800060c:	689b      	ldr	r3, [r3, #8]
 800060e:	4798      	blx	r3
    chSequentialStreamPut(chp, '0');
  else {
    p = buf;
    while (n)
      *p++ = (n % 10) + '0', n /= 10;
    while (p > buf)
 8000610:	42ac      	cmp	r4, r5
 8000612:	d1f7      	bne.n	8000604 <test_printn+0x34>
      chSequentialStreamPut(chp, *--p);
  }
}
 8000614:	b004      	add	sp, #16
 8000616:	bd70      	pop	{r4, r5, r6, pc}
 */
void test_printn(uint32_t n) {
  char buf[16], *p;

  if (!n)
    chSequentialStreamPut(chp, '0');
 8000618:	4b03      	ldr	r3, [pc, #12]	; (8000628 <test_printn+0x58>)
 800061a:	2130      	movs	r1, #48	; 0x30
 800061c:	6818      	ldr	r0, [r3, #0]
 800061e:	6803      	ldr	r3, [r0, #0]
 8000620:	689b      	ldr	r3, [r3, #8]
 8000622:	4718      	bx	r3
 8000624:	cccccccd 	.word	0xcccccccd
 8000628:	20000864 	.word	0x20000864
 800062c:	00000000 	.word	0x00000000

08000630 <__early_init>:
 */
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* PWR clock enable.*/
  RCC->APB1ENR = RCC_APB1ENR_PWREN;
 8000630:	4b3b      	ldr	r3, [pc, #236]	; (8000720 <__early_init+0xf0>)
 8000632:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000

  /* Core voltage setup.*/
  while ((PWR->CSR & PWR_CSR_VOSF) != 0)
 8000636:	493b      	ldr	r1, [pc, #236]	; (8000724 <__early_init+0xf4>)
 */
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* PWR clock enable.*/
  RCC->APB1ENR = RCC_APB1ENR_PWREN;
 8000638:	625a      	str	r2, [r3, #36]	; 0x24

  /* Core voltage setup.*/
  while ((PWR->CSR & PWR_CSR_VOSF) != 0)
 800063a:	684b      	ldr	r3, [r1, #4]
 800063c:	4a39      	ldr	r2, [pc, #228]	; (8000724 <__early_init+0xf4>)
 800063e:	06db      	lsls	r3, r3, #27
 8000640:	d4fb      	bmi.n	800063a <__early_init+0xa>
    ;                           /* Waits until regulator is stable.         */
  PWR->CR = STM32_VOS;
  while ((PWR->CSR & PWR_CSR_VOSF) != 0)
 8000642:	4611      	mov	r1, r2
  RCC->APB1ENR = RCC_APB1ENR_PWREN;

  /* Core voltage setup.*/
  while ((PWR->CSR & PWR_CSR_VOSF) != 0)
    ;                           /* Waits until regulator is stable.         */
  PWR->CR = STM32_VOS;
 8000644:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8000648:	6013      	str	r3, [r2, #0]
  while ((PWR->CSR & PWR_CSR_VOSF) != 0)
 800064a:	684b      	ldr	r3, [r1, #4]
 800064c:	f013 0310 	ands.w	r3, r3, #16
 8000650:	d1fb      	bne.n	800064a <__early_init+0x1a>
    ;                           /* Waits until regulator is stable.         */

  /* Initial clocks setup and wait for MSI stabilization, the MSI clock is
     always enabled because it is the fallback clock when PLL the fails.
     Trim fields are not altered from reset values.*/
  RCC->CFGR  = 0;
 8000652:	4a33      	ldr	r2, [pc, #204]	; (8000720 <__early_init+0xf0>)
  RCC->ICSCR = (RCC->ICSCR & ~STM32_MSIRANGE_MASK) | STM32_MSIRANGE;
  RCC->CR    = RCC_CR_MSION;
 8000654:	f44f 7080 	mov.w	r0, #256	; 0x100
  while ((RCC->CR & RCC_CR_MSIRDY) == 0)
 8000658:	4611      	mov	r1, r2
    ;                           /* Waits until regulator is stable.         */

  /* Initial clocks setup and wait for MSI stabilization, the MSI clock is
     always enabled because it is the fallback clock when PLL the fails.
     Trim fields are not altered from reset values.*/
  RCC->CFGR  = 0;
 800065a:	6093      	str	r3, [r2, #8]
  RCC->ICSCR = (RCC->ICSCR & ~STM32_MSIRANGE_MASK) | STM32_MSIRANGE;
 800065c:	6853      	ldr	r3, [r2, #4]
 800065e:	f423 4360 	bic.w	r3, r3, #57344	; 0xe000
 8000662:	f443 4320 	orr.w	r3, r3, #40960	; 0xa000
 8000666:	6053      	str	r3, [r2, #4]
  RCC->CR    = RCC_CR_MSION;
 8000668:	6010      	str	r0, [r2, #0]
  while ((RCC->CR & RCC_CR_MSIRDY) == 0)
 800066a:	680b      	ldr	r3, [r1, #0]
 800066c:	4a2c      	ldr	r2, [pc, #176]	; (8000720 <__early_init+0xf0>)
 800066e:	0598      	lsls	r0, r3, #22
 8000670:	d5fb      	bpl.n	800066a <__early_init+0x3a>
    ;                           /* Waits until MSI is stable.               */

#if STM32_HSI_ENABLED
  /* HSI activation.*/
  RCC->CR |= RCC_CR_HSION;
  while ((RCC->CR & RCC_CR_HSIRDY) == 0)
 8000672:	4611      	mov	r1, r2
  while ((RCC->CR & RCC_CR_MSIRDY) == 0)
    ;                           /* Waits until MSI is stable.               */

#if STM32_HSI_ENABLED
  /* HSI activation.*/
  RCC->CR |= RCC_CR_HSION;
 8000674:	6813      	ldr	r3, [r2, #0]
 8000676:	f043 0301 	orr.w	r3, r3, #1
 800067a:	6013      	str	r3, [r2, #0]
  while ((RCC->CR & RCC_CR_HSIRDY) == 0)
 800067c:	680b      	ldr	r3, [r1, #0]
 800067e:	4a28      	ldr	r2, [pc, #160]	; (8000720 <__early_init+0xf0>)
 8000680:	079b      	lsls	r3, r3, #30
 8000682:	d5fb      	bpl.n	800067c <__early_init+0x4c>
#endif

#if STM32_LSI_ENABLED
  /* LSI activation.*/
  RCC->CSR |= RCC_CSR_LSION;
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
 8000684:	4611      	mov	r1, r2
    ;                           /* Waits until HSE is stable.               */
#endif

#if STM32_LSI_ENABLED
  /* LSI activation.*/
  RCC->CSR |= RCC_CSR_LSION;
 8000686:	6b53      	ldr	r3, [r2, #52]	; 0x34
 8000688:	f043 0301 	orr.w	r3, r3, #1
 800068c:	6353      	str	r3, [r2, #52]	; 0x34
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
 800068e:	6b4b      	ldr	r3, [r1, #52]	; 0x34
 8000690:	4a23      	ldr	r2, [pc, #140]	; (8000720 <__early_init+0xf0>)
 8000692:	0798      	lsls	r0, r3, #30
 8000694:	d5fb      	bpl.n	800068e <__early_init+0x5e>
    ;                           /* Waits until LSI is stable.               */
#endif

#if STM32_LSE_ENABLED
  /* LSE activation, have to unlock the register.*/
  if ((RCC->CSR & RCC_CSR_LSEON) == 0) {
 8000696:	6b53      	ldr	r3, [r2, #52]	; 0x34
 8000698:	05db      	lsls	r3, r3, #23
 800069a:	d40c      	bmi.n	80006b6 <__early_init+0x86>
    PWR->CR |= PWR_CR_DBP;
 800069c:	4b21      	ldr	r3, [pc, #132]	; (8000724 <__early_init+0xf4>)
 800069e:	6819      	ldr	r1, [r3, #0]
 80006a0:	f441 7180 	orr.w	r1, r1, #256	; 0x100
 80006a4:	6019      	str	r1, [r3, #0]
    RCC->CSR |= RCC_CSR_LSEON;
 80006a6:	6b51      	ldr	r1, [r2, #52]	; 0x34
 80006a8:	f441 7180 	orr.w	r1, r1, #256	; 0x100
 80006ac:	6351      	str	r1, [r2, #52]	; 0x34
    PWR->CR &= ~PWR_CR_DBP;
 80006ae:	681a      	ldr	r2, [r3, #0]
 80006b0:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 80006b4:	601a      	str	r2, [r3, #0]
  }
  while ((RCC->CSR & RCC_CSR_LSERDY) == 0)
 80006b6:	491a      	ldr	r1, [pc, #104]	; (8000720 <__early_init+0xf0>)
 80006b8:	6b4b      	ldr	r3, [r1, #52]	; 0x34
 80006ba:	4a19      	ldr	r2, [pc, #100]	; (8000720 <__early_init+0xf0>)
 80006bc:	0598      	lsls	r0, r3, #22
 80006be:	d5fb      	bpl.n	80006b8 <__early_init+0x88>

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->CFGR |= STM32_PLLDIV | STM32_PLLMUL | STM32_PLLSRC;
  RCC->CR   |= RCC_CR_PLLON;
  while (!(RCC->CR & RCC_CR_PLLRDY))
 80006c0:	4611      	mov	r1, r2
    ;                           /* Waits until LSE is stable.               */
#endif

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->CFGR |= STM32_PLLDIV | STM32_PLLMUL | STM32_PLLSRC;
 80006c2:	6893      	ldr	r3, [r2, #8]
 80006c4:	f443 0308 	orr.w	r3, r3, #8912896	; 0x880000
 80006c8:	6093      	str	r3, [r2, #8]
  RCC->CR   |= RCC_CR_PLLON;
 80006ca:	6813      	ldr	r3, [r2, #0]
 80006cc:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 80006d0:	6013      	str	r3, [r2, #0]
  while (!(RCC->CR & RCC_CR_PLLRDY))
 80006d2:	680b      	ldr	r3, [r1, #0]
 80006d4:	4a12      	ldr	r2, [pc, #72]	; (8000720 <__early_init+0xf0>)
 80006d6:	019b      	lsls	r3, r3, #6
 80006d8:	d5fb      	bpl.n	80006d2 <__early_init+0xa2>
#endif

  /* Switching to the configured clock source if it is different from MSI.*/
#if (STM32_SW != STM32_SW_MSI)
  RCC->CFGR |= STM32_SW;        /* Switches on the selected clock source.   */
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 80006da:	4611      	mov	r1, r2
  while (!(RCC->CR & RCC_CR_PLLRDY))
    ;                           /* Waits until PLL is stable.               */
#endif

  /* Other clock-related settings (dividers, MCO etc).*/
  RCC->CR   |= STM32_RTCPRE;
 80006dc:	6813      	ldr	r3, [r2, #0]
/**
 * @brief   Early initialization code.
 * @details This initialization must be performed just after stack setup
 *          and before any other initialization.
 */
void __early_init(void) {
 80006de:	b430      	push	{r4, r5}
 80006e0:	6013      	str	r3, [r2, #0]
  RCC->CFGR |= STM32_MCOPRE | STM32_MCOSEL |
 80006e2:	6893      	ldr	r3, [r2, #8]
               STM32_PPRE2 | STM32_PPRE1 | STM32_HPRE;
  RCC->CSR  |= STM32_RTCSEL;

  /* Flash setup and final clock selection.*/
#if defined(STM32_FLASHBITS1)
  FLASH->ACR = STM32_FLASHBITS1;
 80006e4:	4810      	ldr	r0, [pc, #64]	; (8000728 <__early_init+0xf8>)
    ;                           /* Waits until PLL is stable.               */
#endif

  /* Other clock-related settings (dividers, MCO etc).*/
  RCC->CR   |= STM32_RTCPRE;
  RCC->CFGR |= STM32_MCOPRE | STM32_MCOSEL |
 80006e6:	6093      	str	r3, [r2, #8]
               STM32_PPRE2 | STM32_PPRE1 | STM32_HPRE;
  RCC->CSR  |= STM32_RTCSEL;
 80006e8:	6b53      	ldr	r3, [r2, #52]	; 0x34

  /* Flash setup and final clock selection.*/
#if defined(STM32_FLASHBITS1)
  FLASH->ACR = STM32_FLASHBITS1;
 80006ea:	2504      	movs	r5, #4

  /* Other clock-related settings (dividers, MCO etc).*/
  RCC->CR   |= STM32_RTCPRE;
  RCC->CFGR |= STM32_MCOPRE | STM32_MCOSEL |
               STM32_PPRE2 | STM32_PPRE1 | STM32_HPRE;
  RCC->CSR  |= STM32_RTCSEL;
 80006ec:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
  /* Flash setup and final clock selection.*/
#if defined(STM32_FLASHBITS1)
  FLASH->ACR = STM32_FLASHBITS1;
#endif
#if defined(STM32_FLASHBITS2)
  FLASH->ACR = STM32_FLASHBITS2;
 80006f0:	2407      	movs	r4, #7

  /* Other clock-related settings (dividers, MCO etc).*/
  RCC->CR   |= STM32_RTCPRE;
  RCC->CFGR |= STM32_MCOPRE | STM32_MCOSEL |
               STM32_PPRE2 | STM32_PPRE1 | STM32_HPRE;
  RCC->CSR  |= STM32_RTCSEL;
 80006f2:	6353      	str	r3, [r2, #52]	; 0x34

  /* Flash setup and final clock selection.*/
#if defined(STM32_FLASHBITS1)
  FLASH->ACR = STM32_FLASHBITS1;
 80006f4:	6005      	str	r5, [r0, #0]
#endif
#if defined(STM32_FLASHBITS2)
  FLASH->ACR = STM32_FLASHBITS2;
 80006f6:	6004      	str	r4, [r0, #0]
#endif

  /* Switching to the configured clock source if it is different from MSI.*/
#if (STM32_SW != STM32_SW_MSI)
  RCC->CFGR |= STM32_SW;        /* Switches on the selected clock source.   */
 80006f8:	6893      	ldr	r3, [r2, #8]
 80006fa:	f043 0303 	orr.w	r3, r3, #3
 80006fe:	6093      	str	r3, [r2, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 8000700:	688b      	ldr	r3, [r1, #8]
 8000702:	4a07      	ldr	r2, [pc, #28]	; (8000720 <__early_init+0xf0>)
 8000704:	f003 030c 	and.w	r3, r3, #12
 8000708:	2b0c      	cmp	r3, #12
 800070a:	d1f9      	bne.n	8000700 <__early_init+0xd0>
#endif
#endif /* STM32_NO_INIT */

  /* SYSCFG clock enabled here because it is a multi-functional unit shared
     among multiple drivers.*/
  rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, TRUE);
 800070c:	6a13      	ldr	r3, [r2, #32]

  stm32_clock_init();
}
 800070e:	bc30      	pop	{r4, r5}
 8000710:	f043 0301 	orr.w	r3, r3, #1
 8000714:	6213      	str	r3, [r2, #32]
 8000716:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
 8000718:	f043 0301 	orr.w	r3, r3, #1
 800071c:	62d3      	str	r3, [r2, #44]	; 0x2c
 800071e:	4770      	bx	lr
 8000720:	40023800 	.word	0x40023800
 8000724:	40007000 	.word	0x40007000
 8000728:	40023c00 	.word	0x40023c00
 800072c:	00000000 	.word	0x00000000

08000730 <chTMStopMeasurementX>:
 *
 * @return              The realtime counter value.
 */
static inline rtcnt_t port_rt_get_counter_value(void) {

  return DWT->CYCCNT;
 8000730:	4b0e      	ldr	r3, [pc, #56]	; (800076c <chTMStopMeasurementX+0x3c>)
 *
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
 8000732:	490f      	ldr	r1, [pc, #60]	; (8000770 <chTMStopMeasurementX+0x40>)
 8000734:	685a      	ldr	r2, [r3, #4]
static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = (now - tmp->last) - offset;
 8000736:	6883      	ldr	r3, [r0, #8]
 *
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
 8000738:	6f09      	ldr	r1, [r1, #112]	; 0x70
static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = (now - tmp->last) - offset;
 800073a:	1ad3      	subs	r3, r2, r3

static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
 800073c:	68c2      	ldr	r2, [r0, #12]
 *
 * @param[in,out] tmp   pointer to a @p time_measurement_t structure
 *
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {
 800073e:	b430      	push	{r4, r5}
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = (now - tmp->last) - offset;
  tmp->cumulative += (rttime_t)tmp->last;
 8000740:	e9d0 4504 	ldrd	r4, r5, [r0, #16]
static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = (now - tmp->last) - offset;
 8000744:	1a5b      	subs	r3, r3, r1

static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
 8000746:	3201      	adds	r2, #1
  tmp->last = (now - tmp->last) - offset;
  tmp->cumulative += (rttime_t)tmp->last;
  if (tmp->last > tmp->worst) {
 8000748:	6841      	ldr	r1, [r0, #4]
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = (now - tmp->last) - offset;
  tmp->cumulative += (rttime_t)tmp->last;
 800074a:	18e4      	adds	r4, r4, r3

static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
 800074c:	60c2      	str	r2, [r0, #12]
  tmp->last = (now - tmp->last) - offset;
  tmp->cumulative += (rttime_t)tmp->last;
  if (tmp->last > tmp->worst) {
    tmp->worst = tmp->last;
  }
  if (tmp->last < tmp->best) {
 800074e:	6802      	ldr	r2, [r0, #0]
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = (now - tmp->last) - offset;
  tmp->cumulative += (rttime_t)tmp->last;
 8000750:	f145 0500 	adc.w	r5, r5, #0
  if (tmp->last > tmp->worst) {
 8000754:	428b      	cmp	r3, r1
    tmp->worst = tmp->last;
 8000756:	bf88      	it	hi
 8000758:	6043      	strhi	r3, [r0, #4]
  }
  if (tmp->last < tmp->best) {
 800075a:	4293      	cmp	r3, r2
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = (now - tmp->last) - offset;
  tmp->cumulative += (rttime_t)tmp->last;
 800075c:	e9c0 4504 	strd	r4, r5, [r0, #16]
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
}
 8000760:	bc30      	pop	{r4, r5}
static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = (now - tmp->last) - offset;
 8000762:	6083      	str	r3, [r0, #8]
  tmp->cumulative += (rttime_t)tmp->last;
  if (tmp->last > tmp->worst) {
    tmp->worst = tmp->last;
  }
  if (tmp->last < tmp->best) {
    tmp->best = tmp->last;
 8000764:	bf38      	it	cc
 8000766:	6003      	strcc	r3, [r0, #0]
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
}
 8000768:	4770      	bx	lr
 800076a:	bf00      	nop
 800076c:	e0001000 	.word	0xe0001000
 8000770:	20000c18 	.word	0x20000c18
	...

08000780 <chSchDoRescheduleAhead>:
 * @special
 */
void chSchDoRescheduleAhead(void) {
  thread_t *otp, *cp;

  otp = currp;
 8000780:	4a0d      	ldr	r2, [pc, #52]	; (80007b8 <chSchDoRescheduleAhead+0x38>)
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoRescheduleAhead(void) {
 8000782:	b430      	push	{r4, r5}
  tp->p_prev->p_next = tp;
  tqp->p_prev = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;
 8000784:	6810      	ldr	r0, [r2, #0]
  thread_t *otp, *cp;

  otp = currp;
 8000786:	6994      	ldr	r4, [r2, #24]

  tqp->p_next = tp->p_next;
 8000788:	6803      	ldr	r3, [r0, #0]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
  if (otp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 800078a:	2101      	movs	r1, #1
  tqp->p_next->p_prev = (thread_t *)tqp;
 800078c:	605a      	str	r2, [r3, #4]

  otp->p_state = CH_STATE_READY;
 800078e:	2500      	movs	r5, #0
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
  if (otp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 8000790:	7701      	strb	r1, [r0, #28]
 8000792:	68a1      	ldr	r1, [r4, #8]
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 8000794:	6013      	str	r3, [r2, #0]
void chSchDoRescheduleAhead(void) {
  thread_t *otp, *cp;

  otp = currp;
  /* Picks the first thread from the ready queue and makes it current.*/
  setcurrp(queue_fifo_remove(&ch.rlist.r_queue));
 8000796:	6190      	str	r0, [r2, #24]
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;

  otp->p_state = CH_STATE_READY;
 8000798:	7725      	strb	r5, [r4, #28]
 800079a:	e000      	b.n	800079e <chSchDoRescheduleAhead+0x1e>
 800079c:	681b      	ldr	r3, [r3, #0]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio > otp->p_prio);
 800079e:	689a      	ldr	r2, [r3, #8]
 80007a0:	428a      	cmp	r2, r1
 80007a2:	d8fb      	bhi.n	800079c <chSchDoRescheduleAhead+0x1c>
  /* Insertion on p_prev.*/
  otp->p_next = cp;
  otp->p_prev = cp->p_prev;
 80007a4:	685a      	ldr	r2, [r3, #4]
  otp->p_prev->p_next = otp;
  cp->p_prev = otp;

  chSysSwitch(currp, otp);
 80007a6:	4621      	mov	r1, r4
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio > otp->p_prio);
  /* Insertion on p_prev.*/
  otp->p_next = cp;
 80007a8:	6023      	str	r3, [r4, #0]
  otp->p_prev = cp->p_prev;
 80007aa:	6062      	str	r2, [r4, #4]
  otp->p_prev->p_next = otp;
 80007ac:	6014      	str	r4, [r2, #0]
  cp->p_prev = otp;
 80007ae:	605c      	str	r4, [r3, #4]

  chSysSwitch(currp, otp);
}
 80007b0:	bc30      	pop	{r4, r5}
  otp->p_next = cp;
  otp->p_prev = cp->p_prev;
  otp->p_prev->p_next = otp;
  cp->p_prev = otp;

  chSysSwitch(currp, otp);
 80007b2:	f7ff bd2d 	b.w	8000210 <_port_switch>
 80007b6:	bf00      	nop
 80007b8:	20000c18 	.word	0x20000c18
 80007bc:	00000000 	.word	0x00000000

080007c0 <chSchDoReschedule>:
    chSchDoRescheduleAhead();
  }
#else /* !(CH_CFG_TIME_QUANTUM > 0) */
  /* If the round-robin mechanism is disabled then the thread goes always
     ahead of its peers.*/
  chSchDoRescheduleAhead();
 80007c0:	f7ff bfde 	b.w	8000780 <chSchDoRescheduleAhead>
	...

080007d0 <chSchGoSleepS>:
void chSchGoSleepS(tstate_t newstate) {
  thread_t *otp;

  chDbgCheckClassS();

  otp = currp;
 80007d0:	4b07      	ldr	r3, [pc, #28]	; (80007f0 <chSchGoSleepS+0x20>)
 *
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
 80007d2:	b430      	push	{r4, r5}
  thread_t *otp;

  chDbgCheckClassS();

  otp = currp;
 80007d4:	6999      	ldr	r1, [r3, #24]
  tp->p_prev->p_next = tp;
  tqp->p_prev = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;
 80007d6:	681a      	ldr	r2, [r3, #0]
  otp->p_state = newstate;
 80007d8:	7708      	strb	r0, [r1, #28]

  tqp->p_next = tp->p_next;
 80007da:	6814      	ldr	r4, [r2, #0]
#if defined(CH_CFG_IDLE_ENTER_HOOK)
  if (currp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 80007dc:	2501      	movs	r5, #1
  tqp->p_next->p_prev = (thread_t *)tqp;
 80007de:	6063      	str	r3, [r4, #4]
 80007e0:	7715      	strb	r5, [r2, #28]
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 80007e2:	601c      	str	r4, [r3, #0]
  chSysSwitch(currp, otp);
 80007e4:	4610      	mov	r0, r2
}
 80007e6:	bc30      	pop	{r4, r5}
#if CH_CFG_TIME_QUANTUM > 0
  /* The thread is renouncing its remaining time slices so it will have a new
     time quantum when it will wakeup.*/
  otp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
  setcurrp(queue_fifo_remove(&ch.rlist.r_queue));
 80007e8:	619a      	str	r2, [r3, #24]
  if (currp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
  chSysSwitch(currp, otp);
 80007ea:	f7ff bd11 	b.w	8000210 <_port_switch>
 80007ee:	bf00      	nop
 80007f0:	20000c18 	.word	0x20000c18
	...

08000800 <chSchGoSleepTimeoutS>:
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {

  chDbgCheckClassS();

  if (TIME_INFINITE != time) {
 8000800:	f64f 73ff 	movw	r3, #65535	; 0xffff
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
 8000804:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}

  chDbgCheckClassS();

  if (TIME_INFINITE != time) {
 8000808:	4299      	cmp	r1, r3
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
 800080a:	b086      	sub	sp, #24

  chDbgCheckClassS();

  if (TIME_INFINITE != time) {
 800080c:	d051      	beq.n	80008b2 <chSchGoSleepTimeoutS+0xb2>
    virtual_timer_t vt;

    chVTDoSetI(&vt, time, wakeup, currp);
 800080e:	4c48      	ldr	r4, [pc, #288]	; (8000930 <chSchGoSleepTimeoutS+0x130>)
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8000810:	f04f 4780 	mov.w	r7, #1073741824	; 0x40000000
    if (delay < (systime_t)CH_CFG_ST_TIMEDELTA) {
      delay = (systime_t)CH_CFG_ST_TIMEDELTA;
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {
 8000814:	4625      	mov	r5, r4
 8000816:	f855 2f1c 	ldr.w	r2, [r5, #28]!
 800081a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    systime_t now = chVTGetSystemTimeX();

    /* If the requested delay is lower than the minimum safe delta then it
       is raised to the minimum safe value.*/
    if (delay < (systime_t)CH_CFG_ST_TIMEDELTA) {
      delay = (systime_t)CH_CFG_ST_TIMEDELTA;
 800081c:	2901      	cmp	r1, #1
 800081e:	4606      	mov	r6, r0

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->vt_par = par;
  vtp->vt_func = vtfunc;
 8000820:	f8df e110 	ldr.w	lr, [pc, #272]	; 8000934 <chSchGoSleepTimeoutS+0x134>
  systime_t delta;

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->vt_par = par;
 8000824:	69a0      	ldr	r0, [r4, #24]
    systime_t now = chVTGetSystemTimeX();

    /* If the requested delay is lower than the minimum safe delta then it
       is raised to the minimum safe value.*/
    if (delay < (systime_t)CH_CFG_ST_TIMEDELTA) {
      delay = (systime_t)CH_CFG_ST_TIMEDELTA;
 8000826:	bf98      	it	ls
 8000828:	2102      	movls	r1, #2
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {
 800082a:	42aa      	cmp	r2, r5
  systime_t delta;

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->vt_par = par;
 800082c:	9005      	str	r0, [sp, #20]
 800082e:	b29b      	uxth	r3, r3
  vtp->vt_func = vtfunc;
 8000830:	f8cd e010 	str.w	lr, [sp, #16]
    if (delay < (systime_t)CH_CFG_ST_TIMEDELTA) {
      delay = (systime_t)CH_CFG_ST_TIMEDELTA;
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {
 8000834:	d064      	beq.n	8000900 <chSchGoSleepTimeoutS+0x100>
      return;
    }

    /* Special case where the timer will be placed as first element in a
       non-empty list, the alarm needs to be recalculated.*/
    delta = now + delay - ch.vtlist.vt_lasttime;
 8000836:	4419      	add	r1, r3
 8000838:	8ce3      	ldrh	r3, [r4, #38]	; 0x26
 800083a:	b289      	uxth	r1, r1
    if (delta < ch.vtlist.vt_next->vt_delta) {
 800083c:	8910      	ldrh	r0, [r2, #8]
      return;
    }

    /* Special case where the timer will be placed as first element in a
       non-empty list, the alarm needs to be recalculated.*/
    delta = now + delay - ch.vtlist.vt_lasttime;
 800083e:	1acb      	subs	r3, r1, r3
 8000840:	b29b      	uxth	r3, r3
    if (delta < ch.vtlist.vt_next->vt_delta) {
 8000842:	4283      	cmp	r3, r0
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8000844:	bf38      	it	cc
 8000846:	6379      	strcc	r1, [r7, #52]	; 0x34
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = ch.vtlist.vt_next;
  while (p->vt_delta < delta) {
 8000848:	4283      	cmp	r3, r0
 800084a:	d905      	bls.n	8000858 <chSchGoSleepTimeoutS+0x58>
    delta -= p->vt_delta;
    p = p->vt_next;
 800084c:	6812      	ldr	r2, [r2, #0]

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = ch.vtlist.vt_next;
  while (p->vt_delta < delta) {
    delta -= p->vt_delta;
 800084e:	1a1b      	subs	r3, r3, r0
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = ch.vtlist.vt_next;
  while (p->vt_delta < delta) {
 8000850:	8910      	ldrh	r0, [r2, #8]
    delta -= p->vt_delta;
 8000852:	b29b      	uxth	r3, r3
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = ch.vtlist.vt_next;
  while (p->vt_delta < delta) {
 8000854:	4298      	cmp	r0, r3
 8000856:	d3f9      	bcc.n	800084c <chSchGoSleepTimeoutS+0x4c>
  vtp->vt_delta = delta

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->vt_delta -= delta;
  ch.vtlist.vt_delta = (systime_t)-1;
 8000858:	f64f 70ff 	movw	r0, #65535	; 0xffff
    p = p->vt_next;
  }

  /* The timer is inserted in the delta list.*/
  vtp->vt_next = p;
  vtp->vt_prev = vtp->vt_next->vt_prev;
 800085c:	6851      	ldr	r1, [r2, #4]
  vtp->vt_prev->vt_next = vtp;
 800085e:	f10d 0804 	add.w	r8, sp, #4
    p = p->vt_next;
  }

  /* The timer is inserted in the delta list.*/
  vtp->vt_next = p;
  vtp->vt_prev = vtp->vt_next->vt_prev;
 8000862:	9102      	str	r1, [sp, #8]
    delta -= p->vt_delta;
    p = p->vt_next;
  }

  /* The timer is inserted in the delta list.*/
  vtp->vt_next = p;
 8000864:	9201      	str	r2, [sp, #4]
  vtp->vt_prev = vtp->vt_next->vt_prev;
  vtp->vt_prev->vt_next = vtp;
 8000866:	f8c1 8000 	str.w	r8, [r1]
  p->vt_prev = vtp;
 800086a:	f8c2 8004 	str.w	r8, [r2, #4]
  vtp->vt_delta = delta
 800086e:	f8ad 300c 	strh.w	r3, [sp, #12]

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->vt_delta -= delta;
 8000872:	8911      	ldrh	r1, [r2, #8]
 8000874:	1acb      	subs	r3, r1, r3
 8000876:	8113      	strh	r3, [r2, #8]
  ch.vtlist.vt_delta = (systime_t)-1;
 8000878:	84a0      	strh	r0, [r4, #36]	; 0x24
    chSchGoSleepS(newstate);
 800087a:	4630      	mov	r0, r6
 800087c:	f7ff ffa8 	bl	80007d0 <chSchGoSleepS>
    if (chVTIsArmedI(&vt)) {
 8000880:	9b04      	ldr	r3, [sp, #16]
 8000882:	b18b      	cbz	r3, 80008a8 <chSchGoSleepTimeoutS+0xa8>
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  systime_t nowdelta, delta;

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.vt_next != vtp) {
 8000884:	69e3      	ldr	r3, [r4, #28]
 8000886:	4a2a      	ldr	r2, [pc, #168]	; (8000930 <chSchGoSleepTimeoutS+0x130>)
 8000888:	4543      	cmp	r3, r8
 800088a:	d01a      	beq.n	80008c2 <chSchGoSleepTimeoutS+0xc2>
    /* Removing the element from the delta list.*/
    vtp->vt_prev->vt_next = vtp->vt_next;
 800088c:	9a02      	ldr	r2, [sp, #8]
 800088e:	9b01      	ldr	r3, [sp, #4]
    vtp->vt_next->vt_prev = vtp->vt_prev;
    vtp->vt_func = NULL;
 8000890:	2100      	movs	r1, #0

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.vt_next != vtp) {
    /* Removing the element from the delta list.*/
    vtp->vt_prev->vt_next = vtp->vt_next;
 8000892:	6013      	str	r3, [r2, #0]
    vtp->vt_next->vt_prev = vtp->vt_prev;
 8000894:	9b01      	ldr	r3, [sp, #4]
    vtp->vt_func = NULL;

    /* Adding delta to the next element, if it is not the last one.*/
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->vt_next)
 8000896:	42ab      	cmp	r3, r5
  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.vt_next != vtp) {
    /* Removing the element from the delta list.*/
    vtp->vt_prev->vt_next = vtp->vt_next;
    vtp->vt_next->vt_prev = vtp->vt_prev;
 8000898:	605a      	str	r2, [r3, #4]
    vtp->vt_func = NULL;
 800089a:	9104      	str	r1, [sp, #16]

    /* Adding delta to the next element, if it is not the last one.*/
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->vt_next)
 800089c:	d004      	beq.n	80008a8 <chSchGoSleepTimeoutS+0xa8>
      vtp->vt_next->vt_delta += vtp->vt_delta;
 800089e:	8919      	ldrh	r1, [r3, #8]
 80008a0:	f8bd 200c 	ldrh.w	r2, [sp, #12]
 80008a4:	440a      	add	r2, r1
 80008a6:	811a      	strh	r2, [r3, #8]
  }
  else {
    chSchGoSleepS(newstate);
  }

  return currp->p_u.rdymsg;
 80008a8:	69a3      	ldr	r3, [r4, #24]
}
 80008aa:	6a18      	ldr	r0, [r3, #32]
 80008ac:	b006      	add	sp, #24
 80008ae:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    if (chVTIsArmedI(&vt)) {
      chVTDoResetI(&vt);
    }
  }
  else {
    chSchGoSleepS(newstate);
 80008b2:	f7ff ff8d 	bl	80007d0 <chSchGoSleepS>
 80008b6:	4c1e      	ldr	r4, [pc, #120]	; (8000930 <chSchGoSleepTimeoutS+0x130>)
  }

  return currp->p_u.rdymsg;
 80008b8:	69a3      	ldr	r3, [r4, #24]
}
 80008ba:	6a18      	ldr	r0, [r3, #32]
 80008bc:	b006      	add	sp, #24
 80008be:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

    return;
  }

  /* Removing the first timer from the list.*/
  ch.vtlist.vt_next = vtp->vt_next;
 80008c2:	9901      	ldr	r1, [sp, #4]
  ch.vtlist.vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
  vtp->vt_func = NULL;
 80008c4:	2300      	movs	r3, #0

  /* If the list become empty then the alarm timer is stopped and done.*/
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {
 80008c6:	42a9      	cmp	r1, r5

    return;
  }

  /* Removing the first timer from the list.*/
  ch.vtlist.vt_next = vtp->vt_next;
 80008c8:	61d1      	str	r1, [r2, #28]
  ch.vtlist.vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
 80008ca:	604d      	str	r5, [r1, #4]
  vtp->vt_func = NULL;
 80008cc:	9304      	str	r3, [sp, #16]

  /* If the list become empty then the alarm timer is stopped and done.*/
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {
 80008ce:	d02a      	beq.n	8000926 <chSchGoSleepTimeoutS+0x126>
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 80008d0:	f04f 4080 	mov.w	r0, #1073741824	; 0x40000000
 80008d4:	6a45      	ldr	r5, [r0, #36]	; 0x24
/*  if (ch.vtlist.vt_next->vt_delta == 0) {
    return;
  }*/

  /* Distance in ticks between the last alarm event and current time.*/
  nowdelta = chVTGetSystemTimeX() - ch.vtlist.vt_lasttime;
 80008d6:	8cd2      	ldrh	r2, [r2, #38]	; 0x26

    return;
  }

  /* The delta of the removed timer is added to the new first timer.*/
  ch.vtlist.vt_next->vt_delta += vtp->vt_delta;
 80008d8:	890e      	ldrh	r6, [r1, #8]
 80008da:	f8bd 300c 	ldrh.w	r3, [sp, #12]
 80008de:	b2ad      	uxth	r5, r5
/*  if (ch.vtlist.vt_next->vt_delta == 0) {
    return;
  }*/

  /* Distance in ticks between the last alarm event and current time.*/
  nowdelta = chVTGetSystemTimeX() - ch.vtlist.vt_lasttime;
 80008e0:	1aaa      	subs	r2, r5, r2

    return;
  }

  /* The delta of the removed timer is added to the new first timer.*/
  ch.vtlist.vt_next->vt_delta += vtp->vt_delta;
 80008e2:	4433      	add	r3, r6
 80008e4:	b29b      	uxth	r3, r3
/*  if (ch.vtlist.vt_next->vt_delta == 0) {
    return;
  }*/

  /* Distance in ticks between the last alarm event and current time.*/
  nowdelta = chVTGetSystemTimeX() - ch.vtlist.vt_lasttime;
 80008e6:	b292      	uxth	r2, r2

  /* If the current time surpassed the time of the next element in list
     then the event interrupt is already pending, just return.*/
  if (nowdelta >= ch.vtlist.vt_next->vt_delta) {
 80008e8:	4293      	cmp	r3, r2

    return;
  }

  /* The delta of the removed timer is added to the new first timer.*/
  ch.vtlist.vt_next->vt_delta += vtp->vt_delta;
 80008ea:	810b      	strh	r3, [r1, #8]
  /* Distance in ticks between the last alarm event and current time.*/
  nowdelta = chVTGetSystemTimeX() - ch.vtlist.vt_lasttime;

  /* If the current time surpassed the time of the next element in list
     then the event interrupt is already pending, just return.*/
  if (nowdelta >= ch.vtlist.vt_next->vt_delta) {
 80008ec:	d9dc      	bls.n	80008a8 <chSchGoSleepTimeoutS+0xa8>
    return;
  }

  /* Distance from the next scheduled event and now.*/
  delta = ch.vtlist.vt_next->vt_delta - nowdelta;
 80008ee:	1a9a      	subs	r2, r3, r2
 80008f0:	b293      	uxth	r3, r2

  /* Making sure to not schedule an event closer than CH_CFG_ST_TIMEDELTA
     ticks from now.*/
  if (delta < (systime_t)CH_CFG_ST_TIMEDELTA) {
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
 80008f2:	2b01      	cmp	r3, #1
 80008f4:	bf98      	it	ls
 80008f6:	2302      	movls	r3, #2
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 80008f8:	442b      	add	r3, r5
 80008fa:	b29b      	uxth	r3, r3
 80008fc:	6343      	str	r3, [r0, #52]	; 0x34
 80008fe:	e7d3      	b.n	80008a8 <chSchGoSleepTimeoutS+0xa8>
 *
 * @notapi
 */
static inline void st_lld_start_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8000900:	185a      	adds	r2, r3, r1
    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {

      /* The delta list is empty, the current time becomes the new
         delta list base time, the timer is inserted.*/
      ch.vtlist.vt_lasttime = now;
 8000902:	84e3      	strh	r3, [r4, #38]	; 0x26
      ch.vtlist.vt_next = vtp;
 8000904:	f10d 0804 	add.w	r8, sp, #4
 8000908:	b292      	uxth	r2, r2
  STM32_ST_TIM->SR     = 0;
 800090a:	2000      	movs	r0, #0
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 800090c:	2302      	movs	r3, #2
      ch.vtlist.vt_prev = vtp;
      vtp->vt_next = (virtual_timer_t *)&ch.vtlist;
 800090e:	9501      	str	r5, [sp, #4]
      vtp->vt_prev = (virtual_timer_t *)&ch.vtlist;
 8000910:	9502      	str	r5, [sp, #8]
      vtp->vt_delta = delay;
 8000912:	f8ad 100c 	strh.w	r1, [sp, #12]
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.vt_next) {

      /* The delta list is empty, the current time becomes the new
         delta list base time, the timer is inserted.*/
      ch.vtlist.vt_lasttime = now;
      ch.vtlist.vt_next = vtp;
 8000916:	f8c4 801c 	str.w	r8, [r4, #28]
      ch.vtlist.vt_prev = vtp;
 800091a:	f8c4 8020 	str.w	r8, [r4, #32]
 *
 * @notapi
 */
static inline void st_lld_start_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 800091e:	637a      	str	r2, [r7, #52]	; 0x34
  STM32_ST_TIM->SR     = 0;
 8000920:	6138      	str	r0, [r7, #16]
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 8000922:	60fb      	str	r3, [r7, #12]
 8000924:	e7a9      	b.n	800087a <chSchGoSleepTimeoutS+0x7a>
 *
 * @notapi
 */
static inline void st_lld_stop_alarm(void) {

  STM32_ST_TIM->DIER = 0;
 8000926:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 800092a:	60d3      	str	r3, [r2, #12]
 800092c:	e7bc      	b.n	80008a8 <chSchGoSleepTimeoutS+0xa8>
 800092e:	bf00      	nop
 8000930:	20000c18 	.word	0x20000c18
 8000934:	08000501 	.word	0x08000501
	...

08000940 <chThdEnqueueTimeoutS>:
 *
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, systime_t timeout) {

  if (TIME_IMMEDIATE == timeout) {
 8000940:	b161      	cbz	r1, 800095c <chThdEnqueueTimeoutS+0x1c>
 8000942:	4602      	mov	r2, r0
    return MSG_TIMEOUT;
  }

  queue_insert(currp, tqp);
 8000944:	4b07      	ldr	r3, [pc, #28]	; (8000964 <chThdEnqueueTimeoutS+0x24>)
 *                      invoked with @p TIME_IMMEDIATE as timeout
 *                      specification.
 *
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, systime_t timeout) {
 8000946:	b410      	push	{r4}

  if (TIME_IMMEDIATE == timeout) {
    return MSG_TIMEOUT;
  }

  queue_insert(currp, tqp);
 8000948:	699b      	ldr	r3, [r3, #24]
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->p_next = (thread_t *)tqp;
  tp->p_prev = tqp->p_prev;
 800094a:	6844      	ldr	r4, [r0, #4]

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 800094c:	2004      	movs	r0, #4
 800094e:	e883 0014 	stmia.w	r3, {r2, r4}
  tp->p_prev->p_next = tp;
 8000952:	6023      	str	r3, [r4, #0]
  tqp->p_prev = tp;
 8000954:	6053      	str	r3, [r2, #4]
}
 8000956:	bc10      	pop	{r4}
    return MSG_TIMEOUT;
  }

  queue_insert(currp, tqp);

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 8000958:	f7ff bf52 	b.w	8000800 <chSchGoSleepTimeoutS>
}
 800095c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8000960:	4770      	bx	lr
 8000962:	bf00      	nop
 8000964:	20000c18 	.word	0x20000c18
	...

08000970 <chOQWriteTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t chOQWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                        size_t n, systime_t timeout) {
 8000970:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8000974:	b083      	sub	sp, #12
 8000976:	4604      	mov	r4, r0
 8000978:	460d      	mov	r5, r1
 800097a:	4616      	mov	r6, r2
 800097c:	9301      	str	r3, [sp, #4]
  qnotify_t nfy = oqp->q_notify;
 800097e:	f8d0 801c 	ldr.w	r8, [r0, #28]
 8000982:	f04f 0920 	mov.w	r9, #32
 8000986:	f389 8811 	msr	BASEPRI, r9
  size_t w = 0;
 800098a:	2700      	movs	r7, #0
 800098c:	46ba      	mov	sl, r7
 */
static inline bool chOQIsFullI(output_queue_t *oqp) {

  chDbgCheckClassI();

  return (bool)(chQSpaceI(oqp) == 0U);
 800098e:	68a3      	ldr	r3, [r4, #8]
        return w;
      }
    }
    
    oqp->q_counter--;
    *oqp->q_wrptr++ = *bp++;
 8000990:	f105 0b01 	add.w	fp, r5, #1

  chDbgCheck(n > 0U);

  chSysLock();
  while (true) {
    while (chOQIsFullI(oqp)) {
 8000994:	b303      	cbz	r3, 80009d8 <chOQWriteTimeout+0x68>
        return w;
      }
    }
    
    oqp->q_counter--;
    *oqp->q_wrptr++ = *bp++;
 8000996:	6961      	ldr	r1, [r4, #20]
        chSysUnlock();
        return w;
      }
    }
    
    oqp->q_counter--;
 8000998:	68a3      	ldr	r3, [r4, #8]
    *oqp->q_wrptr++ = *bp++;
 800099a:	1c48      	adds	r0, r1, #1
        chSysUnlock();
        return w;
      }
    }
    
    oqp->q_counter--;
 800099c:	3b01      	subs	r3, #1
    *oqp->q_wrptr++ = *bp++;
 800099e:	6160      	str	r0, [r4, #20]
        chSysUnlock();
        return w;
      }
    }
    
    oqp->q_counter--;
 80009a0:	60a3      	str	r3, [r4, #8]
    *oqp->q_wrptr++ = *bp++;
 80009a2:	782b      	ldrb	r3, [r5, #0]
 80009a4:	700b      	strb	r3, [r1, #0]
    if (oqp->q_wrptr >= oqp->q_top) {
 80009a6:	6923      	ldr	r3, [r4, #16]
 80009a8:	6961      	ldr	r1, [r4, #20]
 80009aa:	4299      	cmp	r1, r3
      oqp->q_wrptr = oqp->q_buffer;
 80009ac:	bf24      	itt	cs
 80009ae:	68e3      	ldrcs	r3, [r4, #12]
 80009b0:	6163      	strcs	r3, [r4, #20]
    }

    if (nfy != NULL) {
 80009b2:	f1b8 0f00 	cmp.w	r8, #0
 80009b6:	d001      	beq.n	80009bc <chOQWriteTimeout+0x4c>
      nfy(oqp);
 80009b8:	4620      	mov	r0, r4
 80009ba:	47c0      	blx	r8
 80009bc:	f38a 8811 	msr	BASEPRI, sl
    }
    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/

    w++;
    if (--n == 0U) {
 80009c0:	3e01      	subs	r6, #1
    if (nfy != NULL) {
      nfy(oqp);
    }
    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/

    w++;
 80009c2:	f107 0701 	add.w	r7, r7, #1
    if (--n == 0U) {
 80009c6:	d011      	beq.n	80009ec <chOQWriteTimeout+0x7c>
 80009c8:	f389 8811 	msr	BASEPRI, r9
        return w;
      }
    }
    
    oqp->q_counter--;
    *oqp->q_wrptr++ = *bp++;
 80009cc:	465d      	mov	r5, fp
 80009ce:	68a3      	ldr	r3, [r4, #8]
 80009d0:	f105 0b01 	add.w	fp, r5, #1

  chDbgCheck(n > 0U);

  chSysLock();
  while (true) {
    while (chOQIsFullI(oqp)) {
 80009d4:	2b00      	cmp	r3, #0
 80009d6:	d1de      	bne.n	8000996 <chOQWriteTimeout+0x26>
      if (chThdEnqueueTimeoutS(&oqp->q_waiting, timeout) != Q_OK) {
 80009d8:	9901      	ldr	r1, [sp, #4]
 80009da:	4620      	mov	r0, r4
 80009dc:	9300      	str	r3, [sp, #0]
 80009de:	f7ff ffaf 	bl	8000940 <chThdEnqueueTimeoutS>
 80009e2:	9b00      	ldr	r3, [sp, #0]
 80009e4:	2800      	cmp	r0, #0
 80009e6:	d0d2      	beq.n	800098e <chOQWriteTimeout+0x1e>
 80009e8:	f383 8811 	msr	BASEPRI, r3
    if (--n == 0U) {
      return w;
    }
    chSysLock();
  }
}
 80009ec:	4638      	mov	r0, r7
 80009ee:	b003      	add	sp, #12
 80009f0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	...

08000a00 <writet.lto_priv.43>:
  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
}

static size_t writet(void *ip, const uint8_t *bp, size_t n, systime_t timeout) {

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
 8000a00:	3030      	adds	r0, #48	; 0x30
 8000a02:	f7ff bfb5 	b.w	8000970 <chOQWriteTimeout>
 8000a06:	bf00      	nop
	...

08000a10 <write.lto_priv.37>:
 * queue-level function or macro.
 */

static size_t write(void *ip, const uint8_t *bp, size_t n) {

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
 8000a10:	3030      	adds	r0, #48	; 0x30
 8000a12:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8000a16:	f7ff bfab 	b.w	8000970 <chOQWriteTimeout>
 8000a1a:	bf00      	nop
 8000a1c:	0000      	movs	r0, r0
	...

08000a20 <chOQPutTimeout>:
 * @retval Q_TIMEOUT    if the specified time expired.
 * @retval Q_RESET      if the queue has been reset.
 *
 * @api
 */
msg_t chOQPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {
 8000a20:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8000a22:	4604      	mov	r4, r0
 8000a24:	460f      	mov	r7, r1
 8000a26:	4616      	mov	r6, r2
 8000a28:	2320      	movs	r3, #32
 8000a2a:	f383 8811 	msr	BASEPRI, r3
 8000a2e:	e005      	b.n	8000a3c <chOQPutTimeout+0x1c>

  chSysLock();
  while (chOQIsFullI(oqp)) {
    msg_t msg = chThdEnqueueTimeoutS(&oqp->q_waiting, timeout);
 8000a30:	4631      	mov	r1, r6
 8000a32:	4620      	mov	r0, r4
 8000a34:	f7ff ff84 	bl	8000940 <chThdEnqueueTimeoutS>
    if (msg < Q_OK) {
 8000a38:	2800      	cmp	r0, #0
 8000a3a:	db17      	blt.n	8000a6c <chOQPutTimeout+0x4c>
 8000a3c:	68a5      	ldr	r5, [r4, #8]
 * @api
 */
msg_t chOQPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {

  chSysLock();
  while (chOQIsFullI(oqp)) {
 8000a3e:	2d00      	cmp	r5, #0
 8000a40:	d0f6      	beq.n	8000a30 <chOQPutTimeout+0x10>
      return msg;
    }
  }

  oqp->q_counter--;
  *oqp->q_wrptr++ = b;
 8000a42:	6962      	ldr	r2, [r4, #20]
      chSysUnlock();
      return msg;
    }
  }

  oqp->q_counter--;
 8000a44:	68a3      	ldr	r3, [r4, #8]
  *oqp->q_wrptr++ = b;
 8000a46:	1c51      	adds	r1, r2, #1
      chSysUnlock();
      return msg;
    }
  }

  oqp->q_counter--;
 8000a48:	3b01      	subs	r3, #1
  *oqp->q_wrptr++ = b;
 8000a4a:	6161      	str	r1, [r4, #20]
      chSysUnlock();
      return msg;
    }
  }

  oqp->q_counter--;
 8000a4c:	60a3      	str	r3, [r4, #8]
  *oqp->q_wrptr++ = b;
 8000a4e:	7017      	strb	r7, [r2, #0]
  if (oqp->q_wrptr >= oqp->q_top) {
 8000a50:	6923      	ldr	r3, [r4, #16]
 8000a52:	6962      	ldr	r2, [r4, #20]
 8000a54:	429a      	cmp	r2, r3
    oqp->q_wrptr = oqp->q_buffer;
 8000a56:	bf24      	itt	cs
 8000a58:	68e3      	ldrcs	r3, [r4, #12]
 8000a5a:	6163      	strcs	r3, [r4, #20]
  }

  if (oqp->q_notify != NULL) {
 8000a5c:	69e3      	ldr	r3, [r4, #28]
 8000a5e:	b10b      	cbz	r3, 8000a64 <chOQPutTimeout+0x44>
    oqp->q_notify(oqp);
 8000a60:	4620      	mov	r0, r4
 8000a62:	4798      	blx	r3
 8000a64:	2000      	movs	r0, #0
 8000a66:	f380 8811 	msr	BASEPRI, r0
  }
  chSysUnlock();

  return Q_OK;
}
 8000a6a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8000a6c:	f385 8811 	msr	BASEPRI, r5
 8000a70:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8000a72:	bf00      	nop
	...

08000a80 <putt.lto_priv.41>:
  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
}

static msg_t putt(void *ip, uint8_t b, systime_t timeout) {

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
 8000a80:	3030      	adds	r0, #48	; 0x30
 8000a82:	f7ff bfcd 	b.w	8000a20 <chOQPutTimeout>
 8000a86:	bf00      	nop
	...

08000a90 <put.lto_priv.39>:
                       n, TIME_INFINITE);
}

static msg_t put(void *ip, uint8_t b) {

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
 8000a90:	3030      	adds	r0, #48	; 0x30
 8000a92:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8000a96:	f7ff bfc3 	b.w	8000a20 <chOQPutTimeout>
 8000a9a:	bf00      	nop
 8000a9c:	0000      	movs	r0, r0
	...

08000aa0 <chIQReadTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t chIQReadTimeout(input_queue_t *iqp, uint8_t *bp,
                       size_t n, systime_t timeout) {
 8000aa0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8000aa4:	4604      	mov	r4, r0
 8000aa6:	b083      	sub	sp, #12
 8000aa8:	4689      	mov	r9, r1
 8000aaa:	4693      	mov	fp, r2
 8000aac:	461d      	mov	r5, r3
  qnotify_t nfy = iqp->q_notify;
 8000aae:	f8d0 801c 	ldr.w	r8, [r0, #28]
 8000ab2:	2720      	movs	r7, #32
 8000ab4:	f387 8811 	msr	BASEPRI, r7
  size_t r = 0;
 8000ab8:	2600      	movs	r6, #0
 8000aba:	46b2      	mov	sl, r6
 8000abc:	9701      	str	r7, [sp, #4]

  chDbgCheck(n > 0U);

  chSysLock();
  while (true) {
    if (nfy != NULL) {
 8000abe:	f1b8 0f00 	cmp.w	r8, #0
 8000ac2:	d007      	beq.n	8000ad4 <chIQReadTimeout+0x34>
      nfy(iqp);
 8000ac4:	4620      	mov	r0, r4
 8000ac6:	47c0      	blx	r8
 8000ac8:	e004      	b.n	8000ad4 <chIQReadTimeout+0x34>
    }

    while (chIQIsEmptyI(iqp)) {
      if (chThdEnqueueTimeoutS(&iqp->q_waiting, timeout) != Q_OK) {
 8000aca:	4629      	mov	r1, r5
 8000acc:	4620      	mov	r0, r4
 8000ace:	f7ff ff37 	bl	8000940 <chThdEnqueueTimeoutS>
 8000ad2:	b9d0      	cbnz	r0, 8000b0a <chIQReadTimeout+0x6a>
 */
static inline bool chIQIsEmptyI(input_queue_t *iqp) {

  chDbgCheckClassI();

  return (bool)(chQSpaceI(iqp) == 0U);
 8000ad4:	68a7      	ldr	r7, [r4, #8]
  while (true) {
    if (nfy != NULL) {
      nfy(iqp);
    }

    while (chIQIsEmptyI(iqp)) {
 8000ad6:	2f00      	cmp	r7, #0
 8000ad8:	d0f7      	beq.n	8000aca <chIQReadTimeout+0x2a>
        return r;
      }
    }

    iqp->q_counter--;
    *bp++ = *iqp->q_rdptr++;
 8000ada:	69a2      	ldr	r2, [r4, #24]
        chSysUnlock();
        return r;
      }
    }

    iqp->q_counter--;
 8000adc:	68a3      	ldr	r3, [r4, #8]
    *bp++ = *iqp->q_rdptr++;
 8000ade:	1c51      	adds	r1, r2, #1
        chSysUnlock();
        return r;
      }
    }

    iqp->q_counter--;
 8000ae0:	3b01      	subs	r3, #1
    *bp++ = *iqp->q_rdptr++;
 8000ae2:	61a1      	str	r1, [r4, #24]
        chSysUnlock();
        return r;
      }
    }

    iqp->q_counter--;
 8000ae4:	60a3      	str	r3, [r4, #8]
    *bp++ = *iqp->q_rdptr++;
 8000ae6:	7813      	ldrb	r3, [r2, #0]
 8000ae8:	f809 3b01 	strb.w	r3, [r9], #1
    if (iqp->q_rdptr >= iqp->q_top) {
 8000aec:	6923      	ldr	r3, [r4, #16]
 8000aee:	69a2      	ldr	r2, [r4, #24]
 8000af0:	429a      	cmp	r2, r3
      iqp->q_rdptr = iqp->q_buffer;
 8000af2:	bf24      	itt	cs
 8000af4:	68e3      	ldrcs	r3, [r4, #12]
 8000af6:	61a3      	strcs	r3, [r4, #24]
 8000af8:	f38a 8811 	msr	BASEPRI, sl
    }
    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/

    r++;
 8000afc:	3601      	adds	r6, #1
    if (--n == 0U) {
 8000afe:	45b3      	cmp	fp, r6
 8000b00:	d005      	beq.n	8000b0e <chIQReadTimeout+0x6e>
 8000b02:	9b01      	ldr	r3, [sp, #4]
 8000b04:	f383 8811 	msr	BASEPRI, r3
 8000b08:	e7d9      	b.n	8000abe <chIQReadTimeout+0x1e>
 8000b0a:	f387 8811 	msr	BASEPRI, r7
      return r;
    }

    chSysLock();
  }
}
 8000b0e:	4630      	mov	r0, r6
 8000b10:	b003      	add	sp, #12
 8000b12:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8000b16:	bf00      	nop
	...

08000b20 <readt.lto_priv.44>:
  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
}

static size_t readt(void *ip, uint8_t *bp, size_t n, systime_t timeout) {

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp, n, timeout);
 8000b20:	300c      	adds	r0, #12
 8000b22:	f7ff bfbd 	b.w	8000aa0 <chIQReadTimeout>
 8000b26:	bf00      	nop
	...

08000b30 <read.lto_priv.38>:
                        n, TIME_INFINITE);
}

static size_t read(void *ip, uint8_t *bp, size_t n) {

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
 8000b30:	300c      	adds	r0, #12
 8000b32:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8000b36:	f7ff bfb3 	b.w	8000aa0 <chIQReadTimeout>
 8000b3a:	bf00      	nop
 8000b3c:	0000      	movs	r0, r0
	...

08000b40 <chIQGetTimeout>:
 * @retval Q_TIMEOUT    if the specified time expired.
 * @retval Q_RESET      if the queue has been reset.
 *
 * @api
 */
msg_t chIQGetTimeout(input_queue_t *iqp, systime_t timeout) {
 8000b40:	b570      	push	{r4, r5, r6, lr}
 8000b42:	2320      	movs	r3, #32
 8000b44:	460e      	mov	r6, r1
 8000b46:	4604      	mov	r4, r0
 8000b48:	f383 8811 	msr	BASEPRI, r3
  uint8_t b;

  chSysLock();
  if (iqp->q_notify != NULL) {
 8000b4c:	69c3      	ldr	r3, [r0, #28]
 8000b4e:	b13b      	cbz	r3, 8000b60 <chIQGetTimeout+0x20>
    iqp->q_notify(iqp);
 8000b50:	4798      	blx	r3
 8000b52:	e005      	b.n	8000b60 <chIQGetTimeout+0x20>
  }

  while (chIQIsEmptyI(iqp)) {
    msg_t msg = chThdEnqueueTimeoutS(&iqp->q_waiting, timeout);
 8000b54:	4631      	mov	r1, r6
 8000b56:	4620      	mov	r0, r4
 8000b58:	f7ff fef2 	bl	8000940 <chThdEnqueueTimeoutS>
    if (msg < Q_OK) {
 8000b5c:	2800      	cmp	r0, #0
 8000b5e:	db13      	blt.n	8000b88 <chIQGetTimeout+0x48>
 8000b60:	68a5      	ldr	r5, [r4, #8]
  chSysLock();
  if (iqp->q_notify != NULL) {
    iqp->q_notify(iqp);
  }

  while (chIQIsEmptyI(iqp)) {
 8000b62:	2d00      	cmp	r5, #0
 8000b64:	d0f6      	beq.n	8000b54 <chIQGetTimeout+0x14>
      return msg;
    }
  }

  iqp->q_counter--;
  b = *iqp->q_rdptr++;
 8000b66:	69a1      	ldr	r1, [r4, #24]
      chSysUnlock();
      return msg;
    }
  }

  iqp->q_counter--;
 8000b68:	68a3      	ldr	r3, [r4, #8]
  b = *iqp->q_rdptr++;
  if (iqp->q_rdptr >= iqp->q_top) {
 8000b6a:	6925      	ldr	r5, [r4, #16]
      return msg;
    }
  }

  iqp->q_counter--;
  b = *iqp->q_rdptr++;
 8000b6c:	1c4a      	adds	r2, r1, #1
      chSysUnlock();
      return msg;
    }
  }

  iqp->q_counter--;
 8000b6e:	3b01      	subs	r3, #1
  b = *iqp->q_rdptr++;
  if (iqp->q_rdptr >= iqp->q_top) {
 8000b70:	42aa      	cmp	r2, r5
      chSysUnlock();
      return msg;
    }
  }

  iqp->q_counter--;
 8000b72:	60a3      	str	r3, [r4, #8]
  b = *iqp->q_rdptr++;
  if (iqp->q_rdptr >= iqp->q_top) {
    iqp->q_rdptr = iqp->q_buffer;
 8000b74:	bf28      	it	cs
 8000b76:	68e3      	ldrcs	r3, [r4, #12]
      return msg;
    }
  }

  iqp->q_counter--;
  b = *iqp->q_rdptr++;
 8000b78:	61a2      	str	r2, [r4, #24]
 8000b7a:	7808      	ldrb	r0, [r1, #0]
  if (iqp->q_rdptr >= iqp->q_top) {
    iqp->q_rdptr = iqp->q_buffer;
 8000b7c:	bf28      	it	cs
 8000b7e:	61a3      	strcs	r3, [r4, #24]
 8000b80:	2300      	movs	r3, #0
 8000b82:	f383 8811 	msr	BASEPRI, r3
  }
  chSysUnlock();

  return (msg_t)b;
}
 8000b86:	bd70      	pop	{r4, r5, r6, pc}
 8000b88:	f385 8811 	msr	BASEPRI, r5
 8000b8c:	bd70      	pop	{r4, r5, r6, pc}
 8000b8e:	bf00      	nop

08000b90 <gett.lto_priv.42>:
  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
}

static msg_t gett(void *ip, systime_t timeout) {

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
 8000b90:	300c      	adds	r0, #12
 8000b92:	f7ff bfd5 	b.w	8000b40 <chIQGetTimeout>
 8000b96:	bf00      	nop
	...

08000ba0 <get.lto_priv.40>:
  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
}

static msg_t get(void *ip) {

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
 8000ba0:	300c      	adds	r0, #12
 8000ba2:	f64f 71ff 	movw	r1, #65535	; 0xffff
 8000ba6:	f7ff bfcb 	b.w	8000b40 <chIQGetTimeout>
 8000baa:	bf00      	nop
 8000bac:	0000      	movs	r0, r0
	...

08000bb0 <chThdSleep>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @api
 */
void chThdSleep(systime_t time) {
 8000bb0:	b508      	push	{r3, lr}
 8000bb2:	4601      	mov	r1, r0
 8000bb4:	2320      	movs	r3, #32
 8000bb6:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chThdSleepS(systime_t time) {

  chDbgCheck(time != TIME_IMMEDIATE);

  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, time);
 8000bba:	2008      	movs	r0, #8
 8000bbc:	f7ff fe20 	bl	8000800 <chSchGoSleepTimeoutS>
 8000bc0:	2300      	movs	r3, #0
 8000bc2:	f383 8811 	msr	BASEPRI, r3
 8000bc6:	bd08      	pop	{r3, pc}
	...

08000bd0 <chSchReadyI>:
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @iclass
 */
thread_t *chSchReadyI(thread_t *tp) {
 8000bd0:	b410      	push	{r4}
 8000bd2:	4604      	mov	r4, r0
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 8000bd4:	2200      	movs	r2, #0
 8000bd6:	6881      	ldr	r1, [r0, #8]
  cp = (thread_t *)&ch.rlist.r_queue;
 8000bd8:	4b06      	ldr	r3, [pc, #24]	; (8000bf4 <chSchReadyI+0x24>)
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 8000bda:	7702      	strb	r2, [r0, #28]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
 8000bdc:	681b      	ldr	r3, [r3, #0]
  } while (cp->p_prio >= tp->p_prio);
 8000bde:	689a      	ldr	r2, [r3, #8]
 8000be0:	428a      	cmp	r2, r1
 8000be2:	d2fb      	bcs.n	8000bdc <chSchReadyI+0xc>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 8000be4:	685a      	ldr	r2, [r3, #4]
  tp->p_prev->p_next = tp;
  cp->p_prev = tp;

  return tp;
}
 8000be6:	4620      	mov	r0, r4
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
 8000be8:	6023      	str	r3, [r4, #0]
  tp->p_prev = cp->p_prev;
 8000bea:	6062      	str	r2, [r4, #4]
  tp->p_prev->p_next = tp;
 8000bec:	6014      	str	r4, [r2, #0]
  cp->p_prev = tp;
 8000bee:	605c      	str	r4, [r3, #4]

  return tp;
}
 8000bf0:	bc10      	pop	{r4}
 8000bf2:	4770      	bx	lr
 8000bf4:	20000c18 	.word	0x20000c18
	...

08000c00 <VectorD4>:
/**
 * @brief   USART1 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_USART1_HANDLER) {
 8000c00:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 * @brief   Common IRQ handler.
 *
 * @param[in] sdp       communication channel associated to the USART
 */
static void serve_interrupt(SerialDriver *sdp) {
  USART_TypeDef *u = sdp->usart;
 8000c04:	4d6b      	ldr	r5, [pc, #428]	; (8000db4 <VectorD4+0x1b4>)
/**
 * @brief   USART1 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_USART1_HANDLER) {
 8000c06:	b082      	sub	sp, #8
 * @brief   Common IRQ handler.
 *
 * @param[in] sdp       communication channel associated to the USART
 */
static void serve_interrupt(SerialDriver *sdp) {
  USART_TypeDef *u = sdp->usart;
 8000c08:	6f6e      	ldr	r6, [r5, #116]	; 0x74
  uint16_t cr1 = u->CR1;
 8000c0a:	f8d6 a00c 	ldr.w	sl, [r6, #12]
  uint16_t sr = u->SR;
 8000c0e:	6833      	ldr	r3, [r6, #0]

  /* Special case, LIN break detection.*/
  if (sr & USART_SR_LBD) {
 8000c10:	05da      	lsls	r2, r3, #23
 * @param[in] sdp       communication channel associated to the USART
 */
static void serve_interrupt(SerialDriver *sdp) {
  USART_TypeDef *u = sdp->usart;
  uint16_t cr1 = u->CR1;
  uint16_t sr = u->SR;
 8000c12:	b29c      	uxth	r4, r3

  /* Special case, LIN break detection.*/
  if (sr & USART_SR_LBD) {
 8000c14:	f100 8082 	bmi.w	8000d1c <VectorD4+0x11c>
 8000c18:	2320      	movs	r3, #32
 8000c1a:	f383 8811 	msr	BASEPRI, r3
    osalSysUnlockFromISR();
  }

  /* Data available.*/
  osalSysLockFromISR();
  while (sr & (USART_SR_RXNE | USART_SR_ORE | USART_SR_NE | USART_SR_FE |
 8000c1e:	f014 0f2f 	tst.w	r4, #47	; 0x2f
 8000c22:	d049      	beq.n	8000cb8 <VectorD4+0xb8>
static inline bool chIQIsFullI(input_queue_t *iqp) {

  chDbgCheckClassI();

  /*lint -save -e9007 [13.5] No side effects.*/
  return (bool)((iqp->q_wrptr == iqp->q_rdptr) && (iqp->q_counter != 0U));
 8000c24:	4f63      	ldr	r7, [pc, #396]	; (8000db4 <VectorD4+0x1b4>)

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->p_state == CH_STATE_QUEUED, "invalid state");

  tp->p_u.rdymsg = msg;
 8000c26:	f04f 0900 	mov.w	r9, #0
 *
 * @iclass
 */
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {

  if (queue_notempty(tqp)) {
 8000c2a:	f107 080c 	add.w	r8, r7, #12
 8000c2e:	e007      	b.n	8000c40 <VectorD4+0x40>

    /* Error condition detection.*/
    if (sr & (USART_SR_ORE | USART_SR_NE | USART_SR_FE  | USART_SR_PE))
      set_error(sdp, sr);
    b = u->DR;
    if (sr & USART_SR_RXNE)
 8000c30:	06a1      	lsls	r1, r4, #26
    uint8_t b;

    /* Error condition detection.*/
    if (sr & (USART_SR_ORE | USART_SR_NE | USART_SR_FE  | USART_SR_PE))
      set_error(sdp, sr);
    b = u->DR;
 8000c32:	6873      	ldr	r3, [r6, #4]
    if (sr & USART_SR_RXNE)
 8000c34:	d41c      	bmi.n	8000c70 <VectorD4+0x70>
      sdIncomingDataI(sdp, b);
    sr = u->SR;
 8000c36:	6834      	ldr	r4, [r6, #0]
 8000c38:	b2a4      	uxth	r4, r4
    osalSysUnlockFromISR();
  }

  /* Data available.*/
  osalSysLockFromISR();
  while (sr & (USART_SR_RXNE | USART_SR_ORE | USART_SR_NE | USART_SR_FE |
 8000c3a:	f014 0f2f 	tst.w	r4, #47	; 0x2f
 8000c3e:	d03b      	beq.n	8000cb8 <VectorD4+0xb8>
               USART_SR_PE)) {
    uint8_t b;

    /* Error condition detection.*/
    if (sr & (USART_SR_ORE | USART_SR_NE | USART_SR_FE  | USART_SR_PE))
 8000c40:	0723      	lsls	r3, r4, #28
 8000c42:	d0f5      	beq.n	8000c30 <VectorD4+0x30>
 */
static void set_error(SerialDriver *sdp, uint16_t sr) {
  eventflags_t sts = 0;

  if (sr & USART_SR_ORE)
    sts |= SD_OVERRUN_ERROR;
 8000c44:	f014 0f08 	tst.w	r4, #8
 8000c48:	bf0c      	ite	eq
 8000c4a:	2000      	moveq	r0, #0
 8000c4c:	2080      	movne	r0, #128	; 0x80
  if (sr & USART_SR_PE)
 8000c4e:	07e1      	lsls	r1, r4, #31
    sts |= SD_PARITY_ERROR;
 8000c50:	bf48      	it	mi
 8000c52:	f040 0020 	orrmi.w	r0, r0, #32
  if (sr & USART_SR_FE)
 8000c56:	07a2      	lsls	r2, r4, #30
    sts |= SD_FRAMING_ERROR;
 8000c58:	bf48      	it	mi
 8000c5a:	f040 0040 	orrmi.w	r0, r0, #64	; 0x40
  if (sr & USART_SR_NE)
 8000c5e:	0763      	lsls	r3, r4, #29
    sts |= SD_NOISE_ERROR;
 8000c60:	bf48      	it	mi
 8000c62:	f440 7080 	orrmi.w	r0, r0, #256	; 0x100
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {

  chEvtBroadcastFlagsI(esp, flags);
 8000c66:	f001 f833 	bl	8001cd0 <chEvtBroadcastFlagsI.constprop.24>

    /* Error condition detection.*/
    if (sr & (USART_SR_ORE | USART_SR_NE | USART_SR_FE  | USART_SR_PE))
      set_error(sdp, sr);
    b = u->DR;
    if (sr & USART_SR_RXNE)
 8000c6a:	06a1      	lsls	r1, r4, #26
    uint8_t b;

    /* Error condition detection.*/
    if (sr & (USART_SR_ORE | USART_SR_NE | USART_SR_FE  | USART_SR_PE))
      set_error(sdp, sr);
    b = u->DR;
 8000c6c:	6873      	ldr	r3, [r6, #4]
    if (sr & USART_SR_RXNE)
 8000c6e:	d5e2      	bpl.n	8000c36 <VectorD4+0x36>
 */
static inline bool chIQIsEmptyI(input_queue_t *iqp) {

  chDbgCheckClassI();

  return (bool)(chQSpaceI(iqp) == 0U);
 8000c70:	696a      	ldr	r2, [r5, #20]
void sdIncomingDataI(SerialDriver *sdp, uint8_t b) {

  osalDbgCheckClassI();
  osalDbgCheck(sdp != NULL);

  if (iqIsEmptyI(&sdp->iqueue))
 8000c72:	2a00      	cmp	r2, #0
 8000c74:	d042      	beq.n	8000cfc <VectorD4+0xfc>
static inline bool chIQIsFullI(input_queue_t *iqp) {

  chDbgCheckClassI();

  /*lint -save -e9007 [13.5] No side effects.*/
  return (bool)((iqp->q_wrptr == iqp->q_rdptr) && (iqp->q_counter != 0U));
 8000c76:	6a29      	ldr	r1, [r5, #32]
 8000c78:	6a6a      	ldr	r2, [r5, #36]	; 0x24
 8000c7a:	4291      	cmp	r1, r2
 8000c7c:	d047      	beq.n	8000d0e <VectorD4+0x10e>

  if (chIQIsFullI(iqp)) {
    return Q_FULL;
  }

  iqp->q_counter++;
 8000c7e:	696a      	ldr	r2, [r5, #20]
  *iqp->q_wrptr++ = b;
 8000c80:	1c48      	adds	r0, r1, #1

  if (chIQIsFullI(iqp)) {
    return Q_FULL;
  }

  iqp->q_counter++;
 8000c82:	3201      	adds	r2, #1
 8000c84:	616a      	str	r2, [r5, #20]
  *iqp->q_wrptr++ = b;
 8000c86:	6228      	str	r0, [r5, #32]
 8000c88:	700b      	strb	r3, [r1, #0]
  if (iqp->q_wrptr >= iqp->q_top) {
 8000c8a:	6a2a      	ldr	r2, [r5, #32]
 8000c8c:	69eb      	ldr	r3, [r5, #28]
 8000c8e:	429a      	cmp	r2, r3
 8000c90:	d301      	bcc.n	8000c96 <VectorD4+0x96>
    iqp->q_wrptr = iqp->q_buffer;
 8000c92:	69bb      	ldr	r3, [r7, #24]
 8000c94:	623b      	str	r3, [r7, #32]
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 8000c96:	68eb      	ldr	r3, [r5, #12]
 8000c98:	4543      	cmp	r3, r8
 8000c9a:	d0cc      	beq.n	8000c36 <VectorD4+0x36>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 8000c9c:	681a      	ldr	r2, [r3, #0]
  (void) chSchReadyI(tp);
 8000c9e:	4618      	mov	r0, r3
 8000ca0:	60fa      	str	r2, [r7, #12]
  tqp->p_next->p_prev = (thread_t *)tqp;
 8000ca2:	f8c2 8004 	str.w	r8, [r2, #4]

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->p_state == CH_STATE_QUEUED, "invalid state");

  tp->p_u.rdymsg = msg;
 8000ca6:	f8c3 9020 	str.w	r9, [r3, #32]
  (void) chSchReadyI(tp);
 8000caa:	f7ff ff91 	bl	8000bd0 <chSchReadyI>
      sdIncomingDataI(sdp, b);
    sr = u->SR;
 8000cae:	6834      	ldr	r4, [r6, #0]
 8000cb0:	b2a4      	uxth	r4, r4
    osalSysUnlockFromISR();
  }

  /* Data available.*/
  osalSysLockFromISR();
  while (sr & (USART_SR_RXNE | USART_SR_ORE | USART_SR_NE | USART_SR_FE |
 8000cb2:	f014 0f2f 	tst.w	r4, #47	; 0x2f
 8000cb6:	d1c3      	bne.n	8000c40 <VectorD4+0x40>
 8000cb8:	2300      	movs	r3, #0
 8000cba:	f383 8811 	msr	BASEPRI, r3
    sr = u->SR;
  }
  osalSysUnlockFromISR();

  /* Transmission buffer empty.*/
  if ((cr1 & USART_CR1_TXEIE) && (sr & USART_SR_TXE)) {
 8000cbe:	f01a 0f80 	tst.w	sl, #128	; 0x80
 8000cc2:	d001      	beq.n	8000cc8 <VectorD4+0xc8>
 8000cc4:	0622      	lsls	r2, r4, #24
 8000cc6:	d437      	bmi.n	8000d38 <VectorD4+0x138>
      u->DR = b;
    osalSysUnlockFromISR();
  }

  /* Physical transmission end.*/
  if (sr & USART_SR_TC) {
 8000cc8:	0663      	lsls	r3, r4, #25
 8000cca:	d512      	bpl.n	8000cf2 <VectorD4+0xf2>
 8000ccc:	2320      	movs	r3, #32
 8000cce:	f383 8811 	msr	BASEPRI, r3
static inline bool chOQIsEmptyI(output_queue_t *oqp) {

  chDbgCheckClassI();

  /*lint -save -e9007 [13.5] No side effects.*/
  return (bool)((oqp->q_wrptr == oqp->q_rdptr) && (oqp->q_counter != 0U));
 8000cd2:	6c6a      	ldr	r2, [r5, #68]	; 0x44
 8000cd4:	6cab      	ldr	r3, [r5, #72]	; 0x48
 8000cd6:	4937      	ldr	r1, [pc, #220]	; (8000db4 <VectorD4+0x1b4>)
 8000cd8:	429a      	cmp	r2, r3
 8000cda:	d056      	beq.n	8000d8a <VectorD4+0x18a>
    osalSysLockFromISR();
    if (oqIsEmptyI(&sdp->oqueue))
      chnAddFlagsI(sdp, CHN_TRANSMISSION_END);
    u->CR1 = cr1 & ~USART_CR1_TCIE;
 8000cdc:	f64f 73bf 	movw	r3, #65471	; 0xffbf
    u->SR = ~USART_SR_TC;
 8000ce0:	f06f 0240 	mvn.w	r2, #64	; 0x40
  /* Physical transmission end.*/
  if (sr & USART_SR_TC) {
    osalSysLockFromISR();
    if (oqIsEmptyI(&sdp->oqueue))
      chnAddFlagsI(sdp, CHN_TRANSMISSION_END);
    u->CR1 = cr1 & ~USART_CR1_TCIE;
 8000ce4:	ea0a 0303 	and.w	r3, sl, r3
 8000ce8:	60f3      	str	r3, [r6, #12]
 8000cea:	2300      	movs	r3, #0
    u->SR = ~USART_SR_TC;
 8000cec:	6032      	str	r2, [r6, #0]
 8000cee:	f383 8811 	msr	BASEPRI, r3
  OSAL_IRQ_PROLOGUE();

  serve_interrupt(&SD1);

  OSAL_IRQ_EPILOGUE();
}
 8000cf2:	b002      	add	sp, #8
 8000cf4:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}

  OSAL_IRQ_PROLOGUE();

  serve_interrupt(&SD1);

  OSAL_IRQ_EPILOGUE();
 8000cf8:	f7ff baaa 	b.w	8000250 <_port_irq_epilogue>
 8000cfc:	2004      	movs	r0, #4
 8000cfe:	9301      	str	r3, [sp, #4]
 8000d00:	f000 ffe6 	bl	8001cd0 <chEvtBroadcastFlagsI.constprop.24>
static inline bool chIQIsFullI(input_queue_t *iqp) {

  chDbgCheckClassI();

  /*lint -save -e9007 [13.5] No side effects.*/
  return (bool)((iqp->q_wrptr == iqp->q_rdptr) && (iqp->q_counter != 0U));
 8000d04:	6a29      	ldr	r1, [r5, #32]
 8000d06:	6a6a      	ldr	r2, [r5, #36]	; 0x24
 8000d08:	9b01      	ldr	r3, [sp, #4]
 8000d0a:	4291      	cmp	r1, r2
 8000d0c:	d1b7      	bne.n	8000c7e <VectorD4+0x7e>
 8000d0e:	697a      	ldr	r2, [r7, #20]
 8000d10:	2a00      	cmp	r2, #0
 8000d12:	d0b4      	beq.n	8000c7e <VectorD4+0x7e>
 8000d14:	2080      	movs	r0, #128	; 0x80
 8000d16:	f000 ffdb 	bl	8001cd0 <chEvtBroadcastFlagsI.constprop.24>
 8000d1a:	e78c      	b.n	8000c36 <VectorD4+0x36>
 8000d1c:	2320      	movs	r3, #32
 8000d1e:	f383 8811 	msr	BASEPRI, r3
 8000d22:	f44f 7000 	mov.w	r0, #512	; 0x200
 8000d26:	f000 ffd3 	bl	8001cd0 <chEvtBroadcastFlagsI.constprop.24>

  /* Special case, LIN break detection.*/
  if (sr & USART_SR_LBD) {
    osalSysLockFromISR();
    chnAddFlagsI(sdp, SD_BREAK_DETECTED);
    u->SR = ~USART_SR_LBD;
 8000d2a:	f46f 7380 	mvn.w	r3, #256	; 0x100
 8000d2e:	6033      	str	r3, [r6, #0]
 8000d30:	2300      	movs	r3, #0
 8000d32:	f383 8811 	msr	BASEPRI, r3
 8000d36:	e76f      	b.n	8000c18 <VectorD4+0x18>
 8000d38:	2320      	movs	r3, #32
 8000d3a:	f383 8811 	msr	BASEPRI, r3
static inline bool chOQIsEmptyI(output_queue_t *oqp) {

  chDbgCheckClassI();

  /*lint -save -e9007 [13.5] No side effects.*/
  return (bool)((oqp->q_wrptr == oqp->q_rdptr) && (oqp->q_counter != 0U));
 8000d3e:	6cab      	ldr	r3, [r5, #72]	; 0x48
 8000d40:	6c6a      	ldr	r2, [r5, #68]	; 0x44
 8000d42:	491c      	ldr	r1, [pc, #112]	; (8000db4 <VectorD4+0x1b4>)
 8000d44:	429a      	cmp	r2, r3
 8000d46:	d027      	beq.n	8000d98 <VectorD4+0x198>

  if (chOQIsEmptyI(oqp)) {
    return Q_EMPTY;
  }

  oqp->q_counter++;
 8000d48:	6baa      	ldr	r2, [r5, #56]	; 0x38
  b = *oqp->q_rdptr++;
  if (oqp->q_rdptr >= oqp->q_top) {
 8000d4a:	6c28      	ldr	r0, [r5, #64]	; 0x40
  if (chOQIsEmptyI(oqp)) {
    return Q_EMPTY;
  }

  oqp->q_counter++;
  b = *oqp->q_rdptr++;
 8000d4c:	1c59      	adds	r1, r3, #1

  if (chOQIsEmptyI(oqp)) {
    return Q_EMPTY;
  }

  oqp->q_counter++;
 8000d4e:	3201      	adds	r2, #1
 8000d50:	63aa      	str	r2, [r5, #56]	; 0x38
  b = *oqp->q_rdptr++;
 8000d52:	64a9      	str	r1, [r5, #72]	; 0x48
  if (oqp->q_rdptr >= oqp->q_top) {
 8000d54:	4281      	cmp	r1, r0
  if (chOQIsEmptyI(oqp)) {
    return Q_EMPTY;
  }

  oqp->q_counter++;
  b = *oqp->q_rdptr++;
 8000d56:	781f      	ldrb	r7, [r3, #0]

  if (chOQIsEmptyI(oqp)) {
    return Q_EMPTY;
  }

  oqp->q_counter++;
 8000d58:	4b16      	ldr	r3, [pc, #88]	; (8000db4 <VectorD4+0x1b4>)
  b = *oqp->q_rdptr++;
  if (oqp->q_rdptr >= oqp->q_top) {
 8000d5a:	d301      	bcc.n	8000d60 <VectorD4+0x160>
    oqp->q_rdptr = oqp->q_buffer;
 8000d5c:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 8000d5e:	649a      	str	r2, [r3, #72]	; 0x48
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 8000d60:	4914      	ldr	r1, [pc, #80]	; (8000db4 <VectorD4+0x1b4>)
 8000d62:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 8000d64:	f101 0230 	add.w	r2, r1, #48	; 0x30
 8000d68:	4293      	cmp	r3, r2
 8000d6a:	d009      	beq.n	8000d80 <VectorD4+0x180>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 8000d6c:	6818      	ldr	r0, [r3, #0]

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->p_state == CH_STATE_QUEUED, "invalid state");

  tp->p_u.rdymsg = msg;
 8000d6e:	f04f 0e00 	mov.w	lr, #0
 8000d72:	6308      	str	r0, [r1, #48]	; 0x30
  tqp->p_next->p_prev = (thread_t *)tqp;
 8000d74:	6042      	str	r2, [r0, #4]
  (void) chSchReadyI(tp);
 8000d76:	4618      	mov	r0, r3

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->p_state == CH_STATE_QUEUED, "invalid state");

  tp->p_u.rdymsg = msg;
 8000d78:	f8c3 e020 	str.w	lr, [r3, #32]
  (void) chSchReadyI(tp);
 8000d7c:	f7ff ff28 	bl	8000bd0 <chSchReadyI>
    if (b < Q_OK) {
      chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
      u->CR1 = (cr1 & ~USART_CR1_TXEIE) | USART_CR1_TCIE;
    }
    else
      u->DR = b;
 8000d80:	6077      	str	r7, [r6, #4]
 8000d82:	2300      	movs	r3, #0
 8000d84:	f383 8811 	msr	BASEPRI, r3
 8000d88:	e79e      	b.n	8000cc8 <VectorD4+0xc8>
 8000d8a:	6b8b      	ldr	r3, [r1, #56]	; 0x38
 8000d8c:	2b00      	cmp	r3, #0
 8000d8e:	d0a5      	beq.n	8000cdc <VectorD4+0xdc>
 8000d90:	2010      	movs	r0, #16
 8000d92:	f000 ff9d 	bl	8001cd0 <chEvtBroadcastFlagsI.constprop.24>
 8000d96:	e7a1      	b.n	8000cdc <VectorD4+0xdc>
 8000d98:	6b8a      	ldr	r2, [r1, #56]	; 0x38
 8000d9a:	2a00      	cmp	r2, #0
 8000d9c:	d0d4      	beq.n	8000d48 <VectorD4+0x148>
 8000d9e:	2008      	movs	r0, #8
 8000da0:	f000 ff96 	bl	8001cd0 <chEvtBroadcastFlagsI.constprop.24>
    msg_t b;
    osalSysLockFromISR();
    b = oqGetI(&sdp->oqueue);
    if (b < Q_OK) {
      chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
      u->CR1 = (cr1 & ~USART_CR1_TXEIE) | USART_CR1_TCIE;
 8000da4:	f64f 733f 	movw	r3, #65343	; 0xff3f
 8000da8:	ea0a 0303 	and.w	r3, sl, r3
 8000dac:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8000db0:	60f3      	str	r3, [r6, #12]
 8000db2:	e7e6      	b.n	8000d82 <VectorD4+0x182>
 8000db4:	20000ba0 	.word	0x20000ba0
	...

08000dc0 <Vector88>:
OSAL_IRQ_HANDLER(Vector88) {
  uint32_t sr;

  OSAL_IRQ_PROLOGUE();

  sr = ADC1->SR;
 8000dc0:	4b1f      	ldr	r3, [pc, #124]	; (8000e40 <Vector88+0x80>)
  ADC1->SR = 0;
 8000dc2:	2200      	movs	r2, #0
OSAL_IRQ_HANDLER(Vector88) {
  uint32_t sr;

  OSAL_IRQ_PROLOGUE();

  sr = ADC1->SR;
 8000dc4:	6819      	ldr	r1, [r3, #0]
  ADC1->SR = 0;
 8000dc6:	601a      	str	r2, [r3, #0]
  /* Note, an overflow may occur after the conversion ended before the driver
     is able to stop the ADC, this is why the DMA channel is checked too.*/
  if ((sr & ADC_SR_OVR) && (dmaStreamGetTransactionSize(ADCD1.dmastp) > 0)) {
 8000dc8:	068b      	lsls	r3, r1, #26
 8000dca:	d537      	bpl.n	8000e3c <Vector88+0x7c>
/**
 * @brief   ADC interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector88) {
 8000dcc:	b570      	push	{r4, r5, r6, lr}

  sr = ADC1->SR;
  ADC1->SR = 0;
  /* Note, an overflow may occur after the conversion ended before the driver
     is able to stop the ADC, this is why the DMA channel is checked too.*/
  if ((sr & ADC_SR_OVR) && (dmaStreamGetTransactionSize(ADCD1.dmastp) > 0)) {
 8000dce:	4c1d      	ldr	r4, [pc, #116]	; (8000e44 <Vector88+0x84>)
 8000dd0:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8000dd2:	6859      	ldr	r1, [r3, #4]
 8000dd4:	6848      	ldr	r0, [r1, #4]
 8000dd6:	2800      	cmp	r0, #0
 8000dd8:	d02c      	beq.n	8000e34 <Vector88+0x74>
    /* ADC overflow condition, this could happen only if the DMA is unable
       to read data fast enough.*/
    if (ADCD1.grpp != NULL)
 8000dda:	6925      	ldr	r5, [r4, #16]
 8000ddc:	b355      	cbz	r5, 8000e34 <Vector88+0x74>
 *
 * @notapi
 */
void adc_lld_stop_conversion(ADCDriver *adcp) {

  dmaStreamDisable(adcp->dmastp);
 8000dde:	6808      	ldr	r0, [r1, #0]
     is able to stop the ADC, this is why the DMA channel is checked too.*/
  if ((sr & ADC_SR_OVR) && (dmaStreamGetTransactionSize(ADCD1.dmastp) > 0)) {
    /* ADC overflow condition, this could happen only if the DMA is unable
       to read data fast enough.*/
    if (ADCD1.grpp != NULL)
      _adc_isr_error_code(&ADCD1, ADC_ERR_OVERFLOW);
 8000de0:	68ad      	ldr	r5, [r5, #8]
 *
 * @notapi
 */
void adc_lld_stop_conversion(ADCDriver *adcp) {

  dmaStreamDisable(adcp->dmastp);
 8000de2:	f020 000f 	bic.w	r0, r0, #15
 8000de6:	6008      	str	r0, [r1, #0]
 8000de8:	7c18      	ldrb	r0, [r3, #16]
 8000dea:	681e      	ldr	r6, [r3, #0]
 8000dec:	210f      	movs	r1, #15
  adcp->adc->CR1 = 0;
 8000dee:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 *
 * @notapi
 */
void adc_lld_stop_conversion(ADCDriver *adcp) {

  dmaStreamDisable(adcp->dmastp);
 8000df0:	fa01 f000 	lsl.w	r0, r1, r0
  adcp->adc->CR1 = 0;
  adcp->adc->CR2 = 0;
  adcp->adc->CR2 = ADC_CR2_ADON;
 8000df4:	2101      	movs	r1, #1
 *
 * @notapi
 */
void adc_lld_stop_conversion(ADCDriver *adcp) {

  dmaStreamDisable(adcp->dmastp);
 8000df6:	6070      	str	r0, [r6, #4]
  adcp->adc->CR1 = 0;
 8000df8:	605a      	str	r2, [r3, #4]
  adcp->adc->CR2 = 0;
 8000dfa:	609a      	str	r2, [r3, #8]
  adcp->adc->CR2 = ADC_CR2_ADON;
 8000dfc:	6099      	str	r1, [r3, #8]
     is able to stop the ADC, this is why the DMA channel is checked too.*/
  if ((sr & ADC_SR_OVR) && (dmaStreamGetTransactionSize(ADCD1.dmastp) > 0)) {
    /* ADC overflow condition, this could happen only if the DMA is unable
       to read data fast enough.*/
    if (ADCD1.grpp != NULL)
      _adc_isr_error_code(&ADCD1, ADC_ERR_OVERFLOW);
 8000dfe:	b145      	cbz	r5, 8000e12 <Vector88+0x52>
 8000e00:	2305      	movs	r3, #5
 8000e02:	7023      	strb	r3, [r4, #0]
 8000e04:	4620      	mov	r0, r4
 8000e06:	47a8      	blx	r5
 8000e08:	7823      	ldrb	r3, [r4, #0]
 8000e0a:	2b05      	cmp	r3, #5
 8000e0c:	bf04      	itt	eq
 8000e0e:	2302      	moveq	r3, #2
 8000e10:	7023      	strbeq	r3, [r4, #0]
 8000e12:	2300      	movs	r3, #0
 8000e14:	6123      	str	r3, [r4, #16]
 8000e16:	490b      	ldr	r1, [pc, #44]	; (8000e44 <Vector88+0x84>)
 8000e18:	2220      	movs	r2, #32
 8000e1a:	f382 8811 	msr	BASEPRI, r2
 *
 * @iclass
 */
void chThdResumeI(thread_reference_t *trp, msg_t msg) {

  if (*trp != NULL) {
 8000e1e:	6960      	ldr	r0, [r4, #20]
 8000e20:	b128      	cbz	r0, 8000e2e <Vector88+0x6e>

    chDbgAssert(tp->p_state == CH_STATE_SUSPENDED,
                "not THD_STATE_SUSPENDED");

    *trp = NULL;
    tp->p_u.rdymsg = msg;
 8000e22:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8000e26:	6202      	str	r2, [r0, #32]
    thread_t *tp = *trp;

    chDbgAssert(tp->p_state == CH_STATE_SUSPENDED,
                "not THD_STATE_SUSPENDED");

    *trp = NULL;
 8000e28:	614b      	str	r3, [r1, #20]
    tp->p_u.rdymsg = msg;
    (void) chSchReadyI(tp);
 8000e2a:	f7ff fed1 	bl	8000bd0 <chSchReadyI>
 8000e2e:	2300      	movs	r3, #0
 8000e30:	f383 8811 	msr	BASEPRI, r3
  }
  /* TODO: Add here analog watchdog handling.*/

  OSAL_IRQ_EPILOGUE();
}
 8000e34:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    if (ADCD1.grpp != NULL)
      _adc_isr_error_code(&ADCD1, ADC_ERR_OVERFLOW);
  }
  /* TODO: Add here analog watchdog handling.*/

  OSAL_IRQ_EPILOGUE();
 8000e38:	f7ff ba0a 	b.w	8000250 <_port_irq_epilogue>
 8000e3c:	f7ff ba08 	b.w	8000250 <_port_irq_epilogue>
 8000e40:	40012400 	.word	0x40012400
 8000e44:	200008a8 	.word	0x200008a8
	...

08000e50 <adc_lld_serve_rx_interrupt.lto_priv.34>:
 * @brief   ADC DMA ISR service routine.
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 * @param[in] flags     pre-shifted content of the ISR register
 */
static void adc_lld_serve_rx_interrupt(ADCDriver *adcp, uint32_t flags) {
 8000e50:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}

  /* DMA errors handling.*/
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 8000e54:	070e      	lsls	r6, r1, #28
 * @brief   ADC DMA ISR service routine.
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 * @param[in] flags     pre-shifted content of the ISR register
 */
static void adc_lld_serve_rx_interrupt(ADCDriver *adcp, uint32_t flags) {
 8000e56:	4604      	mov	r4, r0

  /* DMA errors handling.*/
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 8000e58:	d52e      	bpl.n	8000eb8 <adc_lld_serve_rx_interrupt.lto_priv.34+0x68>
 *
 * @notapi
 */
void adc_lld_stop_conversion(ADCDriver *adcp) {

  dmaStreamDisable(adcp->dmastp);
 8000e5a:	6ac3      	ldr	r3, [r0, #44]	; 0x2c

  /* DMA errors handling.*/
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
    /* DMA, this could help only if the DMA tries to access an unmapped
       address space or violates alignment rules.*/
    _adc_isr_error_code(adcp, ADC_ERR_DMAFAILURE);
 8000e5c:	6905      	ldr	r5, [r0, #16]
 *
 * @notapi
 */
void adc_lld_stop_conversion(ADCDriver *adcp) {

  dmaStreamDisable(adcp->dmastp);
 8000e5e:	6859      	ldr	r1, [r3, #4]

  /* DMA errors handling.*/
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
    /* DMA, this could help only if the DMA tries to access an unmapped
       address space or violates alignment rules.*/
    _adc_isr_error_code(adcp, ADC_ERR_DMAFAILURE);
 8000e60:	68ad      	ldr	r5, [r5, #8]
 *
 * @notapi
 */
void adc_lld_stop_conversion(ADCDriver *adcp) {

  dmaStreamDisable(adcp->dmastp);
 8000e62:	680a      	ldr	r2, [r1, #0]
 8000e64:	681f      	ldr	r7, [r3, #0]
 8000e66:	f022 020f 	bic.w	r2, r2, #15
 8000e6a:	600a      	str	r2, [r1, #0]
 8000e6c:	7c19      	ldrb	r1, [r3, #16]
 8000e6e:	220f      	movs	r2, #15
  adcp->adc->CR1 = 0;
 8000e70:	6a83      	ldr	r3, [r0, #40]	; 0x28
 *
 * @notapi
 */
void adc_lld_stop_conversion(ADCDriver *adcp) {

  dmaStreamDisable(adcp->dmastp);
 8000e72:	408a      	lsls	r2, r1
  adcp->adc->CR1 = 0;
  adcp->adc->CR2 = 0;
  adcp->adc->CR2 = ADC_CR2_ADON;
 8000e74:	2601      	movs	r6, #1
 * @notapi
 */
void adc_lld_stop_conversion(ADCDriver *adcp) {

  dmaStreamDisable(adcp->dmastp);
  adcp->adc->CR1 = 0;
 8000e76:	2100      	movs	r1, #0
 *
 * @notapi
 */
void adc_lld_stop_conversion(ADCDriver *adcp) {

  dmaStreamDisable(adcp->dmastp);
 8000e78:	607a      	str	r2, [r7, #4]
  adcp->adc->CR1 = 0;
 8000e7a:	6059      	str	r1, [r3, #4]
  adcp->adc->CR2 = 0;
 8000e7c:	6099      	str	r1, [r3, #8]
  adcp->adc->CR2 = ADC_CR2_ADON;
 8000e7e:	609e      	str	r6, [r3, #8]

  /* DMA errors handling.*/
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
    /* DMA, this could help only if the DMA tries to access an unmapped
       address space or violates alignment rules.*/
    _adc_isr_error_code(adcp, ADC_ERR_DMAFAILURE);
 8000e80:	b13d      	cbz	r5, 8000e92 <adc_lld_serve_rx_interrupt.lto_priv.34+0x42>
 8000e82:	2305      	movs	r3, #5
 8000e84:	7003      	strb	r3, [r0, #0]
 8000e86:	47a8      	blx	r5
 8000e88:	7823      	ldrb	r3, [r4, #0]
 8000e8a:	2b05      	cmp	r3, #5
 8000e8c:	bf04      	itt	eq
 8000e8e:	2302      	moveq	r3, #2
 8000e90:	7023      	strbeq	r3, [r4, #0]
 8000e92:	2200      	movs	r2, #0
 8000e94:	6122      	str	r2, [r4, #16]
 8000e96:	2320      	movs	r3, #32
 8000e98:	f383 8811 	msr	BASEPRI, r3
 *
 * @iclass
 */
void chThdResumeI(thread_reference_t *trp, msg_t msg) {

  if (*trp != NULL) {
 8000e9c:	6963      	ldr	r3, [r4, #20]
 8000e9e:	b133      	cbz	r3, 8000eae <adc_lld_serve_rx_interrupt.lto_priv.34+0x5e>

    chDbgAssert(tp->p_state == CH_STATE_SUSPENDED,
                "not THD_STATE_SUSPENDED");

    *trp = NULL;
    tp->p_u.rdymsg = msg;
 8000ea0:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
    thread_t *tp = *trp;

    chDbgAssert(tp->p_state == CH_STATE_SUSPENDED,
                "not THD_STATE_SUSPENDED");

    *trp = NULL;
 8000ea4:	6162      	str	r2, [r4, #20]
    tp->p_u.rdymsg = msg;
    (void) chSchReadyI(tp);
 8000ea6:	4618      	mov	r0, r3

    chDbgAssert(tp->p_state == CH_STATE_SUSPENDED,
                "not THD_STATE_SUSPENDED");

    *trp = NULL;
    tp->p_u.rdymsg = msg;
 8000ea8:	6219      	str	r1, [r3, #32]
    (void) chSchReadyI(tp);
 8000eaa:	f7ff fe91 	bl	8000bd0 <chSchReadyI>
 8000eae:	2300      	movs	r3, #0
 8000eb0:	f383 8811 	msr	BASEPRI, r3
 8000eb4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  }
  else {
    /* It is possible that the conversion group has already be reset by the
       ADC error handler, in this case this interrupt is spurious.*/
    if (adcp->grpp != NULL) {
 8000eb8:	6903      	ldr	r3, [r0, #16]
 8000eba:	b1ab      	cbz	r3, 8000ee8 <adc_lld_serve_rx_interrupt.lto_priv.34+0x98>
      if ((flags & STM32_DMA_ISR_TCIF) != 0) {
 8000ebc:	078d      	lsls	r5, r1, #30
 8000ebe:	d511      	bpl.n	8000ee4 <adc_lld_serve_rx_interrupt.lto_priv.34+0x94>
        /* Transfer complete processing.*/
        _adc_isr_full_code(adcp);
 8000ec0:	781a      	ldrb	r2, [r3, #0]
 8000ec2:	b1e2      	cbz	r2, 8000efe <adc_lld_serve_rx_interrupt.lto_priv.34+0xae>
 8000ec4:	685d      	ldr	r5, [r3, #4]
 8000ec6:	b17d      	cbz	r5, 8000ee8 <adc_lld_serve_rx_interrupt.lto_priv.34+0x98>
 8000ec8:	68c2      	ldr	r2, [r0, #12]
 8000eca:	2a01      	cmp	r2, #1
 8000ecc:	d943      	bls.n	8000f56 <adc_lld_serve_rx_interrupt.lto_priv.34+0x106>
 8000ece:	885b      	ldrh	r3, [r3, #2]
 8000ed0:	0852      	lsrs	r2, r2, #1
 8000ed2:	fb02 f303 	mul.w	r3, r2, r3
 8000ed6:	6881      	ldr	r1, [r0, #8]
 8000ed8:	eb01 0143 	add.w	r1, r1, r3, lsl #1
 8000edc:	462b      	mov	r3, r5
        /* Half transfer processing.*/
        _adc_isr_half_code(adcp);
      }
    }
  }
}
 8000ede:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    /* It is possible that the conversion group has already be reset by the
       ADC error handler, in this case this interrupt is spurious.*/
    if (adcp->grpp != NULL) {
      if ((flags & STM32_DMA_ISR_TCIF) != 0) {
        /* Transfer complete processing.*/
        _adc_isr_full_code(adcp);
 8000ee2:	4718      	bx	r3
      }
      else if ((flags & STM32_DMA_ISR_HTIF) != 0) {
 8000ee4:	074a      	lsls	r2, r1, #29
 8000ee6:	d401      	bmi.n	8000eec <adc_lld_serve_rx_interrupt.lto_priv.34+0x9c>
 8000ee8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        /* Half transfer processing.*/
        _adc_isr_half_code(adcp);
 8000eec:	685b      	ldr	r3, [r3, #4]
 8000eee:	2b00      	cmp	r3, #0
 8000ef0:	d0fa      	beq.n	8000ee8 <adc_lld_serve_rx_interrupt.lto_priv.34+0x98>
      }
    }
  }
}
 8000ef2:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
        /* Transfer complete processing.*/
        _adc_isr_full_code(adcp);
      }
      else if ((flags & STM32_DMA_ISR_HTIF) != 0) {
        /* Half transfer processing.*/
        _adc_isr_half_code(adcp);
 8000ef6:	68c2      	ldr	r2, [r0, #12]
 8000ef8:	6881      	ldr	r1, [r0, #8]
 8000efa:	0852      	lsrs	r2, r2, #1
 8000efc:	4718      	bx	r3
 *
 * @notapi
 */
void adc_lld_stop_conversion(ADCDriver *adcp) {

  dmaStreamDisable(adcp->dmastp);
 8000efe:	6ac1      	ldr	r1, [r0, #44]	; 0x2c
    /* It is possible that the conversion group has already be reset by the
       ADC error handler, in this case this interrupt is spurious.*/
    if (adcp->grpp != NULL) {
      if ((flags & STM32_DMA_ISR_TCIF) != 0) {
        /* Transfer complete processing.*/
        _adc_isr_full_code(adcp);
 8000f00:	685d      	ldr	r5, [r3, #4]
 *
 * @notapi
 */
void adc_lld_stop_conversion(ADCDriver *adcp) {

  dmaStreamDisable(adcp->dmastp);
 8000f02:	684e      	ldr	r6, [r1, #4]
 8000f04:	680f      	ldr	r7, [r1, #0]
 8000f06:	6833      	ldr	r3, [r6, #0]
 8000f08:	f023 030f 	bic.w	r3, r3, #15
 8000f0c:	6033      	str	r3, [r6, #0]
 8000f0e:	7c0e      	ldrb	r6, [r1, #16]
  adcp->adc->CR1 = 0;
 8000f10:	6a83      	ldr	r3, [r0, #40]	; 0x28
 *
 * @notapi
 */
void adc_lld_stop_conversion(ADCDriver *adcp) {

  dmaStreamDisable(adcp->dmastp);
 8000f12:	210f      	movs	r1, #15
 8000f14:	40b1      	lsls	r1, r6
  adcp->adc->CR1 = 0;
  adcp->adc->CR2 = 0;
  adcp->adc->CR2 = ADC_CR2_ADON;
 8000f16:	2601      	movs	r6, #1
 *
 * @notapi
 */
void adc_lld_stop_conversion(ADCDriver *adcp) {

  dmaStreamDisable(adcp->dmastp);
 8000f18:	6079      	str	r1, [r7, #4]
  adcp->adc->CR1 = 0;
 8000f1a:	605a      	str	r2, [r3, #4]
  adcp->adc->CR2 = 0;
 8000f1c:	609a      	str	r2, [r3, #8]
  adcp->adc->CR2 = ADC_CR2_ADON;
 8000f1e:	609e      	str	r6, [r3, #8]
    /* It is possible that the conversion group has already be reset by the
       ADC error handler, in this case this interrupt is spurious.*/
    if (adcp->grpp != NULL) {
      if ((flags & STM32_DMA_ISR_TCIF) != 0) {
        /* Transfer complete processing.*/
        _adc_isr_full_code(adcp);
 8000f20:	b1a5      	cbz	r5, 8000f4c <adc_lld_serve_rx_interrupt.lto_priv.34+0xfc>
 8000f22:	2304      	movs	r3, #4
 8000f24:	7003      	strb	r3, [r0, #0]
 8000f26:	68c2      	ldr	r2, [r0, #12]
 8000f28:	6881      	ldr	r1, [r0, #8]
 8000f2a:	47a8      	blx	r5
 8000f2c:	7823      	ldrb	r3, [r4, #0]
 8000f2e:	2b04      	cmp	r3, #4
 8000f30:	d00c      	beq.n	8000f4c <adc_lld_serve_rx_interrupt.lto_priv.34+0xfc>
 8000f32:	2320      	movs	r3, #32
 8000f34:	f383 8811 	msr	BASEPRI, r3
 *
 * @iclass
 */
void chThdResumeI(thread_reference_t *trp, msg_t msg) {

  if (*trp != NULL) {
 8000f38:	6963      	ldr	r3, [r4, #20]
 8000f3a:	2b00      	cmp	r3, #0
 8000f3c:	d0b7      	beq.n	8000eae <adc_lld_serve_rx_interrupt.lto_priv.34+0x5e>
    thread_t *tp = *trp;

    chDbgAssert(tp->p_state == CH_STATE_SUSPENDED,
                "not THD_STATE_SUSPENDED");

    *trp = NULL;
 8000f3e:	2200      	movs	r2, #0
 8000f40:	6162      	str	r2, [r4, #20]
    tp->p_u.rdymsg = msg;
    (void) chSchReadyI(tp);
 8000f42:	4618      	mov	r0, r3

    chDbgAssert(tp->p_state == CH_STATE_SUSPENDED,
                "not THD_STATE_SUSPENDED");

    *trp = NULL;
    tp->p_u.rdymsg = msg;
 8000f44:	621a      	str	r2, [r3, #32]
    (void) chSchReadyI(tp);
 8000f46:	f7ff fe43 	bl	8000bd0 <chSchReadyI>
 8000f4a:	e7b0      	b.n	8000eae <adc_lld_serve_rx_interrupt.lto_priv.34+0x5e>
 8000f4c:	2202      	movs	r2, #2
 8000f4e:	2300      	movs	r3, #0
 8000f50:	7022      	strb	r2, [r4, #0]
 8000f52:	6123      	str	r3, [r4, #16]
 8000f54:	e7ed      	b.n	8000f32 <adc_lld_serve_rx_interrupt.lto_priv.34+0xe2>
 8000f56:	462b      	mov	r3, r5
        /* Half transfer processing.*/
        _adc_isr_half_code(adcp);
      }
    }
  }
}
 8000f58:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    /* It is possible that the conversion group has already be reset by the
       ADC error handler, in this case this interrupt is spurious.*/
    if (adcp->grpp != NULL) {
      if ((flags & STM32_DMA_ISR_TCIF) != 0) {
        /* Transfer complete processing.*/
        _adc_isr_full_code(adcp);
 8000f5c:	6881      	ldr	r1, [r0, #8]
 8000f5e:	4718      	bx	r3

08000f60 <chThdExit>:
 *
 * @param[in] msg       thread exit code
 *
 * @api
 */
void chThdExit(msg_t msg) {
 8000f60:	b538      	push	{r3, r4, r5, lr}
 8000f62:	2220      	movs	r2, #32
 8000f64:	4603      	mov	r3, r0
 8000f66:	f382 8811 	msr	BASEPRI, r2
 * @param[in] msg       thread exit code
 *
 * @sclass
 */
void chThdExitS(msg_t msg) {
  thread_t *tp = currp;
 8000f6a:	4a0e      	ldr	r2, [pc, #56]	; (8000fa4 <chThdExit+0x44>)
 8000f6c:	6994      	ldr	r4, [r2, #24]
 *
 * @notapi
 */
static inline bool list_notempty(threads_list_t *tlp) {

  return (bool)(tlp->p_next != (thread_t *)tlp);
 8000f6e:	6a60      	ldr	r0, [r4, #36]	; 0x24
  tp->p_u.exitcode = msg;
#if defined(CH_CFG_THREAD_EXIT_HOOK)
  CH_CFG_THREAD_EXIT_HOOK(tp);
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  while (list_notempty(&tp->p_waiting)) {
 8000f70:	f104 0524 	add.w	r5, r4, #36	; 0x24
 8000f74:	4285      	cmp	r5, r0
 * @sclass
 */
void chThdExitS(msg_t msg) {
  thread_t *tp = currp;

  tp->p_u.exitcode = msg;
 8000f76:	6223      	str	r3, [r4, #32]
#if defined(CH_CFG_THREAD_EXIT_HOOK)
  CH_CFG_THREAD_EXIT_HOOK(tp);
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  while (list_notempty(&tp->p_waiting)) {
 8000f78:	d006      	beq.n	8000f88 <chThdExit+0x28>
}

static inline thread_t *list_remove(threads_list_t *tlp) {

  thread_t *tp = tlp->p_next;
  tlp->p_next = tp->p_next;
 8000f7a:	6803      	ldr	r3, [r0, #0]
 8000f7c:	6263      	str	r3, [r4, #36]	; 0x24
    (void) chSchReadyI(list_remove(&tp->p_waiting));
 8000f7e:	f7ff fe27 	bl	8000bd0 <chSchReadyI>
 *
 * @notapi
 */
static inline bool list_notempty(threads_list_t *tlp) {

  return (bool)(tlp->p_next != (thread_t *)tlp);
 8000f82:	6a60      	ldr	r0, [r4, #36]	; 0x24
  tp->p_u.exitcode = msg;
#if defined(CH_CFG_THREAD_EXIT_HOOK)
  CH_CFG_THREAD_EXIT_HOOK(tp);
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  while (list_notempty(&tp->p_waiting)) {
 8000f84:	42a8      	cmp	r0, r5
 8000f86:	d1f8      	bne.n	8000f7a <chThdExit+0x1a>
  }
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  /* Static threads are immediately removed from the registry because
     there is no memory to recover.*/
  if ((tp->p_flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC) {
 8000f88:	7f63      	ldrb	r3, [r4, #29]
 8000f8a:	079b      	lsls	r3, r3, #30
 8000f8c:	d104      	bne.n	8000f98 <chThdExit+0x38>
    REG_REMOVE(tp);
 8000f8e:	6922      	ldr	r2, [r4, #16]
 8000f90:	6963      	ldr	r3, [r4, #20]
 8000f92:	611a      	str	r2, [r3, #16]
 8000f94:	6922      	ldr	r2, [r4, #16]
 8000f96:	6153      	str	r3, [r2, #20]
  }
#endif
  chSchGoSleepS(CH_STATE_FINAL);
 8000f98:	200f      	movs	r0, #15
void chThdExit(msg_t msg) {

  chSysLock();
  chThdExitS(msg);
  /* The thread never returns here.*/
}
 8000f9a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
     there is no memory to recover.*/
  if ((tp->p_flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC) {
    REG_REMOVE(tp);
  }
#endif
  chSchGoSleepS(CH_STATE_FINAL);
 8000f9e:	f7ff bc17 	b.w	80007d0 <chSchGoSleepS>
 8000fa2:	bf00      	nop
 8000fa4:	20000c18 	.word	0x20000c18
	...

08000fb0 <__init_ram_areas>:
}

/**
 * @brief   Performs the initialization of the various RAM areas.
 */
void __init_ram_areas(void) {
 8000fb0:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000fb2:	4f13      	ldr	r7, [pc, #76]	; (8001000 <__init_ram_areas+0x50>)
 8000fb4:	4d13      	ldr	r5, [pc, #76]	; (8001004 <__init_ram_areas+0x54>)
 8000fb6:	4c14      	ldr	r4, [pc, #80]	; (8001008 <__init_ram_areas+0x58>)
 8000fb8:	4b14      	ldr	r3, [pc, #80]	; (800100c <__init_ram_areas+0x5c>)
 8000fba:	4915      	ldr	r1, [pc, #84]	; (8001010 <__init_ram_areas+0x60>)
 8000fbc:	f107 0e70 	add.w	lr, r7, #112	; 0x70
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
      *p = 0;
 8000fc0:	2600      	movs	r6, #0
  do {
    uint32_t *tp = rap->init_text_area;
    uint32_t *p = rap->init_area;

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
 8000fc2:	429c      	cmp	r4, r3
 8000fc4:	d911      	bls.n	8000fea <__init_ram_areas+0x3a>
 8000fc6:	461a      	mov	r2, r3
 8000fc8:	3904      	subs	r1, #4
      *p = *tp;
 8000fca:	f851 0f04 	ldr.w	r0, [r1, #4]!
 8000fce:	f842 0b04 	str.w	r0, [r2], #4
  do {
    uint32_t *tp = rap->init_text_area;
    uint32_t *p = rap->init_area;

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
 8000fd2:	4294      	cmp	r4, r2
 8000fd4:	d8f9      	bhi.n	8000fca <__init_ram_areas+0x1a>
 8000fd6:	43da      	mvns	r2, r3
 8000fd8:	4414      	add	r4, r2
 8000fda:	f024 0403 	bic.w	r4, r4, #3
 8000fde:	3404      	adds	r4, #4
 8000fe0:	4423      	add	r3, r4
      p++;
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
 8000fe2:	429d      	cmp	r5, r3
 8000fe4:	d903      	bls.n	8000fee <__init_ram_areas+0x3e>
      *p = 0;
 8000fe6:	f843 6b04 	str.w	r6, [r3], #4
      p++;
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
 8000fea:	429d      	cmp	r5, r3
 8000fec:	d8fb      	bhi.n	8000fe6 <__init_ram_areas+0x36>
      *p = 0;
      p++;
    }
    rap++;
  }
  while (rap < &ram_areas[CRT1_AREAS_NUMBER]);
 8000fee:	4577      	cmp	r7, lr
 8000ff0:	d005      	beq.n	8000ffe <__init_ram_areas+0x4e>
 8000ff2:	6939      	ldr	r1, [r7, #16]
 8000ff4:	697b      	ldr	r3, [r7, #20]
 8000ff6:	69bc      	ldr	r4, [r7, #24]
 8000ff8:	69fd      	ldr	r5, [r7, #28]
 8000ffa:	3710      	adds	r7, #16
 8000ffc:	e7e1      	b.n	8000fc2 <__init_ram_areas+0x12>
 8000ffe:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8001000:	08001e20 	.word	0x08001e20
 8001004:	20000d68 	.word	0x20000d68
 8001008:	20000d68 	.word	0x20000d68
 800100c:	20000d68 	.word	0x20000d68
 8001010:	080020b8 	.word	0x080020b8
	...

08001020 <__default_exit>:
 */
#if !defined(__DOXYGEN__)
__attribute__((noreturn, weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __default_exit(void) {
 8001020:	e7fe      	b.n	8001020 <__default_exit>
 8001022:	bf00      	nop
	...

08001030 <__late_init>:
 8001030:	4770      	bx	lr
 8001032:	bf00      	nop
	...

08001040 <__core_init>:
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __core_init(void) {
 8001040:	4770      	bx	lr
 8001042:	bf00      	nop
	...

08001050 <Thread2>:

  (void)arg;

  chRegSetThreadName("blinker");
  while (true) {
    palSetPad(GPIOB, GPIOB_LED3);
 8001050:	2580      	movs	r5, #128	; 0x80
 8001052:	462e      	mov	r6, r5

/*
 * Blinker thread #2.
 */
static THD_WORKING_AREA(waThread2, 128);
static THD_FUNCTION(Thread2, arg) {
 8001054:	b508      	push	{r3, lr}
 * @api
 */
static inline void chRegSetThreadName(const char *name) {

#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.r_current->p_name = name;
 8001056:	4b08      	ldr	r3, [pc, #32]	; (8001078 <Thread2+0x28>)
 8001058:	4a08      	ldr	r2, [pc, #32]	; (800107c <Thread2+0x2c>)
 800105a:	699b      	ldr	r3, [r3, #24]

  (void)arg;

  chRegSetThreadName("blinker");
  while (true) {
    palSetPad(GPIOB, GPIOB_LED3);
 800105c:	4c08      	ldr	r4, [pc, #32]	; (8001080 <Thread2+0x30>)
 800105e:	619a      	str	r2, [r3, #24]
 8001060:	8326      	strh	r6, [r4, #24]
    chThdSleepMilliseconds(1000);
 8001062:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8001066:	f7ff fda3 	bl	8000bb0 <chThdSleep>
    palClearPad(GPIOB, GPIOB_LED3);
 800106a:	8365      	strh	r5, [r4, #26]
    chThdSleepMilliseconds(1000);
 800106c:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8001070:	f7ff fd9e 	bl	8000bb0 <chThdSleep>
 8001074:	e7f4      	b.n	8001060 <Thread2+0x10>
 8001076:	bf00      	nop
 8001078:	20000c18 	.word	0x20000c18
 800107c:	08001f90 	.word	0x08001f90
 8001080:	40020400 	.word	0x40020400
	...

08001090 <Thread1>:

/*
 * Blinker thread #1.
 */
static THD_WORKING_AREA(waThread1, 128);
static THD_FUNCTION(Thread1, arg) {
 8001090:	e92d 4880 	stmdb	sp!, {r7, fp, lr}
 8001094:	4f79      	ldr	r7, [pc, #484]	; (800127c <Thread1+0x1ec>)
 8001096:	4d7a      	ldr	r5, [pc, #488]	; (8001280 <Thread1+0x1f0>)
 8001098:	69bb      	ldr	r3, [r7, #24]
 800109a:	4a7a      	ldr	r2, [pc, #488]	; (8001284 <Thread1+0x1f4>)
 800109c:	f8df a20c 	ldr.w	sl, [pc, #524]	; 80012ac <Thread1+0x21c>
 80010a0:	b08b      	sub	sp, #44	; 0x2c
 80010a2:	619a      	str	r2, [r3, #24]
 80010a4:	f105 0618 	add.w	r6, r5, #24
 80010a8:	f105 0914 	add.w	r9, r5, #20
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 80010ac:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 80010b0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
{
  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
}

void TestThread(void *p) {//500-530 normal value, 1000 - heart beat value
	int curtime = osalOsGetSystemTimeX();
 80010b2:	2410      	movs	r4, #16
 80010b4:	b29b      	uxth	r3, r3
 80010b6:	9300      	str	r3, [sp, #0]
 80010b8:	2320      	movs	r3, #32
 80010ba:	f383 8811 	msr	BASEPRI, r3

  chDbgCheckClassS();
  chDbgCheck(mp != NULL);

  /* Is the mutex already locked? */
  if (mp->m_owner != NULL) {
 80010be:	6a2a      	ldr	r2, [r5, #32]
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxLockS(mutex_t *mp) {
  thread_t *ctp = currp;
 80010c0:	f8d7 8018 	ldr.w	r8, [r7, #24]

  chDbgCheckClassS();
  chDbgCheck(mp != NULL);

  /* Is the mutex already locked? */
  if (mp->m_owner != NULL) {
 80010c4:	2a00      	cmp	r2, #0
 80010c6:	f000 8206 	beq.w	80014d6 <Thread1+0x446>
         priority of the running thread requesting the mutex.*/
      thread_t *tp = mp->m_owner;

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->p_prio < ctp->p_prio) {
 80010ca:	f8d8 0008 	ldr.w	r0, [r8, #8]
 80010ce:	6893      	ldr	r3, [r2, #8]
 80010d0:	4283      	cmp	r3, r0
 80010d2:	d210      	bcs.n	80010f6 <Thread1+0x66>
        /* Make priority of thread tp match the running thread's priority.*/
        tp->p_prio = ctp->p_prio;

        /* The following states need priority queues reordering.*/
        switch (tp->p_state) {
 80010d4:	7f13      	ldrb	r3, [r2, #28]

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->p_prio < ctp->p_prio) {
        /* Make priority of thread tp match the running thread's priority.*/
        tp->p_prio = ctp->p_prio;
 80010d6:	6090      	str	r0, [r2, #8]

        /* The following states need priority queues reordering.*/
        switch (tp->p_state) {
 80010d8:	2b06      	cmp	r3, #6
 80010da:	f000 81db 	beq.w	8001494 <Thread1+0x404>
 80010de:	2b07      	cmp	r3, #7
 80010e0:	f000 81bf 	beq.w	8001462 <Thread1+0x3d2>
 80010e4:	b93b      	cbnz	r3, 80010f6 <Thread1+0x66>
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->p_prev->p_next = tp->p_next;
 80010e6:	6813      	ldr	r3, [r2, #0]
 80010e8:	6851      	ldr	r1, [r2, #4]
#if CH_DBG_ENABLE_ASSERTS == TRUE
          /* Prevents an assertion in chSchReadyI().*/
          tp->p_state = CH_STATE_CURRENT;
#endif
          /* Re-enqueues tp with its new priority on the ready list.*/
          (void) chSchReadyI(queue_dequeue(tp));
 80010ea:	4610      	mov	r0, r2
 80010ec:	600b      	str	r3, [r1, #0]
  tp->p_next->p_prev = tp->p_prev;
 80010ee:	6813      	ldr	r3, [r2, #0]
 80010f0:	6059      	str	r1, [r3, #4]
 80010f2:	f7ff fd6d 	bl	8000bd0 <chSchReadyI>
  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
 80010f6:	4b64      	ldr	r3, [pc, #400]	; (8001288 <Thread1+0x1f8>)
 80010f8:	e004      	b.n	8001104 <Thread1+0x74>
  do {
    cp = cp->p_next;
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 80010fa:	6899      	ldr	r1, [r3, #8]
 80010fc:	f8d8 2008 	ldr.w	r2, [r8, #8]
 8001100:	4291      	cmp	r1, r2
 8001102:	d302      	bcc.n	800110a <Thread1+0x7a>

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
 8001104:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 8001106:	42b3      	cmp	r3, r6
 8001108:	d1f7      	bne.n	80010fa <Thread1+0x6a>
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 800110a:	685a      	ldr	r2, [r3, #4]
      }

      /* Sleep on the mutex.*/
      queue_prio_insert(ctp, &mp->m_queue);
      ctp->p_u.wtmtxp = mp;
      chSchGoSleepS(CH_STATE_WTMTX);
 800110c:	2006      	movs	r0, #6

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
  tp->p_next = cp;
 800110e:	f8c8 3000 	str.w	r3, [r8]
  tp->p_prev = cp->p_prev;
 8001112:	f8c8 2004 	str.w	r2, [r8, #4]
  tp->p_prev->p_next = tp;
 8001116:	f8c2 8000 	str.w	r8, [r2]
  cp->p_prev = tp;
 800111a:	f8c3 8004 	str.w	r8, [r3, #4]
        break;
      }

      /* Sleep on the mutex.*/
      queue_prio_insert(ctp, &mp->m_queue);
      ctp->p_u.wtmtxp = mp;
 800111e:	f8c8 6020 	str.w	r6, [r8, #32]
      chSchGoSleepS(CH_STATE_WTMTX);
 8001122:	f7ff fb55 	bl	80007d0 <chSchGoSleepS>
 8001126:	f04f 0800 	mov.w	r8, #0
 800112a:	f388 8811 	msr	BASEPRI, r8
 800112e:	f04f 0b20 	mov.w	fp, #32
 8001132:	f38b 8811 	msr	BASEPRI, fp

  /* The start method is different dependign if HW or SW triggered, the
     start is performed using the method specified in the CR2 configuration.*/
  if ((cr2 & ADC_CR2_SWSTART) != 0) {
    /* Initializing CR2 while keeping ADC_CR2_SWSTART at zero.*/
    adcp->adc->CR2 = (cr2 | ADC_CR2_CONT) & ~ADC_CR2_SWSTART;
 8001136:	f240 3e13 	movw	lr, #787	; 0x313
      /* If circular buffer depth > 1, then the half transfer interrupt
         is enabled in order to allow streaming processing.*/
      mode |= STM32_DMA_CR_HTIE;
    }
  }
  dmaStreamSetMemory0(adcp->dmastp, adcp->samples);
 800113a:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
                (adcp->state == ADC_ERROR),
                "not ready");

  adcp->samples  = samples;
  adcp->depth    = depth;
  adcp->grpp     = grpp;
 800113c:	4853      	ldr	r0, [pc, #332]	; (800128c <Thread1+0x1fc>)
 800113e:	685a      	ldr	r2, [r3, #4]
  uint32_t mode;
  uint32_t cr2;
  const ADCConversionGroup *grpp = adcp->grpp;

  /* DMA setup.*/
  mode = adcp->dmamode;
 8001140:	6b29      	ldr	r1, [r5, #48]	; 0x30
 8001142:	6128      	str	r0, [r5, #16]
                (adcp->state == ADC_COMPLETE) ||
                (adcp->state == ADC_ERROR),
                "not ready");

  adcp->samples  = samples;
  adcp->depth    = depth;
 8001144:	2310      	movs	r3, #16
  osalDbgAssert((adcp->state == ADC_READY) ||
                (adcp->state == ADC_COMPLETE) ||
                (adcp->state == ADC_ERROR),
                "not ready");

  adcp->samples  = samples;
 8001146:	a802      	add	r0, sp, #8
  adcp->depth    = depth;
 8001148:	60eb      	str	r3, [r5, #12]
  osalDbgAssert((adcp->state == ADC_READY) ||
                (adcp->state == ADC_COMPLETE) ||
                (adcp->state == ADC_ERROR),
                "not ready");

  adcp->samples  = samples;
 800114a:	60a8      	str	r0, [r5, #8]
      /* If circular buffer depth > 1, then the half transfer interrupt
         is enabled in order to allow streaming processing.*/
      mode |= STM32_DMA_CR_HTIE;
    }
  }
  dmaStreamSetMemory0(adcp->dmastp, adcp->samples);
 800114c:	60d0      	str	r0, [r2, #12]
  adcp->depth    = depth;
  adcp->grpp     = grpp;
  adcp->state    = ADC_ACTIVE;
 800114e:	2003      	movs	r0, #3
  dmaStreamSetTransactionSize(adcp->dmastp, (uint32_t)grpp->num_channels *
 8001150:	6053      	str	r3, [r2, #4]
 8001152:	7028      	strb	r0, [r5, #0]
                                            (uint32_t)adcp->depth);
  dmaStreamSetMode(adcp->dmastp, mode);
 8001154:	6011      	str	r1, [r2, #0]
  dmaStreamEnable(adcp->dmastp);
 8001156:	6811      	ldr	r1, [r2, #0]

  /* ADC setup.*/
  adcp->adc->SR    = 0;
 8001158:	6aab      	ldr	r3, [r5, #40]	; 0x28
  }
  dmaStreamSetMemory0(adcp->dmastp, adcp->samples);
  dmaStreamSetTransactionSize(adcp->dmastp, (uint32_t)grpp->num_channels *
                                            (uint32_t)adcp->depth);
  dmaStreamSetMode(adcp->dmastp, mode);
  dmaStreamEnable(adcp->dmastp);
 800115a:	f041 0101 	orr.w	r1, r1, #1
 800115e:	6011      	str	r1, [r2, #0]

  /* ADC setup.*/
  adcp->adc->SR    = 0;
  adcp->adc->SMPR1 = grpp->smpr1;
  adcp->adc->SMPR2 = grpp->smpr2;
  adcp->adc->SMPR3 = grpp->smpr3;
 8001160:	2102      	movs	r1, #2
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8001162:	69ba      	ldr	r2, [r7, #24]
                                            (uint32_t)adcp->depth);
  dmaStreamSetMode(adcp->dmastp, mode);
  dmaStreamEnable(adcp->dmastp);

  /* ADC setup.*/
  adcp->adc->SR    = 0;
 8001164:	f8c3 8000 	str.w	r8, [r3]
  adcp->adc->SMPR1 = grpp->smpr1;
 8001168:	f8c3 800c 	str.w	r8, [r3, #12]
  adcp->adc->SMPR2 = grpp->smpr2;
 800116c:	f8c3 8010 	str.w	r8, [r3, #16]
  adcp->adc->SMPR3 = grpp->smpr3;
 8001170:	6159      	str	r1, [r3, #20]
  adcp->adc->SQR1  = grpp->sqr1;
  adcp->adc->SQR2  = grpp->sqr2;
  adcp->adc->SQR3  = grpp->sqr3;
  adcp->adc->SQR4  = grpp->sqr4;
  adcp->adc->SQR5  = grpp->sqr5;
 8001172:	2101      	movs	r1, #1
  /* ADC setup.*/
  adcp->adc->SR    = 0;
  adcp->adc->SMPR1 = grpp->smpr1;
  adcp->adc->SMPR2 = grpp->smpr2;
  adcp->adc->SMPR3 = grpp->smpr3;
  adcp->adc->SQR1  = grpp->sqr1;
 8001174:	f8c3 8030 	str.w	r8, [r3, #48]	; 0x30
  adcp->adc->SQR2  = grpp->sqr2;
 8001178:	f8c3 8034 	str.w	r8, [r3, #52]	; 0x34
  adcp->adc->SQR3  = grpp->sqr3;
 800117c:	f8c3 8038 	str.w	r8, [r3, #56]	; 0x38
  adcp->adc->SQR4  = grpp->sqr4;
 8001180:	f8c3 803c 	str.w	r8, [r3, #60]	; 0x3c
  adcp->adc->SQR5  = grpp->sqr5;
 8001184:	6419      	str	r1, [r3, #64]	; 0x40

  /* ADC configuration and start.*/
  adcp->adc->CR1   = grpp->cr1 | ADC_CR1_OVRIE | ADC_CR1_SCAN;
 8001186:	4942      	ldr	r1, [pc, #264]	; (8001290 <Thread1+0x200>)
 8001188:	6059      	str	r1, [r3, #4]
  if ((cr2 & ADC_CR2_SWSTART) != 0) {
    /* Initializing CR2 while keeping ADC_CR2_SWSTART at zero.*/
    adcp->adc->CR2 = (cr2 | ADC_CR2_CONT) & ~ADC_CR2_SWSTART;

    /* Finally enabling ADC_CR2_SWSTART.*/
    adcp->adc->CR2 = (cr2 | ADC_CR2_CONT);
 800118a:	4942      	ldr	r1, [pc, #264]	; (8001294 <Thread1+0x204>)

  /* The start method is different dependign if HW or SW triggered, the
     start is performed using the method specified in the CR2 configuration.*/
  if ((cr2 & ADC_CR2_SWSTART) != 0) {
    /* Initializing CR2 while keeping ADC_CR2_SWSTART at zero.*/
    adcp->adc->CR2 = (cr2 | ADC_CR2_CONT) & ~ADC_CR2_SWSTART;
 800118c:	f8c3 e008 	str.w	lr, [r3, #8]

    /* Finally enabling ADC_CR2_SWSTART.*/
    adcp->adc->CR2 = (cr2 | ADC_CR2_CONT);
 8001190:	6099      	str	r1, [r3, #8]
  thread_t *tp = chThdGetSelfX();

  chDbgAssert(*trp == NULL, "not NULL");

  *trp = tp;
  tp->p_u.wttrp = trp;
 8001192:	f8c2 9020 	str.w	r9, [r2, #32]
msg_t chThdSuspendS(thread_reference_t *trp) {
  thread_t *tp = chThdGetSelfX();

  chDbgAssert(*trp == NULL, "not NULL");

  *trp = tp;
 8001196:	616a      	str	r2, [r5, #20]
  tp->p_u.wttrp = trp;
  chSchGoSleepS(CH_STATE_SUSPENDED);
 8001198:	f7ff fb1a 	bl	80007d0 <chSchGoSleepS>
 800119c:	f388 8811 	msr	BASEPRI, r8
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxUnlock(mutex_t *mp) {
  thread_t *ctp = currp;
 80011a0:	69b8      	ldr	r0, [r7, #24]
 80011a2:	f38b 8811 	msr	BASEPRI, fp
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 80011a6:	f8d5 e018 	ldr.w	lr, [r5, #24]
    chDbgAssert(ctp->p_mtxlist == mp, "not next in list");

    /* Removes the top mutex from the thread's owned mutexes list and marks
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    ctp->p_mtxlist = mp->m_next;
 80011aa:	6a6b      	ldr	r3, [r5, #36]	; 0x24

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
 80011ac:	45b6      	cmp	lr, r6
    chDbgAssert(ctp->p_mtxlist == mp, "not next in list");

    /* Removes the top mutex from the thread's owned mutexes list and marks
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    ctp->p_mtxlist = mp->m_next;
 80011ae:	6383      	str	r3, [r0, #56]	; 0x38

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
 80011b0:	f000 818d 	beq.w	80014ce <Thread1+0x43e>
      thread_t *tp;

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->p_realprio;
 80011b4:	6bc1      	ldr	r1, [r0, #60]	; 0x3c
      lmp = ctp->p_mtxlist;
      while (lmp != NULL) {
 80011b6:	b14b      	cbz	r3, 80011cc <Thread1+0x13c>
 80011b8:	681a      	ldr	r2, [r3, #0]
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
 80011ba:	4293      	cmp	r3, r2
 80011bc:	d003      	beq.n	80011c6 <Thread1+0x136>
            (lmp->m_queue.p_next->p_prio > newprio)) {
 80011be:	6892      	ldr	r2, [r2, #8]
 80011c0:	4291      	cmp	r1, r2
 80011c2:	bf38      	it	cc
 80011c4:	4611      	movcc	r1, r2
          newprio = lmp->m_queue.p_next->p_prio;
        }
        lmp = lmp->m_next;
 80011c6:	68db      	ldr	r3, [r3, #12]

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->p_realprio;
      lmp = ctp->p_mtxlist;
      while (lmp != NULL) {
 80011c8:	2b00      	cmp	r3, #0
 80011ca:	d1f5      	bne.n	80011b8 <Thread1+0x128>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 80011cc:	f8de 3000 	ldr.w	r3, [lr]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->m_cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->m_queue);
      mp->m_owner = tp;
      mp->m_next = tp->p_mtxlist;
 80011d0:	f8de 2038 	ldr.w	r2, [lr, #56]	; 0x38
        lmp = lmp->m_next;
      }

      /* Assigns to the current thread the highest priority among all the
         waiting threads.*/
      ctp->p_prio = newprio;
 80011d4:	6081      	str	r1, [r0, #8]
 80011d6:	61ab      	str	r3, [r5, #24]

      /* Note, not using chSchWakeupS() becuase that function expects the
         current thread to have the higher or equal priority than the ones
         in the ready list. This is not necessarily true here because we
         just changed priority.*/
      (void) chSchReadyI(tp);
 80011d8:	4670      	mov	r0, lr
  tqp->p_next->p_prev = (thread_t *)tqp;
 80011da:	605e      	str	r6, [r3, #4]
      mp->m_cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->m_queue);
      mp->m_owner = tp;
      mp->m_next = tp->p_mtxlist;
      tp->p_mtxlist = mp;
 80011dc:	f8ce 6038 	str.w	r6, [lr, #56]	; 0x38
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->m_cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->m_queue);
      mp->m_owner = tp;
      mp->m_next = tp->p_mtxlist;
 80011e0:	626a      	str	r2, [r5, #36]	; 0x24
         assigns the mutex to it.*/
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->m_cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->m_queue);
      mp->m_owner = tp;
 80011e2:	f8c5 e020 	str.w	lr, [r5, #32]

      /* Note, not using chSchWakeupS() becuase that function expects the
         current thread to have the higher or equal priority than the ones
         in the ready list. This is not necessarily true here because we
         just changed priority.*/
      (void) chSchReadyI(tp);
 80011e6:	f7ff fcf3 	bl	8000bd0 <chSchReadyI>
 */
static inline bool chSchIsRescRequiredI(void) {

  chDbgCheckClassI();

  return firstprio(&ch.rlist.r_queue) > currp->p_prio;
 80011ea:	683a      	ldr	r2, [r7, #0]
 80011ec:	69bb      	ldr	r3, [r7, #24]
 */
void chSchRescheduleS(void) {

  chDbgCheckClassS();

  if (chSchIsRescRequiredI()) {
 80011ee:	6892      	ldr	r2, [r2, #8]
 80011f0:	689b      	ldr	r3, [r3, #8]
 80011f2:	429a      	cmp	r2, r3
 80011f4:	d901      	bls.n	80011fa <Thread1+0x16a>
    chSchDoRescheduleAhead();
 80011f6:	f7ff fac3 	bl	8000780 <chSchDoRescheduleAhead>
 80011fa:	2300      	movs	r3, #0
 80011fc:	f383 8811 	msr	BASEPRI, r3
	    };
	  int adc_oversample()
	    	  {
	    	      int sum = 0;
	    	      // Oversample by 256 and divide by 16 to get 4 more bits of accuracy.
	    	      for (int i = 0; i < 16; i++)
 8001200:	3c01      	subs	r4, #1

	    	         /* for (int j = 0; j < 16; j++)
	    	          {
	    	              sum += buf[j];
	    	          }*/
	    	          sum = buf[0];
 8001202:	f8bd b008 	ldrh.w	fp, [sp, #8]
	    };
	  int adc_oversample()
	    	  {
	    	      int sum = 0;
	    	      // Oversample by 256 and divide by 16 to get 4 more bits of accuracy.
	    	      for (int i = 0; i < 16; i++)
 8001206:	f47f af57 	bne.w	80010b8 <Thread1+0x28>
	    	      //return (sum + 8) / 16;
	    	  }
	    int val = adc_oversample();


	    int delaytime = ST2MS(delay);//system ticks to ms
 800120a:	4b23      	ldr	r3, [pc, #140]	; (8001298 <Thread1+0x208>)

  //test_println("");
  //test_println("*** ChibiOS/RT test suite");
 /* test_printn(val);
  test_print("--");*/
  chThdSleepMilliseconds(9);
 800120c:	2009      	movs	r0, #9
	    	      //return (sum + 8) / 16;
	    	  }
	    int val = adc_oversample();


	    int delaytime = ST2MS(delay);//system ticks to ms
 800120e:	681c      	ldr	r4, [r3, #0]
 8001210:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8001214:	fb04 3303 	mla	r3, r4, r3, r3
 8001218:	1e5c      	subs	r4, r3, #1
 800121a:	4b20      	ldr	r3, [pc, #128]	; (800129c <Thread1+0x20c>)
 800121c:	fba3 3404 	umull	r3, r4, r3, r4

  chp = p;
 8001220:	4b1f      	ldr	r3, [pc, #124]	; (80012a0 <Thread1+0x210>)
	    	      //return (sum + 8) / 16;
	    	  }
	    int val = adc_oversample();


	    int delaytime = ST2MS(delay);//system ticks to ms
 8001222:	09a4      	lsrs	r4, r4, #6

  chp = p;
 8001224:	f8ca 3000 	str.w	r3, [sl]

  //test_println("");
  //test_println("*** ChibiOS/RT test suite");
 /* test_printn(val);
  test_print("--");*/
  chThdSleepMilliseconds(9);
 8001228:	f7ff fcc2 	bl	8000bb0 <chThdSleep>
  test_printn(delaytime);
 800122c:	4620      	mov	r0, r4
 800122e:	4c1d      	ldr	r4, [pc, #116]	; (80012a4 <Thread1+0x214>)
 8001230:	f7ff f9ce 	bl	80005d0 <test_printn>
 8001234:	212d      	movs	r1, #45	; 0x2d
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
    chSequentialStreamPut(chp, *msgp++);
 8001236:	f8da 0000 	ldr.w	r0, [sl]
 800123a:	6803      	ldr	r3, [r0, #0]
 800123c:	689b      	ldr	r3, [r3, #8]
 800123e:	4798      	blx	r3
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 8001240:	f814 1f01 	ldrb.w	r1, [r4, #1]!
 8001244:	2900      	cmp	r1, #0
 8001246:	d1f6      	bne.n	8001236 <Thread1+0x1a6>
 /* test_printn(val);
  test_print("--");*/
  chThdSleepMilliseconds(9);
  test_printn(delaytime);
  test_print("--");
  test_printn(heart);
 8001248:	4b17      	ldr	r3, [pc, #92]	; (80012a8 <Thread1+0x218>)
 800124a:	6818      	ldr	r0, [r3, #0]
 800124c:	f7ff f9c0 	bl	80005d0 <test_printn>
    // map the sensor range to a range of 12 options:
    int range = map(sensorReading, sensorMin, sensorMax, 0, 11);

    // do something different depending on the
    // range value:
    switch (range) {
 8001250:	eb0b 038b 	add.w	r3, fp, fp, lsl #2
 8001254:	eb0b 0343 	add.w	r3, fp, r3, lsl #1
 8001258:	129b      	asrs	r3, r3, #10
 800125a:	2b0b      	cmp	r3, #11
 800125c:	d82b      	bhi.n	80012b6 <Thread1+0x226>
 800125e:	e8df f013 	tbh	[pc, r3, lsl #1]
 8001262:	00e0      	.short	0x00e0
 8001264:	00dc00e4 	.word	0x00dc00e4
 8001268:	00f000f4 	.word	0x00f000f4
 800126c:	00e800ec 	.word	0x00e800ec
 8001270:	00f800fc 	.word	0x00f800fc
 8001274:	00d400d8 	.word	0x00d400d8
 8001278:	0027      	.short	0x0027
 800127a:	bf00      	nop
 800127c:	20000c18 	.word	0x20000c18
 8001280:	200008a8 	.word	0x200008a8
 8001284:	08001f90 	.word	0x08001f90
 8001288:	200008c0 	.word	0x200008c0
 800128c:	08001ea0 	.word	0x08001ea0
 8001290:	05000100 	.word	0x05000100
 8001294:	40000313 	.word	0x40000313
 8001298:	20000820 	.word	0x20000820
 800129c:	10624dd3 	.word	0x10624dd3
 80012a0:	20000ba0 	.word	0x20000ba0
 80012a4:	0800206c 	.word	0x0800206c
 80012a8:	20000860 	.word	0x20000860
 80012ac:	20000864 	.word	0x20000864
      break;
    case 10:
    	test_println("--------------|-------------------");
      break;
    case 11:
    	test_println("--------------|-----------------------");
 80012b0:	488d      	ldr	r0, [pc, #564]	; (80014e8 <Thread1+0x458>)
 80012b2:	f7ff f96d 	bl	8000590 <test_println>
 *
 * @param[in] p         pointer to a @p BaseChannel object for test output
 */
int heartbeat(int adc, int* intervalN, int* status, int* peak,int* trough,int* thrsh,int* pl )
{
	 Signal = adc; // read the Pulse Sensor
 80012b6:	4b8d      	ldr	r3, [pc, #564]	; (80014ec <Thread1+0x45c>)

	 sampleCounter += 10; //10 //2                       // keep track of the time in mS with this variable
 80012b8:	4a8d      	ldr	r2, [pc, #564]	; (80014f0 <Thread1+0x460>)
 *
 * @param[in] p         pointer to a @p BaseChannel object for test output
 */
int heartbeat(int adc, int* intervalN, int* status, int* peak,int* trough,int* thrsh,int* pl )
{
	 Signal = adc; // read the Pulse Sensor
 80012ba:	f8c3 b000 	str.w	fp, [r3]

	 sampleCounter += 10; //10 //2                       // keep track of the time in mS with this variable
 80012be:	4b8c      	ldr	r3, [pc, #560]	; (80014f0 <Thread1+0x460>)
 *
 * @param[in] p         pointer to a @p BaseChannel object for test output
 */
int heartbeat(int adc, int* intervalN, int* status, int* peak,int* trough,int* thrsh,int* pl )
{
	 Signal = adc; // read the Pulse Sensor
 80012c0:	498a      	ldr	r1, [pc, #552]	; (80014ec <Thread1+0x45c>)

	 sampleCounter += 10; //10 //2                       // keep track of the time in mS with this variable
 80012c2:	681b      	ldr	r3, [r3, #0]
 80012c4:	330a      	adds	r3, #10
 80012c6:	6013      	str	r3, [r2, #0]

	 int N = sampleCounter - lastBeatTime;       // monitor the time since the last beat to avoid noise
 80012c8:	6814      	ldr	r4, [r2, #0]
 80012ca:	4b8a      	ldr	r3, [pc, #552]	; (80014f4 <Thread1+0x464>)

	    //  find the peak and trough of the pulse wave
	  if(Signal < thresh && N > (IBI/5)*3){       // avoid dichrotic noise by waiting 3/5 of last IBI
 80012cc:	4a8a      	ldr	r2, [pc, #552]	; (80014f8 <Thread1+0x468>)
{
	 Signal = adc; // read the Pulse Sensor

	 sampleCounter += 10; //10 //2                       // keep track of the time in mS with this variable

	 int N = sampleCounter - lastBeatTime;       // monitor the time since the last beat to avoid noise
 80012ce:	681b      	ldr	r3, [r3, #0]

	    //  find the peak and trough of the pulse wave
	  if(Signal < thresh && N > (IBI/5)*3){       // avoid dichrotic noise by waiting 3/5 of last IBI
 80012d0:	6808      	ldr	r0, [r1, #0]
 80012d2:	6812      	ldr	r2, [r2, #0]
{
	 Signal = adc; // read the Pulse Sensor

	 sampleCounter += 10; //10 //2                       // keep track of the time in mS with this variable

	 int N = sampleCounter - lastBeatTime;       // monitor the time since the last beat to avoid noise
 80012d4:	1ae3      	subs	r3, r4, r3

	    //  find the peak and trough of the pulse wave
	  if(Signal < thresh && N > (IBI/5)*3){       // avoid dichrotic noise by waiting 3/5 of last IBI
 80012d6:	4290      	cmp	r0, r2
 80012d8:	da12      	bge.n	8001300 <Thread1+0x270>
 80012da:	4a88      	ldr	r2, [pc, #544]	; (80014fc <Thread1+0x46c>)
 80012dc:	4c88      	ldr	r4, [pc, #544]	; (8001500 <Thread1+0x470>)
 80012de:	6810      	ldr	r0, [r2, #0]
 80012e0:	17c2      	asrs	r2, r0, #31
 80012e2:	fb84 4000 	smull	r4, r0, r4, r0
 80012e6:	ebc2 0260 	rsb	r2, r2, r0, asr #1
 80012ea:	eb02 0242 	add.w	r2, r2, r2, lsl #1
 80012ee:	4293      	cmp	r3, r2
 80012f0:	dd06      	ble.n	8001300 <Thread1+0x270>
	    if (Signal < T){                        // T is the trough
 80012f2:	4a84      	ldr	r2, [pc, #528]	; (8001504 <Thread1+0x474>)
 80012f4:	680c      	ldr	r4, [r1, #0]
 80012f6:	6810      	ldr	r0, [r2, #0]
 80012f8:	4284      	cmp	r4, r0
	      T = Signal;                         // keep track of lowest point in pulse wave
 80012fa:	bfbc      	itt	lt
 80012fc:	6809      	ldrlt	r1, [r1, #0]
 80012fe:	6011      	strlt	r1, [r2, #0]
	    }
	  }

	  if(Signal > thresh && Signal > P){          // thresh condition helps avoid noise
 8001300:	4a7a      	ldr	r2, [pc, #488]	; (80014ec <Thread1+0x45c>)
 8001302:	487a      	ldr	r0, [pc, #488]	; (80014ec <Thread1+0x45c>)
 8001304:	6811      	ldr	r1, [r2, #0]
 8001306:	4a7c      	ldr	r2, [pc, #496]	; (80014f8 <Thread1+0x468>)
 8001308:	6812      	ldr	r2, [r2, #0]
 800130a:	4291      	cmp	r1, r2
 800130c:	dd07      	ble.n	800131e <Thread1+0x28e>
 800130e:	4a7e      	ldr	r2, [pc, #504]	; (8001508 <Thread1+0x478>)
 8001310:	6801      	ldr	r1, [r0, #0]
 8001312:	6812      	ldr	r2, [r2, #0]
 8001314:	4c7c      	ldr	r4, [pc, #496]	; (8001508 <Thread1+0x478>)
 8001316:	4291      	cmp	r1, r2
	    P = Signal;                             // P is the peak
 8001318:	bfc4      	itt	gt
 800131a:	6802      	ldrgt	r2, [r0, #0]
 800131c:	6022      	strgt	r2, [r4, #0]
	  }                                        // keep track of highest point in pulse wave

	  //  NOW IT'S TIME TO LOOK FOR THE HEART BEAT
	  // signal surges up in value every time there is a pulse
	  *intervalN=N;
 800131e:	4a7b      	ldr	r2, [pc, #492]	; (800150c <Thread1+0x47c>)
	  if (N > 250){                                   // avoid high frequency noise
 8001320:	2bfa      	cmp	r3, #250	; 0xfa
	    P = Signal;                             // P is the peak
	  }                                        // keep track of highest point in pulse wave

	  //  NOW IT'S TIME TO LOOK FOR THE HEART BEAT
	  // signal surges up in value every time there is a pulse
	  *intervalN=N;
 8001322:	6013      	str	r3, [r2, #0]
	  if (N > 250){                                   // avoid high frequency noise
 8001324:	f340 811a 	ble.w	800155c <Thread1+0x4cc>
	    if ( (Signal > thresh) && (Pulse == false) && (N > (IBI/5)*3) ){
 8001328:	4a70      	ldr	r2, [pc, #448]	; (80014ec <Thread1+0x45c>)
 800132a:	6811      	ldr	r1, [r2, #0]
 800132c:	4a72      	ldr	r2, [pc, #456]	; (80014f8 <Thread1+0x468>)
 800132e:	6812      	ldr	r2, [r2, #0]
 8001330:	4291      	cmp	r1, r2
 8001332:	f340 8113 	ble.w	800155c <Thread1+0x4cc>
 8001336:	4a76      	ldr	r2, [pc, #472]	; (8001510 <Thread1+0x480>)
 8001338:	4c75      	ldr	r4, [pc, #468]	; (8001510 <Thread1+0x480>)
 800133a:	7812      	ldrb	r2, [r2, #0]
 800133c:	f002 00ff 	and.w	r0, r2, #255	; 0xff
 8001340:	2a00      	cmp	r2, #0
 8001342:	f040 810b 	bne.w	800155c <Thread1+0x4cc>
 8001346:	4a6d      	ldr	r2, [pc, #436]	; (80014fc <Thread1+0x46c>)
 8001348:	f8df e1b4 	ldr.w	lr, [pc, #436]	; 8001500 <Thread1+0x470>
 800134c:	6811      	ldr	r1, [r2, #0]
 800134e:	17ca      	asrs	r2, r1, #31
 8001350:	fb8e e101 	smull	lr, r1, lr, r1
 8001354:	ebc2 0261 	rsb	r2, r2, r1, asr #1
 8001358:	eb02 0242 	add.w	r2, r2, r2, lsl #1
 800135c:	4293      	cmp	r3, r2
 800135e:	4967      	ldr	r1, [pc, #412]	; (80014fc <Thread1+0x46c>)
 8001360:	f340 80fc 	ble.w	800155c <Thread1+0x4cc>
	      Pulse = true;                               // set the Pulse flag when we think there is a pulse
 8001364:	2301      	movs	r3, #1
 8001366:	7023      	strb	r3, [r4, #0]
	      //digitalWrite(blinkPin,HIGH);                // turn on pin 13 LED
	      IBI = sampleCounter - lastBeatTime;         // measure time between beats in mS
 8001368:	4a62      	ldr	r2, [pc, #392]	; (80014f4 <Thread1+0x464>)
 800136a:	4b61      	ldr	r3, [pc, #388]	; (80014f0 <Thread1+0x460>)
 800136c:	681b      	ldr	r3, [r3, #0]
 800136e:	6814      	ldr	r4, [r2, #0]
	      lastBeatTime = sampleCounter;               // keep track of time for next pulse

	      if(secondBeat){                        // if this is the second beat, if secondBeat == TRUE
 8001370:	4a68      	ldr	r2, [pc, #416]	; (8001514 <Thread1+0x484>)
	  *intervalN=N;
	  if (N > 250){                                   // avoid high frequency noise
	    if ( (Signal > thresh) && (Pulse == false) && (N > (IBI/5)*3) ){
	      Pulse = true;                               // set the Pulse flag when we think there is a pulse
	      //digitalWrite(blinkPin,HIGH);                // turn on pin 13 LED
	      IBI = sampleCounter - lastBeatTime;         // measure time between beats in mS
 8001372:	1b1b      	subs	r3, r3, r4
 8001374:	600b      	str	r3, [r1, #0]
	      lastBeatTime = sampleCounter;               // keep track of time for next pulse
 8001376:	4b5e      	ldr	r3, [pc, #376]	; (80014f0 <Thread1+0x460>)
 8001378:	495e      	ldr	r1, [pc, #376]	; (80014f4 <Thread1+0x464>)
 800137a:	681b      	ldr	r3, [r3, #0]
 800137c:	600b      	str	r3, [r1, #0]

	      if(secondBeat){                        // if this is the second beat, if secondBeat == TRUE
 800137e:	7813      	ldrb	r3, [r2, #0]
 8001380:	b14b      	cbz	r3, 8001396 <Thread1+0x306>
	        secondBeat = false;                  // clear secondBeat flag
	        for(int i=0; i<=9; i++){             // seed the running total to get a realisitic BPM at startup
 8001382:	4603      	mov	r3, r0
	      //digitalWrite(blinkPin,HIGH);                // turn on pin 13 LED
	      IBI = sampleCounter - lastBeatTime;         // measure time between beats in mS
	      lastBeatTime = sampleCounter;               // keep track of time for next pulse

	      if(secondBeat){                        // if this is the second beat, if secondBeat == TRUE
	        secondBeat = false;                  // clear secondBeat flag
 8001384:	7010      	strb	r0, [r2, #0]
	        for(int i=0; i<=9; i++){             // seed the running total to get a realisitic BPM at startup
	          rate[i] = IBI;
 8001386:	4a5d      	ldr	r2, [pc, #372]	; (80014fc <Thread1+0x46c>)
 8001388:	4963      	ldr	r1, [pc, #396]	; (8001518 <Thread1+0x488>)
 800138a:	6812      	ldr	r2, [r2, #0]
 800138c:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
	      IBI = sampleCounter - lastBeatTime;         // measure time between beats in mS
	      lastBeatTime = sampleCounter;               // keep track of time for next pulse

	      if(secondBeat){                        // if this is the second beat, if secondBeat == TRUE
	        secondBeat = false;                  // clear secondBeat flag
	        for(int i=0; i<=9; i++){             // seed the running total to get a realisitic BPM at startup
 8001390:	3301      	adds	r3, #1
 8001392:	2b0a      	cmp	r3, #10
 8001394:	d1f7      	bne.n	8001386 <Thread1+0x2f6>
	          rate[i] = IBI;
	        }
	      }

	      if(firstBeat){                         // if it's the first time we found a beat, if firstBeat == TRUE
 8001396:	4b61      	ldr	r3, [pc, #388]	; (800151c <Thread1+0x48c>)
 8001398:	4a60      	ldr	r2, [pc, #384]	; (800151c <Thread1+0x48c>)
 800139a:	781b      	ldrb	r3, [r3, #0]
 800139c:	b123      	cbz	r3, 80013a8 <Thread1+0x318>
	        firstBeat = false;                   // clear firstBeat flag
 800139e:	2100      	movs	r1, #0
 80013a0:	7011      	strb	r1, [r2, #0]
	        secondBeat = true;                   // set the second beat flag
 80013a2:	4a5c      	ldr	r2, [pc, #368]	; (8001514 <Thread1+0x484>)
 80013a4:	2301      	movs	r3, #1
 80013a6:	7013      	strb	r3, [r2, #0]
	      IBI = sampleCounter - lastBeatTime;         // measure time between beats in mS
	      lastBeatTime = sampleCounter;               // keep track of time for next pulse

	      if(secondBeat){                        // if this is the second beat, if secondBeat == TRUE
	        secondBeat = false;                  // clear secondBeat flag
	        for(int i=0; i<=9; i++){             // seed the running total to get a realisitic BPM at startup
 80013a8:	2200      	movs	r2, #0
 80013aa:	4613      	mov	r3, r2

	      // keep a running total of the last 10 IBI values
	      int runningTotal = 0;                  // clear the runningTotal variable

	      for(int i=0; i<=8; i++){                // shift data in the rate array
	        rate[i] = rate[i+1];                  // and drop the oldest IBI value
 80013ac:	485a      	ldr	r0, [pc, #360]	; (8001518 <Thread1+0x488>)
 80013ae:	1c59      	adds	r1, r3, #1
 80013b0:	f850 0021 	ldr.w	r0, [r0, r1, lsl #2]
 80013b4:	f8df e160 	ldr.w	lr, [pc, #352]	; 8001518 <Thread1+0x488>


	      // keep a running total of the last 10 IBI values
	      int runningTotal = 0;                  // clear the runningTotal variable

	      for(int i=0; i<=8; i++){                // shift data in the rate array
 80013b8:	2909      	cmp	r1, #9
	        rate[i] = rate[i+1];                  // and drop the oldest IBI value
 80013ba:	f84e 0023 	str.w	r0, [lr, r3, lsl #2]
	        runningTotal += rate[i];              // add up the 9 oldest IBI values
 80013be:	f85e 0023 	ldr.w	r0, [lr, r3, lsl #2]
 80013c2:	460b      	mov	r3, r1
 80013c4:	4402      	add	r2, r0


	      // keep a running total of the last 10 IBI values
	      int runningTotal = 0;                  // clear the runningTotal variable

	      for(int i=0; i<=8; i++){                // shift data in the rate array
 80013c6:	d1f1      	bne.n	80013ac <Thread1+0x31c>
	      }

	      rate[9] = IBI;                          // add the latest IBI to the rate array
	      runningTotal += rate[9];                // add the latest IBI to runningTotal
	      runningTotal /= 10;                     // average the last 10 IBI values
	      BPM = 60000/runningTotal;               // how many beats can fit into a minute? that's BPM!
 80013c8:	f64e 2160 	movw	r1, #60000	; 0xea60
	      for(int i=0; i<=8; i++){                // shift data in the rate array
	        rate[i] = rate[i+1];                  // and drop the oldest IBI value
	        runningTotal += rate[i];              // add up the 9 oldest IBI values
	      }

	      rate[9] = IBI;                          // add the latest IBI to the rate array
 80013cc:	4b4b      	ldr	r3, [pc, #300]	; (80014fc <Thread1+0x46c>)
	      runningTotal += rate[9];                // add the latest IBI to runningTotal
	      runningTotal /= 10;                     // average the last 10 IBI values
	      BPM = 60000/runningTotal;               // how many beats can fit into a minute? that's BPM!
 80013ce:	484c      	ldr	r0, [pc, #304]	; (8001500 <Thread1+0x470>)
	      for(int i=0; i<=8; i++){                // shift data in the rate array
	        rate[i] = rate[i+1];                  // and drop the oldest IBI value
	        runningTotal += rate[i];              // add up the 9 oldest IBI values
	      }

	      rate[9] = IBI;                          // add the latest IBI to the rate array
 80013d0:	681b      	ldr	r3, [r3, #0]
 80013d2:	f8ce 3024 	str.w	r3, [lr, #36]	; 0x24
	      runningTotal += rate[9];                // add the latest IBI to runningTotal
 80013d6:	f8de 3024 	ldr.w	r3, [lr, #36]	; 0x24
 80013da:	4413      	add	r3, r2
	      runningTotal /= 10;                     // average the last 10 IBI values
	      BPM = 60000/runningTotal;               // how many beats can fit into a minute? that's BPM!
 80013dc:	fb80 0203 	smull	r0, r2, r0, r3
 80013e0:	17db      	asrs	r3, r3, #31
 80013e2:	ebc3 03a2 	rsb	r3, r3, r2, asr #2
 80013e6:	fb91 f3f3 	sdiv	r3, r1, r3
 80013ea:	4a4d      	ldr	r2, [pc, #308]	; (8001520 <Thread1+0x490>)
 80013ec:	6013      	str	r3, [r2, #0]
	      return BPM;
 80013ee:	6813      	ldr	r3, [r2, #0]
 80013f0:	9301      	str	r3, [sp, #4]



  //QS=false;

  heart = heartbeat(val,&intervalN,&status,&peak,&trough,&thrsh,&pl);// input adc and pointer (to store interval b/w heart beats)
 80013f2:	4b4c      	ldr	r3, [pc, #304]	; (8001524 <Thread1+0x494>)
 80013f4:	9a01      	ldr	r2, [sp, #4]
 80013f6:	601a      	str	r2, [r3, #0]
 80013f8:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 80013fc:	6a5b      	ldr	r3, [r3, #36]	; 0x24

  int pastime = osalOsGetSystemTimeX();
  delay = pastime - curtime;
 80013fe:	9a00      	ldr	r2, [sp, #0]
 8001400:	b29b      	uxth	r3, r3
 8001402:	1a9b      	subs	r3, r3, r2
 8001404:	4a48      	ldr	r2, [pc, #288]	; (8001528 <Thread1+0x498>)
 8001406:	6013      	str	r3, [r2, #0]
 8001408:	e650      	b.n	80010ac <Thread1+0x1c>
      break;
    case 9:
    	test_println("--------------|----------------");
      break;
    case 10:
    	test_println("--------------|-------------------");
 800140a:	4848      	ldr	r0, [pc, #288]	; (800152c <Thread1+0x49c>)
 800140c:	f7ff f8c0 	bl	8000590 <test_println>
 8001410:	e751      	b.n	80012b6 <Thread1+0x226>
      break;
    case 8:
    	test_println("--------------|----------");
      break;
    case 9:
    	test_println("--------------|----------------");
 8001412:	4847      	ldr	r0, [pc, #284]	; (8001530 <Thread1+0x4a0>)
 8001414:	f7ff f8bc 	bl	8000590 <test_println>
 8001418:	e74d      	b.n	80012b6 <Thread1+0x226>
      break;
    case 1:
    	test_println("---");
      break;
    case 2:
    	test_println("------");
 800141a:	4846      	ldr	r0, [pc, #280]	; (8001534 <Thread1+0x4a4>)
 800141c:	f7ff f8b8 	bl	8000590 <test_println>
 8001420:	e749      	b.n	80012b6 <Thread1+0x226>

    // do something different depending on the
    // range value:
    switch (range) {
    case 0:
      test_println("");     /////ASCII Art Madness
 8001422:	4845      	ldr	r0, [pc, #276]	; (8001538 <Thread1+0x4a8>)
 8001424:	f7ff f8b4 	bl	8000590 <test_println>
 8001428:	e745      	b.n	80012b6 <Thread1+0x226>
      break;
    case 1:
    	test_println("---");
 800142a:	4844      	ldr	r0, [pc, #272]	; (800153c <Thread1+0x4ac>)
 800142c:	f7ff f8b0 	bl	8000590 <test_println>
 8001430:	e741      	b.n	80012b6 <Thread1+0x226>
      break;
    case 5:
    	test_println("--------------|-");
      break;
    case 6:
    	test_println("--------------|---");
 8001432:	4843      	ldr	r0, [pc, #268]	; (8001540 <Thread1+0x4b0>)
 8001434:	f7ff f8ac 	bl	8000590 <test_println>
 8001438:	e73d      	b.n	80012b6 <Thread1+0x226>
      break;
    case 4:
    	test_println("------------");
      break;
    case 5:
    	test_println("--------------|-");
 800143a:	4842      	ldr	r0, [pc, #264]	; (8001544 <Thread1+0x4b4>)
 800143c:	f7ff f8a8 	bl	8000590 <test_println>
 8001440:	e739      	b.n	80012b6 <Thread1+0x226>
      break;
    case 3:
    	test_println("---------");
      break;
    case 4:
    	test_println("------------");
 8001442:	4841      	ldr	r0, [pc, #260]	; (8001548 <Thread1+0x4b8>)
 8001444:	f7ff f8a4 	bl	8000590 <test_println>
 8001448:	e735      	b.n	80012b6 <Thread1+0x226>
      break;
    case 2:
    	test_println("------");
      break;
    case 3:
    	test_println("---------");
 800144a:	4840      	ldr	r0, [pc, #256]	; (800154c <Thread1+0x4bc>)
 800144c:	f7ff f8a0 	bl	8000590 <test_println>
 8001450:	e731      	b.n	80012b6 <Thread1+0x226>
      break;
    case 7:
    	test_println("--------------|-------");
      break;
    case 8:
    	test_println("--------------|----------");
 8001452:	483f      	ldr	r0, [pc, #252]	; (8001550 <Thread1+0x4c0>)
 8001454:	f7ff f89c 	bl	8000590 <test_println>
 8001458:	e72d      	b.n	80012b6 <Thread1+0x226>
      break;
    case 6:
    	test_println("--------------|---");
      break;
    case 7:
    	test_println("--------------|-------");
 800145a:	483e      	ldr	r0, [pc, #248]	; (8001554 <Thread1+0x4c4>)
 800145c:	f7ff f898 	bl	8000590 <test_println>
 8001460:	e729      	b.n	80012b6 <Thread1+0x226>
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->p_prev->p_next = tp->p_next;
 8001462:	6851      	ldr	r1, [r2, #4]
 8001464:	6813      	ldr	r3, [r2, #0]
  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
 8001466:	4696      	mov	lr, r2
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->p_prev->p_next = tp->p_next;
 8001468:	600b      	str	r3, [r1, #0]
  tp->p_next->p_prev = tp->p_prev;
 800146a:	6813      	ldr	r3, [r2, #0]
 800146c:	6059      	str	r1, [r3, #4]
#endif
#if (CH_CFG_USE_MESSAGES == TRUE) && (CH_CFG_USE_MESSAGES_PRIORITY == TRUE)
        case CH_STATE_SNDMSGQ:
#endif
          /* Re-enqueues tp with its new priority on the queue.*/
          queue_prio_insert(queue_dequeue(tp), &tp->p_u.wtmtxp->m_queue);
 800146e:	6a11      	ldr	r1, [r2, #32]
  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
 8001470:	460b      	mov	r3, r1
 8001472:	e002      	b.n	800147a <Thread1+0x3ea>
  do {
    cp = cp->p_next;
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 8001474:	689a      	ldr	r2, [r3, #8]
 8001476:	4282      	cmp	r2, r0
 8001478:	d302      	bcc.n	8001480 <Thread1+0x3f0>

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
 800147a:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 800147c:	4299      	cmp	r1, r3
 800147e:	d1f9      	bne.n	8001474 <Thread1+0x3e4>
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 8001480:	6859      	ldr	r1, [r3, #4]

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
  tp->p_next = cp;
 8001482:	f8ce 3000 	str.w	r3, [lr]
  tp->p_prev = cp->p_prev;
 8001486:	f8ce 1004 	str.w	r1, [lr, #4]
  tp->p_prev->p_next = tp;
 800148a:	f8c1 e000 	str.w	lr, [r1]
  cp->p_prev = tp;
 800148e:	f8c3 e004 	str.w	lr, [r3, #4]
 8001492:	e630      	b.n	80010f6 <Thread1+0x66>
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->p_prev->p_next = tp->p_next;
 8001494:	6813      	ldr	r3, [r2, #0]
 8001496:	6851      	ldr	r1, [r2, #4]
 8001498:	600b      	str	r3, [r1, #0]
  tp->p_next->p_prev = tp->p_prev;
 800149a:	6813      	ldr	r3, [r2, #0]
 800149c:	6059      	str	r1, [r3, #4]

        /* The following states need priority queues reordering.*/
        switch (tp->p_state) {
        case CH_STATE_WTMTX:
          /* Re-enqueues the mutex owner with its new priority.*/
          queue_prio_insert(queue_dequeue(tp), &tp->p_u.wtmtxp->m_queue);
 800149e:	f8d2 e020 	ldr.w	lr, [r2, #32]
  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
 80014a2:	4673      	mov	r3, lr
 80014a4:	e002      	b.n	80014ac <Thread1+0x41c>
  do {
    cp = cp->p_next;
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 80014a6:	6899      	ldr	r1, [r3, #8]
 80014a8:	4281      	cmp	r1, r0
 80014aa:	d302      	bcc.n	80014b2 <Thread1+0x422>

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
 80014ac:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 80014ae:	459e      	cmp	lr, r3
 80014b0:	d1f9      	bne.n	80014a6 <Thread1+0x416>
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 80014b2:	6859      	ldr	r1, [r3, #4]

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
  tp->p_next = cp;
 80014b4:	6013      	str	r3, [r2, #0]
  tp->p_prev = cp->p_prev;
 80014b6:	6051      	str	r1, [r2, #4]
  tp->p_prev->p_next = tp;
 80014b8:	600a      	str	r2, [r1, #0]
  cp->p_prev = tp;
 80014ba:	605a      	str	r2, [r3, #4]
          tp = tp->p_u.wtmtxp->m_owner;
 80014bc:	f8de 2008 	ldr.w	r2, [lr, #8]
         priority of the running thread requesting the mutex.*/
      thread_t *tp = mp->m_owner;

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->p_prio < ctp->p_prio) {
 80014c0:	f8d8 0008 	ldr.w	r0, [r8, #8]
 80014c4:	6893      	ldr	r3, [r2, #8]
 80014c6:	4298      	cmp	r0, r3
 80014c8:	f63f ae04 	bhi.w	80010d4 <Thread1+0x44>
 80014cc:	e613      	b.n	80010f6 <Thread1+0x66>
         just changed priority.*/
      (void) chSchReadyI(tp);
      chSchRescheduleS();
    }
    else {
      mp->m_owner = NULL;
 80014ce:	4b22      	ldr	r3, [pc, #136]	; (8001558 <Thread1+0x4c8>)
 80014d0:	f8c3 8020 	str.w	r8, [r3, #32]
 80014d4:	e691      	b.n	80011fa <Thread1+0x16a>

    mp->m_cnt++;
#endif
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->m_owner = ctp;
    mp->m_next = ctp->p_mtxlist;
 80014d6:	f8d8 3038 	ldr.w	r3, [r8, #56]	; 0x38
    chDbgAssert(mp->m_cnt == (cnt_t)0, "counter is not zero");

    mp->m_cnt++;
#endif
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->m_owner = ctp;
 80014da:	4a1f      	ldr	r2, [pc, #124]	; (8001558 <Thread1+0x4c8>)
    mp->m_next = ctp->p_mtxlist;
    ctp->p_mtxlist = mp;
 80014dc:	f8c8 6038 	str.w	r6, [r8, #56]	; 0x38
    chDbgAssert(mp->m_cnt == (cnt_t)0, "counter is not zero");

    mp->m_cnt++;
#endif
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->m_owner = ctp;
 80014e0:	f8c2 8020 	str.w	r8, [r2, #32]
    mp->m_next = ctp->p_mtxlist;
 80014e4:	6253      	str	r3, [r2, #36]	; 0x24
 80014e6:	e61e      	b.n	8001126 <Thread1+0x96>
 80014e8:	08002048 	.word	0x08002048
 80014ec:	20000858 	.word	0x20000858
 80014f0:	200008dc 	.word	0x200008dc
 80014f4:	20000850 	.word	0x20000850
 80014f8:	2000080c 	.word	0x2000080c
 80014fc:	20000804 	.word	0x20000804
 8001500:	66666667 	.word	0x66666667
 8001504:	20000800 	.word	0x20000800
 8001508:	20000814 	.word	0x20000814
 800150c:	200008e4 	.word	0x200008e4
 8001510:	20000868 	.word	0x20000868
 8001514:	20000a30 	.word	0x20000a30
 8001518:	20000824 	.word	0x20000824
 800151c:	20000810 	.word	0x20000810
 8001520:	200008e0 	.word	0x200008e0
 8001524:	20000860 	.word	0x20000860
 8001528:	20000820 	.word	0x20000820
 800152c:	08002024 	.word	0x08002024
 8001530:	08002004 	.word	0x08002004
 8001534:	08002068 	.word	0x08002068
 8001538:	08001fa4 	.word	0x08001fa4
 800153c:	08002020 	.word	0x08002020
 8001540:	08001fbc 	.word	0x08001fbc
 8001544:	08001fa8 	.word	0x08001fa8
 8001548:	08001f98 	.word	0x08001f98
 800154c:	08001ff8 	.word	0x08001ff8
 8001550:	08001fe8 	.word	0x08001fe8
 8001554:	08001fd0 	.word	0x08001fd0
 8001558:	200008a8 	.word	0x200008a8
	      *status=1;// set Quantified Self flag
	      // QS FLAG IS NOT CLEARED INSIDE THIS ISR
	    }
	  }

	  if (Signal < thresh && Pulse == true){   // when the values are going down, the beat is over
 800155c:	4a25      	ldr	r2, [pc, #148]	; (80015f4 <Thread1+0x564>)
 800155e:	4826      	ldr	r0, [pc, #152]	; (80015f8 <Thread1+0x568>)
 8001560:	6811      	ldr	r1, [r2, #0]
 8001562:	4a25      	ldr	r2, [pc, #148]	; (80015f8 <Thread1+0x568>)
 8001564:	6812      	ldr	r2, [r2, #0]
 8001566:	4291      	cmp	r1, r2
 8001568:	da28      	bge.n	80015bc <Thread1+0x52c>
 800156a:	4a24      	ldr	r2, [pc, #144]	; (80015fc <Thread1+0x56c>)
 800156c:	4923      	ldr	r1, [pc, #140]	; (80015fc <Thread1+0x56c>)
 800156e:	7812      	ldrb	r2, [r2, #0]
 8001570:	b322      	cbz	r2, 80015bc <Thread1+0x52c>
	    //digitalWrite(blinkPin,LOW);            // turn off pin 13 LED
	    Pulse = false;                         // reset the Pulse flag so we can do it again
 8001572:	2200      	movs	r2, #0
 8001574:	700a      	strb	r2, [r1, #0]
	    amp = P - T;                           // get amplitude of the pulse wave
 8001576:	4c22      	ldr	r4, [pc, #136]	; (8001600 <Thread1+0x570>)
 8001578:	4a22      	ldr	r2, [pc, #136]	; (8001604 <Thread1+0x574>)
	    thresh = amp/2 + T;                    // set thresh at 50% of the amplitude
	    P = thresh;                            // reset these for next time
	    T = thresh;
	    *thrsh=thresh;
	    *pl=Pulse;
	    *status=2;
 800157a:	f04f 0c02 	mov.w	ip, #2
	  }

	  if (Signal < thresh && Pulse == true){   // when the values are going down, the beat is over
	    //digitalWrite(blinkPin,LOW);            // turn off pin 13 LED
	    Pulse = false;                         // reset the Pulse flag so we can do it again
	    amp = P - T;                           // get amplitude of the pulse wave
 800157e:	6812      	ldr	r2, [r2, #0]
 8001580:	f8d4 e000 	ldr.w	lr, [r4]
 8001584:	4c20      	ldr	r4, [pc, #128]	; (8001608 <Thread1+0x578>)
 8001586:	ebce 0202 	rsb	r2, lr, r2
 800158a:	6022      	str	r2, [r4, #0]
	    thresh = amp/2 + T;                    // set thresh at 50% of the amplitude
 800158c:	6822      	ldr	r2, [r4, #0]
 800158e:	4c1c      	ldr	r4, [pc, #112]	; (8001600 <Thread1+0x570>)
 8001590:	eb02 72d2 	add.w	r2, r2, r2, lsr #31
 8001594:	f8d4 e000 	ldr.w	lr, [r4]
	    P = thresh;                            // reset these for next time
	    T = thresh;
	    *thrsh=thresh;
	    *pl=Pulse;
	    *status=2;
 8001598:	4c1c      	ldr	r4, [pc, #112]	; (800160c <Thread1+0x57c>)

	  if (Signal < thresh && Pulse == true){   // when the values are going down, the beat is over
	    //digitalWrite(blinkPin,LOW);            // turn off pin 13 LED
	    Pulse = false;                         // reset the Pulse flag so we can do it again
	    amp = P - T;                           // get amplitude of the pulse wave
	    thresh = amp/2 + T;                    // set thresh at 50% of the amplitude
 800159a:	eb0e 0262 	add.w	r2, lr, r2, asr #1
 800159e:	6002      	str	r2, [r0, #0]
	    P = thresh;                            // reset these for next time
 80015a0:	6802      	ldr	r2, [r0, #0]
	    T = thresh;
	    *thrsh=thresh;
	    *pl=Pulse;
	    *status=2;
 80015a2:	f8c4 c000 	str.w	ip, [r4]
	  if (Signal < thresh && Pulse == true){   // when the values are going down, the beat is over
	    //digitalWrite(blinkPin,LOW);            // turn off pin 13 LED
	    Pulse = false;                         // reset the Pulse flag so we can do it again
	    amp = P - T;                           // get amplitude of the pulse wave
	    thresh = amp/2 + T;                    // set thresh at 50% of the amplitude
	    P = thresh;                            // reset these for next time
 80015a6:	4c17      	ldr	r4, [pc, #92]	; (8001604 <Thread1+0x574>)
 80015a8:	6022      	str	r2, [r4, #0]
	    T = thresh;
 80015aa:	6802      	ldr	r2, [r0, #0]
 80015ac:	4c14      	ldr	r4, [pc, #80]	; (8001600 <Thread1+0x570>)
 80015ae:	6022      	str	r2, [r4, #0]
	    *thrsh=thresh;
 80015b0:	6800      	ldr	r0, [r0, #0]
	    *pl=Pulse;
 80015b2:	780a      	ldrb	r2, [r1, #0]
	    Pulse = false;                         // reset the Pulse flag so we can do it again
	    amp = P - T;                           // get amplitude of the pulse wave
	    thresh = amp/2 + T;                    // set thresh at 50% of the amplitude
	    P = thresh;                            // reset these for next time
	    T = thresh;
	    *thrsh=thresh;
 80015b4:	4916      	ldr	r1, [pc, #88]	; (8001610 <Thread1+0x580>)
 80015b6:	6008      	str	r0, [r1, #0]
	    *pl=Pulse;
 80015b8:	4916      	ldr	r1, [pc, #88]	; (8001614 <Thread1+0x584>)
 80015ba:	600a      	str	r2, [r1, #0]
	    *status=2;
	  }

	  if (N > 2500){                           // if 2.5 seconds go by without a beat
 80015bc:	f640 12c4 	movw	r2, #2500	; 0x9c4
 80015c0:	4293      	cmp	r3, r2
 80015c2:	f77f af16 	ble.w	80013f2 <Thread1+0x362>
	    thresh = 712;//512                          // set thresh default
 80015c6:	4a0c      	ldr	r2, [pc, #48]	; (80015f8 <Thread1+0x568>)
 80015c8:	f44f 7332 	mov.w	r3, #712	; 0x2c8
 80015cc:	6013      	str	r3, [r2, #0]
	    P = 712;                               // set P default
 80015ce:	4a0d      	ldr	r2, [pc, #52]	; (8001604 <Thread1+0x574>)
	    T = 712;                               // set T default
	    lastBeatTime = sampleCounter;          // bring the lastBeatTime up to date
 80015d0:	4911      	ldr	r1, [pc, #68]	; (8001618 <Thread1+0x588>)
	    *status=2;
	  }

	  if (N > 2500){                           // if 2.5 seconds go by without a beat
	    thresh = 712;//512                          // set thresh default
	    P = 712;                               // set P default
 80015d2:	6013      	str	r3, [r2, #0]
	    T = 712;                               // set T default
 80015d4:	4a0a      	ldr	r2, [pc, #40]	; (8001600 <Thread1+0x570>)
 80015d6:	6013      	str	r3, [r2, #0]
	    lastBeatTime = sampleCounter;          // bring the lastBeatTime up to date
 80015d8:	4b10      	ldr	r3, [pc, #64]	; (800161c <Thread1+0x58c>)
 80015da:	681a      	ldr	r2, [r3, #0]
	    firstBeat = true;                      // set these to avoid noise
 80015dc:	2301      	movs	r3, #1

	  if (N > 2500){                           // if 2.5 seconds go by without a beat
	    thresh = 712;//512                          // set thresh default
	    P = 712;                               // set P default
	    T = 712;                               // set T default
	    lastBeatTime = sampleCounter;          // bring the lastBeatTime up to date
 80015de:	600a      	str	r2, [r1, #0]
	    firstBeat = true;                      // set these to avoid noise
 80015e0:	490f      	ldr	r1, [pc, #60]	; (8001620 <Thread1+0x590>)
	    secondBeat = false;
 80015e2:	2200      	movs	r2, #0
	  if (N > 2500){                           // if 2.5 seconds go by without a beat
	    thresh = 712;//512                          // set thresh default
	    P = 712;                               // set P default
	    T = 712;                               // set T default
	    lastBeatTime = sampleCounter;          // bring the lastBeatTime up to date
	    firstBeat = true;                      // set these to avoid noise
 80015e4:	700b      	strb	r3, [r1, #0]
	    secondBeat = false;
 80015e6:	490f      	ldr	r1, [pc, #60]	; (8001624 <Thread1+0x594>)
	    *status=3;// when we get the heartbeat back
 80015e8:	2303      	movs	r3, #3
	    thresh = 712;//512                          // set thresh default
	    P = 712;                               // set P default
	    T = 712;                               // set T default
	    lastBeatTime = sampleCounter;          // bring the lastBeatTime up to date
	    firstBeat = true;                      // set these to avoid noise
	    secondBeat = false;
 80015ea:	700a      	strb	r2, [r1, #0]
	    *status=3;// when we get the heartbeat back
 80015ec:	4a07      	ldr	r2, [pc, #28]	; (800160c <Thread1+0x57c>)
 80015ee:	6013      	str	r3, [r2, #0]
 80015f0:	e6ff      	b.n	80013f2 <Thread1+0x362>
 80015f2:	bf00      	nop
 80015f4:	20000858 	.word	0x20000858
 80015f8:	2000080c 	.word	0x2000080c
 80015fc:	20000868 	.word	0x20000868
 8001600:	20000800 	.word	0x20000800
 8001604:	20000814 	.word	0x20000814
 8001608:	20000808 	.word	0x20000808
 800160c:	20000854 	.word	0x20000854
 8001610:	2000081c 	.word	0x2000081c
 8001614:	2000084c 	.word	0x2000084c
 8001618:	20000850 	.word	0x20000850
 800161c:	200008dc 	.word	0x200008dc
 8001620:	20000810 	.word	0x20000810
 8001624:	20000a30 	.word	0x20000a30
	...

08001630 <main>:
 * @notapi
 */
void hal_lld_init(void) {

  /* Reset of all peripherals.*/
  rccResetAHB(~RCC_AHBRSTR_FLITFRST);
 8001630:	4b25      	ldr	r3, [pc, #148]	; (80016c8 <main+0x98>)
 8001632:	2200      	movs	r2, #0
 8001634:	6919      	ldr	r1, [r3, #16]
}

/*
 * Application entry point.
 */
int main(void) {
 8001636:	e92d 4880 	stmdb	sp!, {r7, fp, lr}
 800163a:	f461 4100 	orn	r1, r1, #32768	; 0x8000
 800163e:	6119      	str	r1, [r3, #16]
 8001640:	611a      	str	r2, [r3, #16]
  rccResetAPB1(~RCC_APB1RSTR_PWRRST);
 8001642:	6999      	ldr	r1, [r3, #24]
  rccResetAPB2(~0);
 8001644:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
 */
void hal_lld_init(void) {

  /* Reset of all peripherals.*/
  rccResetAHB(~RCC_AHBRSTR_FLITFRST);
  rccResetAPB1(~RCC_APB1RSTR_PWRRST);
 8001648:	f061 5180 	orn	r1, r1, #268435456	; 0x10000000
 800164c:	6199      	str	r1, [r3, #24]
 800164e:	619a      	str	r2, [r3, #24]
  rccResetAPB2(~0);
 8001650:	6959      	ldr	r1, [r3, #20]
 8001652:	615c      	str	r4, [r3, #20]
 8001654:	615a      	str	r2, [r3, #20]

  /* PWR clock enabled.*/
  rccEnablePWRInterface(FALSE);
 8001656:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 * @brief   Initializes the backup domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 8001658:	481c      	ldr	r0, [pc, #112]	; (80016cc <main+0x9c>)
  rccResetAHB(~RCC_AHBRSTR_FLITFRST);
  rccResetAPB1(~RCC_APB1RSTR_PWRRST);
  rccResetAPB2(~0);

  /* PWR clock enabled.*/
  rccEnablePWRInterface(FALSE);
 800165a:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 800165e:	625a      	str	r2, [r3, #36]	; 0x24
 * @brief   Initializes the backup domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 8001660:	6802      	ldr	r2, [r0, #0]
 8001662:	b08b      	sub	sp, #44	; 0x2c
 8001664:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8001668:	6002      	str	r2, [r0, #0]

  /* Reset BKP domain if different clock source selected.*/
  if ((RCC->CSR & STM32_RTCSEL_MASK) != STM32_RTCSEL){
 800166a:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800166c:	f402 3240 	and.w	r2, r2, #196608	; 0x30000
 8001670:	f5b2 3f80 	cmp.w	r2, #65536	; 0x10000
 8001674:	d007      	beq.n	8001686 <main+0x56>
    /* Backup domain reset.*/
    RCC->CSR |= RCC_CSR_RTCRST;
 8001676:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8001678:	f442 0200 	orr.w	r2, r2, #8388608	; 0x800000
 800167c:	635a      	str	r2, [r3, #52]	; 0x34
    RCC->CSR &= ~RCC_CSR_RTCRST;
 800167e:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8001680:	f422 0200 	bic.w	r2, r2, #8388608	; 0x800000
 8001684:	635a      	str	r2, [r3, #52]	; 0x34
  }

  /* If enabled then the LSE is started.*/
#if STM32_LSE_ENABLED
  RCC->CSR |= RCC_CSR_LSEON;
 8001686:	4b10      	ldr	r3, [pc, #64]	; (80016c8 <main+0x98>)
  while ((RCC->CSR & RCC_CSR_LSERDY) == 0)
 8001688:	4619      	mov	r1, r3
    RCC->CSR &= ~RCC_CSR_RTCRST;
  }

  /* If enabled then the LSE is started.*/
#if STM32_LSE_ENABLED
  RCC->CSR |= RCC_CSR_LSEON;
 800168a:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800168c:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8001690:	635a      	str	r2, [r3, #52]	; 0x34
  while ((RCC->CSR & RCC_CSR_LSERDY) == 0)
 8001692:	6b4a      	ldr	r2, [r1, #52]	; 0x34
 8001694:	4b0c      	ldr	r3, [pc, #48]	; (80016c8 <main+0x98>)
 8001696:	0590      	lsls	r0, r2, #22
 8001698:	d5fb      	bpl.n	8001692 <main+0x62>
#endif

#if STM32_RTCSEL != STM32_RTCSEL_NOCLOCK
  /* If the backup domain hasn't been initialized yet then proceed with
     initialization.*/
  if ((RCC->CSR & RCC_CSR_RTCEN) == 0) {
 800169a:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800169c:	0251      	lsls	r1, r2, #9
 800169e:	d407      	bmi.n	80016b0 <main+0x80>
    /* Selects clock source.*/
    RCC->CSR |= STM32_RTCSEL;
 80016a0:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 80016a2:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 80016a6:	635a      	str	r2, [r3, #52]	; 0x34

    /* RTC clock enabled.*/
    RCC->CSR |= RCC_CSR_RTCEN;
 80016a8:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 80016aa:	f442 0280 	orr.w	r2, r2, #4194304	; 0x400000
 80016ae:	635a      	str	r2, [r3, #52]	; 0x34
 * @init
 */
void dmaInit(void) {
  int i;

  dma_streams_mask = 0U;
 80016b0:	f8df a024 	ldr.w	sl, [pc, #36]	; 80016d8 <main+0xa8>
 80016b4:	2100      	movs	r1, #0
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
 80016b6:	460b      	mov	r3, r1
    _stm32_dma_streams[i].channel->CCR = 0U;
 80016b8:	460d      	mov	r5, r1
 80016ba:	4a05      	ldr	r2, [pc, #20]	; (80016d0 <main+0xa0>)
 * @init
 */
void dmaInit(void) {
  int i;

  dma_streams_mask = 0U;
 80016bc:	4805      	ldr	r0, [pc, #20]	; (80016d4 <main+0xa4>)
 80016be:	f8df b01c 	ldr.w	fp, [pc, #28]	; 80016dc <main+0xac>
 80016c2:	f8ca 1000 	str.w	r1, [sl]
 80016c6:	e00d      	b.n	80016e4 <main+0xb4>
 80016c8:	40023800 	.word	0x40023800
 80016cc:	40007000 	.word	0x40007000
 80016d0:	08001ef8 	.word	0x08001ef8
 80016d4:	40026008 	.word	0x40026008
 80016d8:	2000085c 	.word	0x2000085c
 80016dc:	20000870 	.word	0x20000870
 80016e0:	f852 0c14 	ldr.w	r0, [r2, #-20]
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
    _stm32_dma_streams[i].channel->CCR = 0U;
 80016e4:	6005      	str	r5, [r0, #0]
    _stm32_dma_isr_redir[i].dma_func = NULL;
 80016e6:	f84b 5033 	str.w	r5, [fp, r3, lsl #3]
 */
void dmaInit(void) {
  int i;

  dma_streams_mask = 0U;
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
 80016ea:	3301      	adds	r3, #1
 80016ec:	2b07      	cmp	r3, #7
 80016ee:	f102 0214 	add.w	r2, r2, #20
    _stm32_dma_streams[i].channel->CCR = 0U;
 80016f2:	f04f 0400 	mov.w	r4, #0
 */
void dmaInit(void) {
  int i;

  dma_streams_mask = 0U;
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
 80016f6:	d1f3      	bne.n	80016e0 <main+0xb0>
static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
 80016f8:	f64f 71ff 	movw	r1, #65535	; 0xffff
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
 80016fc:	f24f 36f0 	movw	r6, #62448	; 0xf3f0
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
 8001700:	f64f 783f 	movw	r8, #65343	; 0xff3f
 *
 * @init
 */
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {

  sdp->vmt = &vmt;
 8001704:	4dc6      	ldr	r5, [pc, #792]	; (8001a20 <main+0x3f0>)
#if STM32_ADC_USE_ADC1
  /* Driver initialization.*/
  adcObjectInit(&ADCD1);
  ADCD1.adc = ADC1;
  ADCD1.dmastp  = STM32_DMA1_STREAM1;
  ADCD1.dmamode = STM32_DMA_CR_PL(STM32_ADC_ADC1_DMA_PRIORITY) |
 8001706:	f242 528a 	movw	r2, #9610	; 0x258a
 800170a:	462b      	mov	r3, r5
    _stm32_dma_streams[i].channel->CCR = 0U;
    _stm32_dma_isr_redir[i].dma_func = NULL;
  }
  DMA1->IFCR = 0xFFFFFFFFU;
 800170c:	f8df e350 	ldr.w	lr, [pc, #848]	; 8001a60 <main+0x430>
   */
#if defined(STM32L0XX)
  RCC->IOPENR |= AHB_EN_MASK;
  RCC->IOPSMENR |= AHB_LPEN_MASK;
#elif defined(STM32L1XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
 8001710:	4fc4      	ldr	r7, [pc, #784]	; (8001a24 <main+0x3f4>)
 8001712:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8001716:	f8ce 0004 	str.w	r0, [lr, #4]
 800171a:	f8d7 901c 	ldr.w	r9, [r7, #28]

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 800171e:	f647 40ff 	movw	r0, #31999	; 0x7cff
 8001722:	f049 093f 	orr.w	r9, r9, #63	; 0x3f
 8001726:	f8c7 901c 	str.w	r9, [r7, #28]
 800172a:	f8d7 9028 	ldr.w	r9, [r7, #40]	; 0x28
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 800172e:	f5ae 4ec0 	sub.w	lr, lr, #24576	; 0x6000
   */
#if defined(STM32L0XX)
  RCC->IOPENR |= AHB_EN_MASK;
  RCC->IOPSMENR |= AHB_LPEN_MASK;
#elif defined(STM32L1XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
 8001732:	f049 093f 	orr.w	r9, r9, #63	; 0x3f
 8001736:	f8c7 9028 	str.w	r9, [r7, #40]	; 0x28
  RCC->AHBLPENR |= AHB_LPEN_MASK;
 800173a:	f8d7 9028 	ldr.w	r9, [r7, #40]	; 0x28
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk));             /* clear bits to change               */
 800173e:	f64f 0cff 	movw	ip, #63743	; 0xf8ff
 8001742:	f049 093f 	orr.w	r9, r9, #63	; 0x3f
 8001746:	f8c7 9028 	str.w	r9, [r7, #40]	; 0x28
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
 800174a:	f04f 497c 	mov.w	r9, #4227858432	; 0xfc000000
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 800174e:	f8ce 4004 	str.w	r4, [lr, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8001752:	f8ce 9008 	str.w	r9, [lr, #8]
  gpiop->PUPDR   = config->pupdr;
 8001756:	f8df 930c 	ldr.w	r9, [pc, #780]	; 8001a64 <main+0x434>
 800175a:	f8ce 900c 	str.w	r9, [lr, #12]
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
  gpiop->AFRH    = config->afrh;
  gpiop->MODER   = config->moder;
 800175e:	f04f 4928 	mov.w	r9, #2818572288	; 0xa8000000
static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
 8001762:	f8ce 1014 	str.w	r1, [lr, #20]
  gpiop->AFRL    = config->afrl;
 8001766:	f8ce 4020 	str.w	r4, [lr, #32]
  gpiop->AFRH    = config->afrh;
 800176a:	f8ce 4024 	str.w	r4, [lr, #36]	; 0x24
  gpiop->MODER   = config->moder;
 800176e:	f8ce 9000 	str.w	r9, [lr]

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
 8001772:	f8df 92f4 	ldr.w	r9, [pc, #756]	; 8001a68 <main+0x438>
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8001776:	f8ce 4404 	str.w	r4, [lr, #1028]	; 0x404
  gpiop->OSPEEDR = config->ospeedr;
 800177a:	f8ce 6408 	str.w	r6, [lr, #1032]	; 0x408
  gpiop->PUPDR   = config->pupdr;
 800177e:	f8ce 940c 	str.w	r9, [lr, #1036]	; 0x40c
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8001782:	4ea9      	ldr	r6, [pc, #676]	; (8001a28 <main+0x3f8>)
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
 8001784:	f8ce 8414 	str.w	r8, [lr, #1044]	; 0x414

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
 8001788:	f8df 92e0 	ldr.w	r9, [pc, #736]	; 8001a6c <main+0x43c>
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
  gpiop->AFRH    = config->afrh;
  gpiop->MODER   = config->moder;
 800178c:	f44f 48a5 	mov.w	r8, #21120	; 0x5280

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
 8001790:	f8ce 4420 	str.w	r4, [lr, #1056]	; 0x420
  gpiop->AFRH    = config->afrh;
 8001794:	f8ce 4424 	str.w	r4, [lr, #1060]	; 0x424
  gpiop->MODER   = config->moder;
 8001798:	f8ce 8400 	str.w	r8, [lr, #1024]	; 0x400
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
 800179c:	f04f 4870 	mov.w	r8, #4026531840	; 0xf0000000
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 80017a0:	6074      	str	r4, [r6, #4]
  gpiop->OSPEEDR = config->ospeedr;
 80017a2:	f8c6 8008 	str.w	r8, [r6, #8]
  gpiop->PUPDR   = config->pupdr;
 80017a6:	f8c6 900c 	str.w	r9, [r6, #12]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 80017aa:	f108 48a0 	add.w	r8, r8, #1342177280	; 0x50000000
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
 80017ae:	6171      	str	r1, [r6, #20]
  gpiop->AFRL    = config->afrl;
 80017b0:	6234      	str	r4, [r6, #32]
  gpiop->AFRH    = config->afrh;
 80017b2:	6274      	str	r4, [r6, #36]	; 0x24
  gpiop->MODER   = config->moder;
 80017b4:	6034      	str	r4, [r6, #0]

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
 80017b6:	f04f 3655 	mov.w	r6, #1431655765	; 0x55555555
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 80017ba:	f508 3804 	add.w	r8, r8, #135168	; 0x21000
 80017be:	f8df 92b0 	ldr.w	r9, [pc, #688]	; 8001a70 <main+0x440>
 80017c2:	f8ce 4c04 	str.w	r4, [lr, #3076]	; 0xc04
  gpiop->OSPEEDR = config->ospeedr;
 80017c6:	f8ce 4c08 	str.w	r4, [lr, #3080]	; 0xc08
  gpiop->PUPDR   = config->pupdr;
 80017ca:	f8ce 6c0c 	str.w	r6, [lr, #3084]	; 0xc0c
  gpiop->ODR     = config->odr;
 80017ce:	f8ce 1c14 	str.w	r1, [lr, #3092]	; 0xc14
  gpiop->AFRL    = config->afrl;
 80017d2:	f8ce 4c20 	str.w	r4, [lr, #3104]	; 0xc20
  gpiop->AFRH    = config->afrh;
 80017d6:	f8ce 4c24 	str.w	r4, [lr, #3108]	; 0xc24
  gpiop->MODER   = config->moder;
 80017da:	f8ce 4c00 	str.w	r4, [lr, #3072]	; 0xc00

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
 80017de:	f8df e294 	ldr.w	lr, [pc, #660]	; 8001a74 <main+0x444>
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 80017e2:	f8c8 4004 	str.w	r4, [r8, #4]
  gpiop->OSPEEDR = config->ospeedr;
 80017e6:	f8c8 4008 	str.w	r4, [r8, #8]
  gpiop->PUPDR   = config->pupdr;
 80017ea:	f8c8 600c 	str.w	r6, [r8, #12]
  gpiop->ODR     = config->odr;
 80017ee:	f8c8 1014 	str.w	r1, [r8, #20]
 *
 * @init
 */
void adcObjectInit(ADCDriver *adcp) {

  adcp->state    = ADC_STOP;
 80017f2:	4e8e      	ldr	r6, [pc, #568]	; (8001a2c <main+0x3fc>)
  gpiop->AFRL    = config->afrl;
 80017f4:	f8c8 4020 	str.w	r4, [r8, #32]
  gpiop->AFRH    = config->afrh;
 80017f8:	f8c8 4024 	str.w	r4, [r8, #36]	; 0x24
  gpiop->MODER   = config->moder;
 80017fc:	f8c8 4000 	str.w	r4, [r8]
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
 8001800:	f04f 080f 	mov.w	r8, #15
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8001804:	f8c9 4004 	str.w	r4, [r9, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8001808:	f8c9 8008 	str.w	r8, [r9, #8]
  gpiop->PUPDR   = config->pupdr;
 800180c:	f8c9 e00c 	str.w	lr, [r9, #12]
  gpiop->ODR     = config->odr;
 8001810:	f8c9 1014 	str.w	r1, [r9, #20]
  gpiop->AFRL    = config->afrl;
 8001814:	f8c9 4020 	str.w	r4, [r9, #32]
  gpiop->AFRH    = config->afrh;
 8001818:	f8c9 4024 	str.w	r4, [r9, #36]	; 0x24
  gpiop->MODER   = config->moder;
 800181c:	f8c9 4000 	str.w	r4, [r9]
void adc_lld_init(void) {

#if STM32_ADC_USE_ADC1
  /* Driver initialization.*/
  adcObjectInit(&ADCD1);
  ADCD1.adc = ADC1;
 8001820:	f5a9 4970 	sub.w	r9, r9, #61440	; 0xf000
 8001824:	f8c6 9028 	str.w	r9, [r6, #40]	; 0x28
  ADCD1.dmastp  = STM32_DMA1_STREAM1;
 8001828:	f8df 924c 	ldr.w	r9, [pc, #588]	; 8001a78 <main+0x448>

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 800182c:	f8df 824c 	ldr.w	r8, [pc, #588]	; 8001a7c <main+0x44c>
  ADCD1.dmamode = STM32_DMA_CR_PL(STM32_ADC_ADC1_DMA_PRIORITY) |
 8001830:	6332      	str	r2, [r6, #48]	; 0x30

#if STM32_ADC_USE_ADC1
  /* Driver initialization.*/
  adcObjectInit(&ADCD1);
  ADCD1.adc = ADC1;
  ADCD1.dmastp  = STM32_DMA1_STREAM1;
 8001832:	f8c6 902c 	str.w	r9, [r6, #44]	; 0x2c
 8001836:	2201      	movs	r2, #1
 8001838:	f8df e244 	ldr.w	lr, [pc, #580]	; 8001a80 <main+0x450>
 800183c:	f04f 0960 	mov.w	r9, #96	; 0x60
 8001840:	7032      	strb	r2, [r6, #0]
  adcp->config   = NULL;
 8001842:	6074      	str	r4, [r6, #4]
  adcp->samples  = NULL;
 8001844:	60b4      	str	r4, [r6, #8]
  adcp->depth    = 0;
 8001846:	60f4      	str	r4, [r6, #12]
  adcp->grpp     = NULL;
 8001848:	6134      	str	r4, [r6, #16]
#if ADC_USE_WAIT == TRUE
  adcp->thread   = NULL;
 800184a:	6174      	str	r4, [r6, #20]
void chMtxObjectInit(mutex_t *mp) {

  chDbgCheck(mp != NULL);

  queue_init(&mp->m_queue);
  mp->m_owner = NULL;
 800184c:	6234      	str	r4, [r6, #32]
 800184e:	f888 9312 	strb.w	r9, [r8, #786]	; 0x312
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8001852:	f44f 2980 	mov.w	r9, #262144	; 0x40000
 8001856:	f8c8 9180 	str.w	r9, [r8, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 800185a:	f8c8 9000 	str.w	r9, [r8]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 800185e:	f106 0918 	add.w	r9, r6, #24
 8001862:	f843 eb04 	str.w	lr, [r3], #4
 */
void chOQObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                    qnotify_t onfy, void *link) {

  chThdQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
 8001866:	f04f 0e10 	mov.w	lr, #16
 800186a:	f8c6 9018 	str.w	r9, [r6, #24]
  tqp->p_prev = (thread_t *)tqp;
 800186e:	f8c6 901c 	str.w	r9, [r6, #28]
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {

  esp->es_next = (event_listener_t *)esp;
 8001872:	606b      	str	r3, [r5, #4]
 */
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {

  chThdQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
 8001874:	616c      	str	r4, [r5, #20]
 */
void chOQObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                    qnotify_t onfy, void *link) {

  chThdQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
 8001876:	f8c5 e038 	str.w	lr, [r5, #56]	; 0x38

#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  /* Free running counter mode.*/

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
 800187a:	6a7b      	ldr	r3, [r7, #36]	; 0x24

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 800187c:	f8df 9204 	ldr.w	r9, [pc, #516]	; 8001a84 <main+0x454>

#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  /* Free running counter mode.*/

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
 8001880:	4313      	orrs	r3, r2
 8001882:	627b      	str	r3, [r7, #36]	; 0x24

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 8001884:	f8d9 3008 	ldr.w	r3, [r9, #8]
  osalEventObjectInit(&sdp->event);
  sdp->state = SD_STOP;
 8001888:	722a      	strb	r2, [r5, #8]
 800188a:	4313      	orrs	r3, r2
  iqp->q_counter = 0;
  iqp->q_buffer  = bp;
  iqp->q_rdptr   = bp;
  iqp->q_wrptr   = bp;
  iqp->q_top     = bp + size;
  iqp->q_notify  = infy;
 800188c:	62ac      	str	r4, [r5, #40]	; 0x28
  iqp->q_link    = link;
 800188e:	62ed      	str	r5, [r5, #44]	; 0x2c
  oqp->q_buffer  = bp;
  oqp->q_rdptr   = bp;
  oqp->q_wrptr   = bp;
  oqp->q_top     = bp + size;
  oqp->q_notify  = onfy;
  oqp->q_link    = link;
 8001890:	652d      	str	r5, [r5, #80]	; 0x50
 8001892:	f8c9 3008 	str.w	r3, [r9, #8]

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 8001896:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800189a:	6298      	str	r0, [r3, #40]	; 0x28
  oqp->q_counter = size;
  oqp->q_buffer  = bp;
  oqp->q_rdptr   = bp;
  oqp->q_wrptr   = bp;
  oqp->q_top     = bp + size;
  oqp->q_notify  = onfy;
 800189c:	f8df 91e8 	ldr.w	r9, [pc, #488]	; 8001a88 <main+0x458>
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 80018a0:	62d9      	str	r1, [r3, #44]	; 0x2c
 */
void sd_lld_init(void) {

#if STM32_SERIAL_USE_USART1
  sdObjectInit(&SD1, NULL, notify1);
  SD1.usart = USART1;
 80018a2:	4963      	ldr	r1, [pc, #396]	; (8001a30 <main+0x400>)
  STM32_ST_TIM->CCMR1  = 0;
 80018a4:	619c      	str	r4, [r3, #24]
 80018a6:	f8c5 904c 	str.w	r9, [r5, #76]	; 0x4c
  STM32_ST_TIM->CCR[0] = 0;
 80018aa:	635c      	str	r4, [r3, #52]	; 0x34
 80018ac:	6769      	str	r1, [r5, #116]	; 0x74
  STM32_ST_TIM->DIER   = 0;
 80018ae:	60dc      	str	r4, [r3, #12]
  STM32_ST_TIM->CR2    = 0;
 80018b0:	605c      	str	r4, [r3, #4]
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
 80018b2:	615a      	str	r2, [r3, #20]
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;
 80018b4:	601a      	str	r2, [r3, #0]
  chThdQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
  oqp->q_buffer  = bp;
  oqp->q_rdptr   = bp;
  oqp->q_wrptr   = bp;
  oqp->q_top     = bp + size;
 80018b6:	f105 0374 	add.w	r3, r5, #116	; 0x74
 80018ba:	642b      	str	r3, [r5, #64]	; 0x40
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 80018bc:	f105 030c 	add.w	r3, r5, #12
 80018c0:	60eb      	str	r3, [r5, #12]
  tqp->p_prev = (thread_t *)tqp;
 80018c2:	612b      	str	r3, [r5, #16]
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {

  chThdQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
  iqp->q_buffer  = bp;
 80018c4:	f105 0354 	add.w	r3, r5, #84	; 0x54
 80018c8:	61ab      	str	r3, [r5, #24]
  iqp->q_rdptr   = bp;
 80018ca:	626b      	str	r3, [r5, #36]	; 0x24
  iqp->q_wrptr   = bp;
 80018cc:	622b      	str	r3, [r5, #32]
  iqp->q_top     = bp + size;
 80018ce:	f105 0364 	add.w	r3, r5, #100	; 0x64
 80018d2:	61eb      	str	r3, [r5, #28]
void chOQObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                    qnotify_t onfy, void *link) {

  chThdQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
  oqp->q_buffer  = bp;
 80018d4:	63eb      	str	r3, [r5, #60]	; 0x3c
  oqp->q_rdptr   = bp;
 80018d6:	64ab      	str	r3, [r5, #72]	; 0x48
  oqp->q_wrptr   = bp;
 80018d8:	646b      	str	r3, [r5, #68]	; 0x44
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 80018da:	f105 0330 	add.w	r3, r5, #48	; 0x30
 * @brief   Port-related initialization code.
 */
static inline void port_init(void) {

  /* Initialization of the vector table and priority related settings.*/
  SCB->VTOR = CORTEX_VTOR_INIT;
 80018de:	4955      	ldr	r1, [pc, #340]	; (8001a34 <main+0x404>)
 80018e0:	9203      	str	r2, [sp, #12]
 80018e2:	632b      	str	r3, [r5, #48]	; 0x30
  tqp->p_prev = (thread_t *)tqp;
 80018e4:	636b      	str	r3, [r5, #52]	; 0x34

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 80018e6:	2380      	movs	r3, #128	; 0x80
 80018e8:	f888 331c 	strb.w	r3, [r8, #796]	; 0x31c
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 80018ec:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
 80018f0:	f8c8 3180 	str.w	r3, [r8, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 80018f4:	f8c8 3000 	str.w	r3, [r8]
 80018f8:	608c      	str	r4, [r1, #8]
__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 80018fa:	f8d1 900c 	ldr.w	r9, [r1, #12]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk));             /* clear bits to change               */
  reg_value  =  (reg_value                                   |
 80018fe:	4b4e      	ldr	r3, [pc, #312]	; (8001a38 <main+0x408>)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk));             /* clear bits to change               */
 8001900:	ea09 0c0c 	and.w	ip, r9, ip
  reg_value  =  (reg_value                                   |
 8001904:	ea4c 0303 	orr.w	r3, ip, r3

  /* Initializing priority grouping.*/
  NVIC_SetPriorityGrouping(CORTEX_PRIGROUP_INIT);

  /* DWT cycle counter enable, note, the M7 requires DWT unlocking.*/
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 8001908:	f8df c180 	ldr.w	ip, [pc, #384]	; 8001a8c <main+0x45c>
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8)                       );              /* Insert write key and priorty group */
  SCB->AIRCR =  reg_value;
 800190c:	60cb      	str	r3, [r1, #12]
 800190e:	f8dc 300c 	ldr.w	r3, [ip, #12]
#if CORTEX_MODEL == 7
  DWT->LAR = 0xC5ACCE55U;
#endif
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 8001912:	f8df 917c 	ldr.w	r9, [pc, #380]	; 8001a90 <main+0x460>

  /* Initializing priority grouping.*/
  NVIC_SetPriorityGrouping(CORTEX_PRIGROUP_INIT);

  /* DWT cycle counter enable, note, the M7 requires DWT unlocking.*/
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 8001916:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 800191a:	f8cc 300c 	str.w	r3, [ip, #12]
#if CORTEX_MODEL == 7
  DWT->LAR = 0xC5ACCE55U;
#endif
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 800191e:	f8d9 c000 	ldr.w	ip, [r9]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8001922:	4b46      	ldr	r3, [pc, #280]	; (8001a3c <main+0x40c>)
 8001924:	ea4c 0c02 	orr.w	ip, ip, r2
 8001928:	f8c9 c000 	str.w	ip, [r9]
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if((int32_t)IRQn < 0) {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800192c:	f04f 0920 	mov.w	r9, #32
 8001930:	f881 e01f 	strb.w	lr, [r1, #31]
 *
 * @init
 */
void chTMObjectInit(time_measurement_t *tmp) {

  tmp->best       = (rtcnt_t)-1;
 8001934:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8001938:	f881 9022 	strb.w	r9, [r1, #34]	; 0x22
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.vt_next = (virtual_timer_t *)&ch.vtlist;
 800193c:	f103 011c 	add.w	r1, r3, #28
 8001940:	61d9      	str	r1, [r3, #28]
  ch.vtlist.vt_prev = (virtual_timer_t *)&ch.vtlist;
 8001942:	6219      	str	r1, [r3, #32]
  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = (rtcnt_t)0;
  chTMObjectInit(&tm);
  chTMStartMeasurementX(&tm);
 8001944:	eb0d 000e 	add.w	r0, sp, lr
 *
 * @init
 */
void chTMObjectInit(time_measurement_t *tmp) {

  tmp->best       = (rtcnt_t)-1;
 8001948:	9204      	str	r2, [sp, #16]
  ch.vtlist.vt_delta = (systime_t)-1;
 800194a:	849a      	strh	r2, [r3, #36]	; 0x24
 * @notapi
 */
void _scheduler_init(void) {

  queue_init(&ch.rlist.r_queue);
  ch.rlist.r_prio = NOPRIO;
 800194c:	609c      	str	r4, [r3, #8]
  tmp->worst      = (rtcnt_t)0;
  tmp->last       = (rtcnt_t)0;
  tmp->n          = (ucnt_t)0;
  tmp->cumulative = (rttime_t)0;
 800194e:	2200      	movs	r2, #0
#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.vt_systime = (systime_t)0;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  ch.vtlist.vt_lasttime = (systime_t)0;
 8001950:	84dc      	strh	r4, [r3, #38]	; 0x26
  time_measurement_t tm;

  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = (rtcnt_t)0;
 8001952:	671c      	str	r4, [r3, #112]	; 0x70
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.vt_next = (virtual_timer_t *)&ch.vtlist;
  ch.vtlist.vt_prev = (virtual_timer_t *)&ch.vtlist;
 8001954:	9302      	str	r3, [sp, #8]
 8001956:	601b      	str	r3, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 8001958:	605b      	str	r3, [r3, #4]
#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.r_newer = (thread_t *)&ch.rlist;
 800195a:	611b      	str	r3, [r3, #16]
  ch.rlist.r_older = (thread_t *)&ch.rlist;
 800195c:	615b      	str	r3, [r3, #20]

  tmp->best       = (rtcnt_t)-1;
  tmp->worst      = (rtcnt_t)0;
  tmp->last       = (rtcnt_t)0;
  tmp->n          = (ucnt_t)0;
  tmp->cumulative = (rttime_t)0;
 800195e:	2300      	movs	r3, #0
 8001960:	e9cd 2308 	strd	r2, r3, [sp, #32]
 * @init
 */
void chTMObjectInit(time_measurement_t *tmp) {

  tmp->best       = (rtcnt_t)-1;
  tmp->worst      = (rtcnt_t)0;
 8001964:	9405      	str	r4, [sp, #20]
  tmp->last       = (rtcnt_t)0;
 8001966:	9406      	str	r4, [sp, #24]
  tmp->n          = (ucnt_t)0;
 8001968:	9407      	str	r4, [sp, #28]
  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = (rtcnt_t)0;
  chTMObjectInit(&tm);
  chTMStartMeasurementX(&tm);
 800196a:	f000 f9a9 	bl	8001cc0 <chTMStartMeasurementX.constprop.30>
  chTMStopMeasurementX(&tm);
 800196e:	a804      	add	r0, sp, #16
 8001970:	f7fe fede 	bl	8000730 <chTMStopMeasurementX>
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8001974:	4b32      	ldr	r3, [pc, #200]	; (8001a40 <main+0x410>)
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  nextmem = (uint8_t *)MEM_ALIGN_NEXT(__heap_base__);
 8001976:	f8df c11c 	ldr.w	ip, [pc, #284]	; 8001a94 <main+0x464>
  endmem = (uint8_t *)MEM_ALIGN_PREV(__heap_end__);
 800197a:	4832      	ldr	r0, [pc, #200]	; (8001a44 <main+0x414>)
 800197c:	f103 0e10 	add.w	lr, r3, #16
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  nextmem = (uint8_t *)MEM_ALIGN_NEXT(__heap_base__);
 8001980:	f02c 0307 	bic.w	r3, ip, #7
 8001984:	9301      	str	r3, [sp, #4]
  endmem = (uint8_t *)MEM_ALIGN_PREV(__heap_end__);
 8001986:	f020 0c07 	bic.w	ip, r0, #7
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
  tp->p_flags = CH_FLAG_MODE_STATIC;
 800198a:	9b02      	ldr	r3, [sp, #8]
  ch.tm.offset = tm.last;
 800198c:	9806      	ldr	r0, [sp, #24]
 800198e:	f1ae 0110 	sub.w	r1, lr, #16
 8001992:	f8c1 e010 	str.w	lr, [r1, #16]
  tqp->p_prev = (thread_t *)tqp;
 8001996:	f8c1 e014 	str.w	lr, [r1, #20]
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
 800199a:	9a03      	ldr	r2, [sp, #12]
 800199c:	6718      	str	r0, [r3, #112]	; 0x70
 * @notapi
 */
void _heap_init(void) {

  default_heap.h_provider = chCoreAlloc;
  default_heap.h_free.h.u.next = NULL;
 800199e:	608c      	str	r4, [r1, #8]
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 80019a0:	6958      	ldr	r0, [r3, #20]
  default_heap.h_free.h.size = 0;
 80019a2:	60cc      	str	r4, [r1, #12]
 80019a4:	4928      	ldr	r1, [pc, #160]	; (8001a48 <main+0x418>)
 80019a6:	f8ce 4008 	str.w	r4, [lr, #8]
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
 80019aa:	f04f 0e40 	mov.w	lr, #64	; 0x40
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 80019ae:	6418      	str	r0, [r3, #64]	; 0x40
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
 80019b0:	f8c3 e034 	str.w	lr, [r3, #52]	; 0x34
  tp->p_flags = CH_FLAG_MODE_STATIC;
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
 80019b4:	f8c3 e068 	str.w	lr, [r3, #104]	; 0x68
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
  tp->p_flags = CH_FLAG_MODE_STATIC;
 80019b8:	f883 4049 	strb.w	r4, [r3, #73]	; 0x49
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
  tp->p_mtxlist = NULL;
 80019bc:	665c      	str	r4, [r3, #100]	; 0x64
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->p_epending = (eventmask_t)0;
 80019be:	661c      	str	r4, [r3, #96]	; 0x60
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
 80019c0:	f883 204a 	strb.w	r2, [r3, #74]	; 0x4a
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
 80019c4:	645c      	str	r4, [r3, #68]	; 0x44
  REG_INSERT(tp);
 80019c6:	63db      	str	r3, [r3, #60]	; 0x3c
 80019c8:	6101      	str	r1, [r0, #16]
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->p_next = (thread_t *)tlp;
 80019ca:	f103 0050 	add.w	r0, r3, #80	; 0x50
 80019ce:	6159      	str	r1, [r3, #20]
  _dbg_trace_init();
#endif

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
  setcurrp(_thread_init(&ch.mainthread, NORMALPRIO));
 80019d0:	6199      	str	r1, [r3, #24]
 80019d2:	6518      	str	r0, [r3, #80]	; 0x50
 *
 * @notapi
 */
void _heap_init(void) {

  default_heap.h_provider = chCoreAlloc;
 80019d4:	491a      	ldr	r1, [pc, #104]	; (8001a40 <main+0x410>)
 80019d6:	481d      	ldr	r0, [pc, #116]	; (8001a4c <main+0x41c>)
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  nextmem = (uint8_t *)MEM_ALIGN_NEXT(__heap_base__);
 80019d8:	f8df e0bc 	ldr.w	lr, [pc, #188]	; 8001a98 <main+0x468>
 80019dc:	6008      	str	r0, [r1, #0]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 80019de:	f103 0154 	add.w	r1, r3, #84	; 0x54
  endmem = (uint8_t *)MEM_ALIGN_PREV(__heap_end__);
 80019e2:	481b      	ldr	r0, [pc, #108]	; (8001a50 <main+0x420>)
 80019e4:	6559      	str	r1, [r3, #84]	; 0x54
  tqp->p_prev = (thread_t *)tqp;
 80019e6:	6599      	str	r1, [r3, #88]	; 0x58
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  nextmem = (uint8_t *)MEM_ALIGN_NEXT(__heap_base__);
 80019e8:	9901      	ldr	r1, [sp, #4]
#else
  /* Now this instructions flow becomes the idle thread.*/
  setcurrp(_thread_init(&ch.mainthread, IDLEPRIO));
#endif

  currp->p_state = CH_STATE_CURRENT;
 80019ea:	f883 2048 	strb.w	r2, [r3, #72]	; 0x48
 80019ee:	f8ce 1000 	str.w	r1, [lr]
  endmem = (uint8_t *)MEM_ALIGN_PREV(__heap_end__);
 80019f2:	f8c0 c000 	str.w	ip, [r0]
 80019f6:	f384 8811 	msr	BASEPRI, r4
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80019fa:	b662      	cpsie	i
 80019fc:	4c15      	ldr	r4, [pc, #84]	; (8001a54 <main+0x424>)
 80019fe:	6999      	ldr	r1, [r3, #24]
#if CH_CFG_NO_IDLE_THREAD == FALSE
  {
  /* This thread has the lowest priority in the system, its role is just to
     serve interrupts in its context while keeping the lowest energy saving
     mode compatible with the system status.*/
    thread_t *tp =  chThdCreateStatic(ch.idle_thread_wa,
 8001a00:	f103 0078 	add.w	r0, r3, #120	; 0x78
 8001a04:	618c      	str	r4, [r1, #24]
 8001a06:	4b14      	ldr	r3, [pc, #80]	; (8001a58 <main+0x428>)
 8001a08:	21d8      	movs	r1, #216	; 0xd8
 8001a0a:	f000 f901 	bl	8001c10 <chThdCreateStatic.constprop.32>
 * @xclass
 */
static inline void chRegSetThreadNameX(thread_t *tp, const char *name) {

#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = name;
 8001a0e:	4b13      	ldr	r3, [pc, #76]	; (8001a5c <main+0x42c>)
 8001a10:	6183      	str	r3, [r0, #24]

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8001a12:	f389 8811 	msr	BASEPRI, r9
void sd_lld_start(SerialDriver *sdp, const SerialConfig *config) {

  if (config == NULL)
    config = &default_config;

  if (sdp->state == SD_STOP) {
 8001a16:	7a2b      	ldrb	r3, [r5, #8]
 8001a18:	2b01      	cmp	r3, #1
 8001a1a:	f000 8082 	beq.w	8001b22 <main+0x4f2>
 8001a1e:	e03d      	b.n	8001a9c <main+0x46c>
 8001a20:	20000ba0 	.word	0x20000ba0
 8001a24:	40023800 	.word	0x40023800
 8001a28:	40020800 	.word	0x40020800
 8001a2c:	200008a8 	.word	0x200008a8
 8001a30:	40013800 	.word	0x40013800
 8001a34:	e000ed00 	.word	0xe000ed00
 8001a38:	05fa0300 	.word	0x05fa0300
 8001a3c:	20000c18 	.word	0x20000c18
 8001a40:	20000b80 	.word	0x20000b80
 8001a44:	20004000 	.word	0x20004000
 8001a48:	20000c44 	.word	0x20000c44
 8001a4c:	080004c1 	.word	0x080004c1
 8001a50:	20000818 	.word	0x20000818
 8001a54:	08001f70 	.word	0x08001f70
 8001a58:	08000571 	.word	0x08000571
 8001a5c:	08002070 	.word	0x08002070
 8001a60:	40026000 	.word	0x40026000
 8001a64:	65555568 	.word	0x65555568
 8001a68:	55550505 	.word	0x55550505
 8001a6c:	05555555 	.word	0x05555555
 8001a70:	40021400 	.word	0x40021400
 8001a74:	55555550 	.word	0x55555550
 8001a78:	08001ee0 	.word	0x08001ee0
 8001a7c:	e000e100 	.word	0xe000e100
 8001a80:	08002080 	.word	0x08002080
 8001a84:	e0042000 	.word	0xe0042000
 8001a88:	08000241 	.word	0x08000241
 8001a8c:	e000edf0 	.word	0xe000edf0
 8001a90:	e0001000 	.word	0xe0001000
 8001a94:	20000d6f 	.word	0x20000d6f
 8001a98:	2000086c 	.word	0x2000086c
#if STM32_HAS_USART6
  if ((sdp->usart == USART1) || (sdp->usart == USART6))
#else
  if (sdp->usart == USART1)
#endif
    u->BRR = STM32_PCLK2 / config->speed;
 8001a9c:	f240 3241 	movw	r2, #833	; 0x341
 *
 * @param[in] sdp       pointer to a @p SerialDriver object
 * @param[in] config    the architecture-dependent serial driver configuration
 */
static void usart_init(SerialDriver *sdp, const SerialConfig *config) {
  USART_TypeDef *u = sdp->usart;
 8001aa0:	6f6b      	ldr	r3, [r5, #116]	; 0x74
    u->BRR = STM32_PCLK2 / config->speed;
  else
    u->BRR = STM32_PCLK1 / config->speed;

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 8001aa2:	f244 0040 	movw	r0, #16448	; 0x4040
#if STM32_HAS_USART6
  if ((sdp->usart == USART1) || (sdp->usart == USART6))
#else
  if (sdp->usart == USART1)
#endif
    u->BRR = STM32_PCLK2 / config->speed;
 8001aa6:	609a      	str	r2, [r3, #8]
    u->BRR = STM32_PCLK1 / config->speed;

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
  u->CR3 = config->cr3 | USART_CR3_EIE;
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
 8001aa8:	f242 122c 	movw	r2, #8492	; 0x212c
  else
    u->BRR = STM32_PCLK1 / config->speed;

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
  u->CR3 = config->cr3 | USART_CR3_EIE;
 8001aac:	2101      	movs	r1, #1
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
                         USART_CR1_RXNEIE | USART_CR1_TE |
                         USART_CR1_RE;
  u->SR = 0;
 8001aae:	2400      	movs	r4, #0
    u->BRR = STM32_PCLK2 / config->speed;
  else
    u->BRR = STM32_PCLK1 / config->speed;

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 8001ab0:	6118      	str	r0, [r3, #16]
  u->CR3 = config->cr3 | USART_CR3_EIE;
 8001ab2:	6159      	str	r1, [r3, #20]
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
 8001ab4:	60da      	str	r2, [r3, #12]
                         USART_CR1_RXNEIE | USART_CR1_TE |
                         USART_CR1_RE;
  u->SR = 0;
 8001ab6:	601c      	str	r4, [r3, #0]

  osalSysLock();
  osalDbgAssert((sdp->state == SD_STOP) || (sdp->state == SD_READY),
                "invalid state");
  sd_lld_start(sdp, config);
  sdp->state = SD_READY;
 8001ab8:	2202      	movs	r2, #2
  (void)u->SR;  /* SR reset step 1.*/
 8001aba:	6819      	ldr	r1, [r3, #0]
  (void)u->DR;  /* SR reset step 2.*/
 8001abc:	685b      	ldr	r3, [r3, #4]
 8001abe:	722a      	strb	r2, [r5, #8]
 8001ac0:	f384 8811 	msr	BASEPRI, r4
  /*
   * Activates the serial driver 1 using the driver default configuration.
   * PA9(TX) and PA10(RX) are routed to USART1.
   */
  sdStart(&SD1, NULL);
  palSetPadMode(GPIOA, 9, PAL_MODE_ALTERNATE(7));
 8001ac4:	f44f 7000 	mov.w	r0, #512	; 0x200
 8001ac8:	f000 f93a 	bl	8001d40 <_pal_lld_setgroupmode.constprop.4>
  palSetPadMode(GPIOA, 10, PAL_MODE_ALTERNATE(7));
 8001acc:	f44f 6080 	mov.w	r0, #1024	; 0x400
 8001ad0:	f000 f936 	bl	8001d40 <_pal_lld_setgroupmode.constprop.4>
 8001ad4:	2320      	movs	r3, #32
 8001ad6:	f383 8811 	msr	BASEPRI, r3
 * @notapi
 */
void adc_lld_start(ADCDriver *adcp) {

  /* If in stopped state then enables the ADC and DMA clocks.*/
  if (adcp->state == ADC_STOP) {
 8001ada:	7832      	ldrb	r2, [r6, #0]
  osalDbgCheck(adcp != NULL);

  osalSysLock();
  osalDbgAssert((adcp->state == ADC_STOP) || (adcp->state == ADC_READY),
                "invalid state");
  adcp->config = config;
 8001adc:	6074      	str	r4, [r6, #4]
 8001ade:	2a01      	cmp	r2, #1
 8001ae0:	4c41      	ldr	r4, [pc, #260]	; (8001be8 <main+0x5b8>)
 8001ae2:	d02a      	beq.n	8001b3a <main+0x50a>
  adc_lld_start(adcp);
  adcp->state = ADC_READY;
 8001ae4:	2302      	movs	r3, #2
 8001ae6:	7033      	strb	r3, [r6, #0]
 8001ae8:	2300      	movs	r3, #0
 8001aea:	f383 8811 	msr	BASEPRI, r3
  adcStart(&ADCD1, NULL);

  /*
   * Creates the example threads.
   */
  chThdCreateStatic(waThread1, sizeof(waThread1), NORMALPRIO+1, Thread1, NULL);
 8001aee:	4b3f      	ldr	r3, [pc, #252]	; (8001bec <main+0x5bc>)
 8001af0:	2241      	movs	r2, #65	; 0x41
 8001af2:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8001af6:	483e      	ldr	r0, [pc, #248]	; (8001bf0 <main+0x5c0>)
 8001af8:	f000 f88a 	bl	8001c10 <chThdCreateStatic.constprop.32>
   * sleeping in a loop and check the button state, when the button is
   * pressed the test procedure is launched.
   */
  while (true) {
    //if (palReadPad(GPIOA, GPIOA_BUTTON))
	  palSetPad(GPIOB, GPIOB_LED4);
 8001afc:	2540      	movs	r5, #64	; 0x40

  /*
   * Creates the example threads.
   */
  chThdCreateStatic(waThread1, sizeof(waThread1), NORMALPRIO+1, Thread1, NULL);
  chThdCreateStatic(waThread2, sizeof(waThread2), NORMALPRIO+1, Thread2, NULL);
 8001afe:	4b3d      	ldr	r3, [pc, #244]	; (8001bf4 <main+0x5c4>)
 8001b00:	2241      	movs	r2, #65	; 0x41
 8001b02:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8001b06:	483c      	ldr	r0, [pc, #240]	; (8001bf8 <main+0x5c8>)
 8001b08:	f000 f882 	bl	8001c10 <chThdCreateStatic.constprop.32>
   * sleeping in a loop and check the button state, when the button is
   * pressed the test procedure is launched.
   */
  while (true) {
    //if (palReadPad(GPIOA, GPIOA_BUTTON))
	  palSetPad(GPIOB, GPIOB_LED4);
 8001b0c:	462e      	mov	r6, r5
 8001b0e:	4c3b      	ldr	r4, [pc, #236]	; (8001bfc <main+0x5cc>)
 8001b10:	8326      	strh	r6, [r4, #24]
	  chThdSleepMilliseconds(200);
 8001b12:	20c8      	movs	r0, #200	; 0xc8
 8001b14:	f7ff f84c 	bl	8000bb0 <chThdSleep>
	  palClearPad(GPIOB, GPIOB_LED4);
 8001b18:	8365      	strh	r5, [r4, #26]
	  chThdSleepMilliseconds(200);
 8001b1a:	20c8      	movs	r0, #200	; 0xc8
 8001b1c:	f7ff f848 	bl	8000bb0 <chThdSleep>
 8001b20:	e7f6      	b.n	8001b10 <main+0x4e0>
    config = &default_config;

  if (sdp->state == SD_STOP) {
#if STM32_SERIAL_USE_USART1
    if (&SD1 == sdp) {
      rccEnableUSART1(FALSE);
 8001b22:	6a3b      	ldr	r3, [r7, #32]

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8001b24:	22c0      	movs	r2, #192	; 0xc0
 8001b26:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8001b2a:	623b      	str	r3, [r7, #32]
 8001b2c:	f888 2325 	strb.w	r2, [r8, #805]	; 0x325
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8001b30:	f8c8 9184 	str.w	r9, [r8, #388]	; 0x184
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8001b34:	f8c8 9004 	str.w	r9, [r8, #4]
 8001b38:	e7b0      	b.n	8001a9c <main+0x46c>
#if STM32_ADC_USE_ADC1
    if (&ADCD1 == adcp) {
      bool b = dmaStreamAllocate(adcp->dmastp,
 8001b3a:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
                       void *param) {

  osalDbgCheck(dmastp != NULL);

  /* Checks if the stream is already taken.*/
  if ((dma_streams_mask & (1U << dmastp->selfindex)) != 0U)
 8001b3c:	f8da 1000 	ldr.w	r1, [sl]
 8001b40:	7c58      	ldrb	r0, [r3, #17]
 8001b42:	4082      	lsls	r2, r0
 8001b44:	420a      	tst	r2, r1
 8001b46:	d14c      	bne.n	8001be2 <main+0x5b2>
    return true;

  /* Installs the DMA handler.*/
  _stm32_dma_isr_redir[dmastp->selfindex].dma_func  = func;
  _stm32_dma_isr_redir[dmastp->selfindex].dma_param = param;
 8001b48:	eb0b 02c0 	add.w	r2, fp, r0, lsl #3
  /* Checks if the stream is already taken.*/
  if ((dma_streams_mask & (1U << dmastp->selfindex)) != 0U)
    return true;

  /* Installs the DMA handler.*/
  _stm32_dma_isr_redir[dmastp->selfindex].dma_func  = func;
 8001b4c:	4d2c      	ldr	r5, [pc, #176]	; (8001c00 <main+0x5d0>)
  _stm32_dma_isr_redir[dmastp->selfindex].dma_param = param;
 8001b4e:	6054      	str	r4, [r2, #4]

  /* Enabling DMA clocks required by the current streams set.*/
  if ((dma_streams_mask & STM32_DMA1_STREAMS_MASK) == 0U) {
 8001b50:	064a      	lsls	r2, r1, #25
  /* Checks if the stream is already taken.*/
  if ((dma_streams_mask & (1U << dmastp->selfindex)) != 0U)
    return true;

  /* Installs the DMA handler.*/
  _stm32_dma_isr_redir[dmastp->selfindex].dma_func  = func;
 8001b52:	f84b 5030 	str.w	r5, [fp, r0, lsl #3]
  _stm32_dma_isr_redir[dmastp->selfindex].dma_param = param;

  /* Enabling DMA clocks required by the current streams set.*/
  if ((dma_streams_mask & STM32_DMA1_STREAMS_MASK) == 0U) {
 8001b56:	d104      	bne.n	8001b62 <main+0x532>
    rccEnableDMA1(false);
 8001b58:	482a      	ldr	r0, [pc, #168]	; (8001c04 <main+0x5d4>)
 8001b5a:	69c2      	ldr	r2, [r0, #28]
 8001b5c:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 8001b60:	61c2      	str	r2, [r0, #28]
    rccEnableDMA2(false);
  }
#endif

  /* Putting the stream in a safe state.*/
  dmaStreamDisable(dmastp);
 8001b62:	685a      	ldr	r2, [r3, #4]
 8001b64:	681d      	ldr	r5, [r3, #0]
 8001b66:	6814      	ldr	r4, [r2, #0]
 8001b68:	200f      	movs	r0, #15
 8001b6a:	f024 040f 	bic.w	r4, r4, #15
 8001b6e:	6014      	str	r4, [r2, #0]
 8001b70:	7c1f      	ldrb	r7, [r3, #16]
  dmastp->channel->CCR = STM32_DMA_CCR_RESET_VALUE;

  /* Enables the associated IRQ vector if not alread enabled and if a
     callback is defined.*/
  if (((dma_streams_mask & dmastp->cmask) == 0U) &&
 8001b72:	689c      	ldr	r4, [r3, #8]
    rccEnableDMA2(false);
  }
#endif

  /* Putting the stream in a safe state.*/
  dmaStreamDisable(dmastp);
 8001b74:	40b8      	lsls	r0, r7
 8001b76:	6068      	str	r0, [r5, #4]
  dmastp->channel->CCR = STM32_DMA_CCR_RESET_VALUE;

  /* Enables the associated IRQ vector if not alread enabled and if a
     callback is defined.*/
  if (((dma_streams_mask & dmastp->cmask) == 0U) &&
 8001b78:	4221      	tst	r1, r4
  }
#endif

  /* Putting the stream in a safe state.*/
  dmaStreamDisable(dmastp);
  dmastp->channel->CCR = STM32_DMA_CCR_RESET_VALUE;
 8001b7a:	f04f 0000 	mov.w	r0, #0
 8001b7e:	6010      	str	r0, [r2, #0]

  /* Enables the associated IRQ vector if not alread enabled and if a
     callback is defined.*/
  if (((dma_streams_mask & dmastp->cmask) == 0U) &&
 8001b80:	d116      	bne.n	8001bb0 <main+0x580>
      (func != NULL)) {
    nvicEnableVector(dmastp->vector, priority);
 8001b82:	7c98      	ldrb	r0, [r3, #18]
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8001b84:	2401      	movs	r4, #1
 8001b86:	0942      	lsrs	r2, r0, #5
 8001b88:	0092      	lsls	r2, r2, #2

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8001b8a:	f100 4560 	add.w	r5, r0, #3758096384	; 0xe0000000
 8001b8e:	f102 4260 	add.w	r2, r2, #3758096384	; 0xe0000000
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8001b92:	f000 001f 	and.w	r0, r0, #31
 8001b96:	f502 4261 	add.w	r2, r2, #57600	; 0xe100
 8001b9a:	fa04 f000 	lsl.w	r0, r4, r0

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8001b9e:	2760      	movs	r7, #96	; 0x60
 8001ba0:	f505 4561 	add.w	r5, r5, #57600	; 0xe100
 8001ba4:	f885 7300 	strb.w	r7, [r5, #768]	; 0x300
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8001ba8:	f8c2 0180 	str.w	r0, [r2, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8001bac:	6010      	str	r0, [r2, #0]
 8001bae:	685a      	ldr	r2, [r3, #4]
  }

  /* Marks the stream as allocated.*/
  dma_streams_mask |= (1U << dmastp->selfindex);
 8001bb0:	7c58      	ldrb	r0, [r3, #17]
 8001bb2:	2301      	movs	r3, #1
 8001bb4:	4083      	lsls	r3, r0
 8001bb6:	4319      	orrs	r1, r3
 8001bb8:	f8ca 1000 	str.w	r1, [sl]
                                 STM32_ADC_ADC1_DMA_IRQ_PRIORITY,
                                 (stm32_dmaisr_t)adc_lld_serve_rx_interrupt,
                                 (void *)adcp);
      osalDbgAssert(!b, "stream already allocated");
      dmaStreamSetPeripheral(adcp->dmastp, &ADC1->DR);
 8001bbc:	4b12      	ldr	r3, [pc, #72]	; (8001c08 <main+0x5d8>)
      rccEnableADC1(FALSE);
 8001bbe:	4911      	ldr	r1, [pc, #68]	; (8001c04 <main+0x5d4>)
      bool b = dmaStreamAllocate(adcp->dmastp,
                                 STM32_ADC_ADC1_DMA_IRQ_PRIORITY,
                                 (stm32_dmaisr_t)adc_lld_serve_rx_interrupt,
                                 (void *)adcp);
      osalDbgAssert(!b, "stream already allocated");
      dmaStreamSetPeripheral(adcp->dmastp, &ADC1->DR);
 8001bc0:	6093      	str	r3, [r2, #8]
      rccEnableADC1(FALSE);
 8001bc2:	6a0b      	ldr	r3, [r1, #32]
    }
#endif /* STM32_ADC_USE_ADC1 */

    ADC->CCR = (ADC->CCR & ADC_CCR_TSVREFE) | (STM32_ADC_ADCPRE << 16);
 8001bc4:	4811      	ldr	r0, [pc, #68]	; (8001c0c <main+0x5dc>)
                                 STM32_ADC_ADC1_DMA_IRQ_PRIORITY,
                                 (stm32_dmaisr_t)adc_lld_serve_rx_interrupt,
                                 (void *)adcp);
      osalDbgAssert(!b, "stream already allocated");
      dmaStreamSetPeripheral(adcp->dmastp, &ADC1->DR);
      rccEnableADC1(FALSE);
 8001bc6:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8001bca:	620b      	str	r3, [r1, #32]
    }
#endif /* STM32_ADC_USE_ADC1 */

    ADC->CCR = (ADC->CCR & ADC_CCR_TSVREFE) | (STM32_ADC_ADCPRE << 16);
 8001bcc:	6842      	ldr	r2, [r0, #4]

    /* ADC initial setup, starting the analog part here in order to reduce
       the latency when starting a conversion.*/
    adcp->adc->CR1 = 0;
 8001bce:	6ab3      	ldr	r3, [r6, #40]	; 0x28
 8001bd0:	2100      	movs	r1, #0
      dmaStreamSetPeripheral(adcp->dmastp, &ADC1->DR);
      rccEnableADC1(FALSE);
    }
#endif /* STM32_ADC_USE_ADC1 */

    ADC->CCR = (ADC->CCR & ADC_CCR_TSVREFE) | (STM32_ADC_ADCPRE << 16);
 8001bd2:	f402 0200 	and.w	r2, r2, #8388608	; 0x800000

    /* ADC initial setup, starting the analog part here in order to reduce
       the latency when starting a conversion.*/
    adcp->adc->CR1 = 0;
    adcp->adc->CR2 = 0;
    adcp->adc->CR2 = ADC_CR2_ADON;
 8001bd6:	2401      	movs	r4, #1
      dmaStreamSetPeripheral(adcp->dmastp, &ADC1->DR);
      rccEnableADC1(FALSE);
    }
#endif /* STM32_ADC_USE_ADC1 */

    ADC->CCR = (ADC->CCR & ADC_CCR_TSVREFE) | (STM32_ADC_ADCPRE << 16);
 8001bd8:	6042      	str	r2, [r0, #4]

    /* ADC initial setup, starting the analog part here in order to reduce
       the latency when starting a conversion.*/
    adcp->adc->CR1 = 0;
 8001bda:	6059      	str	r1, [r3, #4]
    adcp->adc->CR2 = 0;
 8001bdc:	6099      	str	r1, [r3, #8]
    adcp->adc->CR2 = ADC_CR2_ADON;
 8001bde:	609c      	str	r4, [r3, #8]
 8001be0:	e780      	b.n	8001ae4 <main+0x4b4>
 8001be2:	685a      	ldr	r2, [r3, #4]
 8001be4:	e7ea      	b.n	8001bbc <main+0x58c>
 8001be6:	bf00      	nop
 8001be8:	200008a8 	.word	0x200008a8
 8001bec:	08001091 	.word	0x08001091
 8001bf0:	200008e8 	.word	0x200008e8
 8001bf4:	08001051 	.word	0x08001051
 8001bf8:	20000a38 	.word	0x20000a38
 8001bfc:	40020400 	.word	0x40020400
 8001c00:	08000e51 	.word	0x08000e51
 8001c04:	40023800 	.word	0x40023800
 8001c08:	40012458 	.word	0x40012458
 8001c0c:	40012700 	.word	0x40012700

08001c10 <chThdCreateStatic.constprop.32>:
 * @return              The pointer to the @p thread_t structure allocated for
 *                      the thread into the working space area.
 *
 * @api
 */
thread_t *chThdCreateStatic(void *wsp, size_t size,
 8001c10:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8001c12:	4604      	mov	r4, r0
 8001c14:	2020      	movs	r0, #32
 8001c16:	f380 8811 	msr	BASEPRI, r0
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 8001c1a:	4d24      	ldr	r5, [pc, #144]	; (8001cac <chThdCreateStatic.constprop.32+0x9c>)

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 8001c1c:	3924      	subs	r1, #36	; 0x24
 8001c1e:	4e24      	ldr	r6, [pc, #144]	; (8001cb0 <chThdCreateStatic.constprop.32+0xa0>)
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 8001c20:	696f      	ldr	r7, [r5, #20]

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 8001c22:	1860      	adds	r0, r4, r1
 8001c24:	60e0      	str	r0, [r4, #12]
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
 8001c26:	f04f 0e02 	mov.w	lr, #2

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 8001c2a:	5063      	str	r3, [r4, r1]
 8001c2c:	6206      	str	r6, [r0, #32]
 8001c2e:	2100      	movs	r1, #0

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio) {
 8001c30:	69ae      	ldr	r6, [r5, #24]
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
 8001c32:	2301      	movs	r3, #1

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 8001c34:	6041      	str	r1, [r0, #4]
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
 8001c36:	60a2      	str	r2, [r4, #8]
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
 8001c38:	77a3      	strb	r3, [r4, #30]
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 8001c3a:	6167      	str	r7, [r4, #20]
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
  tp->p_flags = CH_FLAG_MODE_STATIC;
 8001c3c:	7761      	strb	r1, [r4, #29]
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
 8001c3e:	f884 e01c 	strb.w	lr, [r4, #28]
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 8001c42:	6125      	str	r5, [r4, #16]
  tp->p_flags = CH_FLAG_MODE_STATIC;
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
 8001c44:	63e2      	str	r2, [r4, #60]	; 0x3c
  tp->p_mtxlist = NULL;
 8001c46:	63a1      	str	r1, [r4, #56]	; 0x38
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->p_epending = (eventmask_t)0;
 8001c48:	6361      	str	r1, [r4, #52]	; 0x34
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
 8001c4a:	61a1      	str	r1, [r4, #24]
  REG_INSERT(tp);
 8001c4c:	613c      	str	r4, [r7, #16]
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  /* Storing the message to be retrieved by the target thread when it will
     restart execution.*/
  ntp->p_u.rdymsg = msg;
 8001c4e:	6221      	str	r1, [r4, #32]

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio) {
 8001c50:	68b0      	ldr	r0, [r6, #8]
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->p_waiting);
#endif
#if CH_CFG_USE_MESSAGES == TRUE
  queue_init(&tp->p_msgqueue);
 8001c52:	f104 0328 	add.w	r3, r4, #40	; 0x28
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->p_waiting);
 8001c56:	f104 0724 	add.w	r7, r4, #36	; 0x24
 8001c5a:	4282      	cmp	r2, r0
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8001c5c:	62a3      	str	r3, [r4, #40]	; 0x28
  tqp->p_prev = (thread_t *)tqp;
 8001c5e:	62e3      	str	r3, [r4, #44]	; 0x2c
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 8001c60:	616c      	str	r4, [r5, #20]
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->p_next = (thread_t *)tlp;
 8001c62:	6267      	str	r7, [r4, #36]	; 0x24
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
  cp = (thread_t *)&ch.rlist.r_queue;
 8001c64:	462b      	mov	r3, r5

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio) {
 8001c66:	d80e      	bhi.n	8001c86 <chThdCreateStatic.constprop.32+0x76>
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 8001c68:	7721      	strb	r1, [r4, #28]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
 8001c6a:	681b      	ldr	r3, [r3, #0]
  } while (cp->p_prio >= tp->p_prio);
 8001c6c:	6899      	ldr	r1, [r3, #8]
 8001c6e:	428a      	cmp	r2, r1
 8001c70:	d9fb      	bls.n	8001c6a <chThdCreateStatic.constprop.32+0x5a>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 8001c72:	685a      	ldr	r2, [r3, #4]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
 8001c74:	6023      	str	r3, [r4, #0]
  tp->p_prev = cp->p_prev;
 8001c76:	6062      	str	r2, [r4, #4]
  tp->p_prev->p_next = tp;
 8001c78:	6014      	str	r4, [r2, #0]
  cp->p_prev = tp;
 8001c7a:	605c      	str	r4, [r3, #4]
 8001c7c:	2300      	movs	r3, #0
 8001c7e:	f383 8811 	msr	BASEPRI, r3
  tp = chThdCreateI(wsp, size, prio, pf, arg);
  chSchWakeupS(tp, MSG_OK);
  chSysUnlock();

  return tp;
}
 8001c82:	4620      	mov	r0, r4
 8001c84:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 8001c86:	7731      	strb	r1, [r6, #28]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
 8001c88:	681b      	ldr	r3, [r3, #0]
  } while (cp->p_prio >= tp->p_prio);
 8001c8a:	689a      	ldr	r2, [r3, #8]
 8001c8c:	4290      	cmp	r0, r2
 8001c8e:	d9fb      	bls.n	8001c88 <chThdCreateStatic.constprop.32+0x78>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 8001c90:	685a      	ldr	r2, [r3, #4]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
    if (otp->p_prio == IDLEPRIO) {
      CH_CFG_IDLE_LEAVE_HOOK();
    }
#endif
    ntp->p_state = CH_STATE_CURRENT;
 8001c92:	2701      	movs	r7, #1
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
 8001c94:	6033      	str	r3, [r6, #0]
  tp->p_prev = cp->p_prev;
 8001c96:	6072      	str	r2, [r6, #4]
    if (otp->p_prio == IDLEPRIO) {
      CH_CFG_IDLE_LEAVE_HOOK();
    }
#endif
    ntp->p_state = CH_STATE_CURRENT;
    chSysSwitch(ntp, otp);
 8001c98:	4631      	mov	r1, r6
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = tp;
 8001c9a:	6016      	str	r6, [r2, #0]
    if (otp->p_prio == IDLEPRIO) {
      CH_CFG_IDLE_LEAVE_HOOK();
    }
#endif
    ntp->p_state = CH_STATE_CURRENT;
    chSysSwitch(ntp, otp);
 8001c9c:	4620      	mov	r0, r4
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = tp;
  cp->p_prev = tp;
 8001c9e:	605e      	str	r6, [r3, #4]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
    if (otp->p_prio == IDLEPRIO) {
      CH_CFG_IDLE_LEAVE_HOOK();
    }
#endif
    ntp->p_state = CH_STATE_CURRENT;
 8001ca0:	7727      	strb	r7, [r4, #28]
  if (ntp->p_prio <= currp->p_prio) {
    (void) chSchReadyI(ntp);
  }
  else {
    thread_t *otp = chSchReadyI(currp);
    setcurrp(ntp);
 8001ca2:	61ac      	str	r4, [r5, #24]
    if (otp->p_prio == IDLEPRIO) {
      CH_CFG_IDLE_LEAVE_HOOK();
    }
#endif
    ntp->p_state = CH_STATE_CURRENT;
    chSysSwitch(ntp, otp);
 8001ca4:	f7fe fab4 	bl	8000210 <_port_switch>
 8001ca8:	e7e8      	b.n	8001c7c <chThdCreateStatic.constprop.32+0x6c>
 8001caa:	bf00      	nop
 8001cac:	20000c18 	.word	0x20000c18
 8001cb0:	08000221 	.word	0x08000221
	...

08001cc0 <chTMStartMeasurementX.constprop.30>:
 *
 * @return              The realtime counter value.
 */
static inline rtcnt_t port_rt_get_counter_value(void) {

  return DWT->CYCCNT;
 8001cc0:	4b01      	ldr	r3, [pc, #4]	; (8001cc8 <chTMStartMeasurementX.constprop.30+0x8>)
 8001cc2:	685b      	ldr	r3, [r3, #4]
 *
 * @xclass
 */
NOINLINE void chTMStartMeasurementX(time_measurement_t *tmp) {

  tmp->last = chSysGetRealtimeCounterX();
 8001cc4:	6083      	str	r3, [r0, #8]
 8001cc6:	4770      	bx	lr
 8001cc8:	e0001000 	.word	0xe0001000
 8001ccc:	00000000 	.word	0x00000000

08001cd0 <chEvtBroadcastFlagsI.constprop.24>:
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
 8001cd0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  event_listener_t *elp;

  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->es_next;
 8001cd2:	4f17      	ldr	r7, [pc, #92]	; (8001d30 <chEvtBroadcastFlagsI.constprop.24+0x60>)
 8001cd4:	f857 4f04 	ldr.w	r4, [r7, #4]!
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 8001cd8:	42bc      	cmp	r4, r7
 8001cda:	d020      	beq.n	8001d1e <chEvtBroadcastFlagsI.constprop.24+0x4e>
 8001cdc:	4605      	mov	r5, r0
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
      ((tp->p_state == CH_STATE_WTANDEVT) &&
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask))) {
    tp->p_u.rdymsg = MSG_OK;
 8001cde:	2600      	movs	r6, #0
 8001ce0:	e002      	b.n	8001ce8 <chEvtBroadcastFlagsI.constprop.24+0x18>
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
        ((elp->el_flags & elp->el_wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->el_listener, elp->el_events);
    }
    elp = elp->el_next;
 8001ce2:	6824      	ldr	r4, [r4, #0]
  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->es_next;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 8001ce4:	42bc      	cmp	r4, r7
 8001ce6:	d01a      	beq.n	8001d1e <chEvtBroadcastFlagsI.constprop.24+0x4e>
  /*lint -restore*/
    elp->el_flags |= flags;
 8001ce8:	68e3      	ldr	r3, [r4, #12]
 8001cea:	432b      	orrs	r3, r5
 8001cec:	60e3      	str	r3, [r4, #12]
    /* When flags == 0 the thread will always be signaled because the
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
 8001cee:	b115      	cbz	r5, 8001cf6 <chEvtBroadcastFlagsI.constprop.24+0x26>
 8001cf0:	6922      	ldr	r2, [r4, #16]
 8001cf2:	4213      	tst	r3, r2
 8001cf4:	d0f5      	beq.n	8001ce2 <chEvtBroadcastFlagsI.constprop.24+0x12>
        ((elp->el_flags & elp->el_wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->el_listener, elp->el_events);
 8001cf6:	6860      	ldr	r0, [r4, #4]
void chEvtSignalI(thread_t *tp, eventmask_t events) {

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
 8001cf8:	68a1      	ldr	r1, [r4, #8]
 8001cfa:	6b43      	ldr	r3, [r0, #52]	; 0x34
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 8001cfc:	7f02      	ldrb	r2, [r0, #28]
void chEvtSignalI(thread_t *tp, eventmask_t events) {

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
 8001cfe:	430b      	orrs	r3, r1
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 8001d00:	2a0a      	cmp	r2, #10
void chEvtSignalI(thread_t *tp, eventmask_t events) {

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
 8001d02:	6343      	str	r3, [r0, #52]	; 0x34
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 8001d04:	d00c      	beq.n	8001d20 <chEvtBroadcastFlagsI.constprop.24+0x50>
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
 8001d06:	2a0b      	cmp	r2, #11
 8001d08:	d1eb      	bne.n	8001ce2 <chEvtBroadcastFlagsI.constprop.24+0x12>
      ((tp->p_state == CH_STATE_WTANDEVT) &&
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask))) {
 8001d0a:	6a02      	ldr	r2, [r0, #32]

  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
      ((tp->p_state == CH_STATE_WTANDEVT) &&
 8001d0c:	ea32 0303 	bics.w	r3, r2, r3
 8001d10:	d1e7      	bne.n	8001ce2 <chEvtBroadcastFlagsI.constprop.24+0x12>
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask))) {
    tp->p_u.rdymsg = MSG_OK;
 8001d12:	6206      	str	r6, [r0, #32]
    (void) chSchReadyI(tp);
 8001d14:	f7fe ff5c 	bl	8000bd0 <chSchReadyI>
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
        ((elp->el_flags & elp->el_wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->el_listener, elp->el_events);
    }
    elp = elp->el_next;
 8001d18:	6824      	ldr	r4, [r4, #0]
  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->es_next;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 8001d1a:	42bc      	cmp	r4, r7
 8001d1c:	d1e4      	bne.n	8001ce8 <chEvtBroadcastFlagsI.constprop.24+0x18>
 8001d1e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 8001d20:	6a02      	ldr	r2, [r0, #32]
 8001d22:	4213      	tst	r3, r2
 8001d24:	d0dd      	beq.n	8001ce2 <chEvtBroadcastFlagsI.constprop.24+0x12>
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
      ((tp->p_state == CH_STATE_WTANDEVT) &&
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask))) {
    tp->p_u.rdymsg = MSG_OK;
 8001d26:	6206      	str	r6, [r0, #32]
    (void) chSchReadyI(tp);
 8001d28:	f7fe ff52 	bl	8000bd0 <chSchReadyI>
 8001d2c:	e7f4      	b.n	8001d18 <chEvtBroadcastFlagsI.constprop.24+0x48>
 8001d2e:	bf00      	nop
 8001d30:	20000ba0 	.word	0x20000ba0
	...

08001d40 <_pal_lld_setgroupmode.constprop.4>:
 * @param[in] mask      the group mask
 * @param[in] mode      the mode
 *
 * @notapi
 */
void _pal_lld_setgroupmode(ioportid_t port,
 8001d40:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}

      altrmask = altr << ((bit & 7) * 4);
      m1 = 1 << bit;
      m2 = 3 << (bit * 2);
      m4 = 15 << ((bit & 7) * 4);
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
 8001d44:	4b2f      	ldr	r3, [pc, #188]	; (8001e04 <_pal_lld_setgroupmode.constprop.4+0xc4>)
  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
  uint32_t otyper  = (mode & PAL_STM32_OTYPE_MASK) >> 2;
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
  uint32_t pupdr   = (mode & PAL_STM32_PUPDR_MASK) >> 5;
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
  uint32_t bit     = 0;
 8001d46:	2400      	movs	r4, #0
 */
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {

  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
 8001d48:	2502      	movs	r5, #2
  uint32_t bit     = 0;
  while (true) {
    if ((mask & 1) != 0) {
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
 8001d4a:	f04f 0c07 	mov.w	ip, #7
      m1 = 1 << bit;
      m2 = 3 << (bit * 2);
      m4 = 15 << ((bit & 7) * 4);
 8001d4e:	f04f 0e0f 	mov.w	lr, #15
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
 8001d52:	2701      	movs	r7, #1
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 8001d54:	2603      	movs	r6, #3
 8001d56:	e009      	b.n	8001d6c <_pal_lld_setgroupmode.constprop.4+0x2c>
      else {
        /* If going into a non-alternate mode then the mode is switched
           before setting the alternate mode in order to avoid glitches.*/
        port->MODER   = (port->MODER & ~m2) | moder;
        if (bit < 8)
          port->AFRL = (port->AFRL & ~m4) | altrmask;
 8001d58:	6a19      	ldr	r1, [r3, #32]
 8001d5a:	ea21 0202 	bic.w	r2, r1, r2
 8001d5e:	ea42 0208 	orr.w	r2, r2, r8
 8001d62:	621a      	str	r2, [r3, #32]
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
      }
    }
    mask >>= 1;
    if (!mask)
 8001d64:	0840      	lsrs	r0, r0, #1
 8001d66:	d033      	beq.n	8001dd0 <_pal_lld_setgroupmode.constprop.4+0x90>
      return;
    otyper <<= 1;
    ospeedr <<= 2;
    pupdr <<= 2;
    moder <<= 2;
 8001d68:	00ad      	lsls	r5, r5, #2
    bit++;
 8001d6a:	3401      	adds	r4, #1
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
  uint32_t pupdr   = (mode & PAL_STM32_PUPDR_MASK) >> 5;
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
  uint32_t bit     = 0;
  while (true) {
    if ((mask & 1) != 0) {
 8001d6c:	07c2      	lsls	r2, r0, #31
 8001d6e:	d5f9      	bpl.n	8001d64 <_pal_lld_setgroupmode.constprop.4+0x24>
      altrmask = altr << ((bit & 7) * 4);
      m1 = 1 << bit;
      m2 = 3 << (bit * 2);
      m4 = 15 << ((bit & 7) * 4);
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 8001d70:	0061      	lsls	r1, r4, #1
 8001d72:	fa06 f101 	lsl.w	r1, r6, r1
 8001d76:	43c9      	mvns	r1, r1

      altrmask = altr << ((bit & 7) * 4);
      m1 = 1 << bit;
      m2 = 3 << (bit * 2);
      m4 = 15 << ((bit & 7) * 4);
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
 8001d78:	685a      	ldr	r2, [r3, #4]
 8001d7a:	fa07 f804 	lsl.w	r8, r7, r4
 8001d7e:	ea22 0208 	bic.w	r2, r2, r8
 8001d82:	605a      	str	r2, [r3, #4]
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 8001d84:	f8d3 8008 	ldr.w	r8, [r3, #8]
  uint32_t bit     = 0;
  while (true) {
    if ((mask & 1) != 0) {
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
 8001d88:	f004 0207 	and.w	r2, r4, #7
      m1 = 1 << bit;
      m2 = 3 << (bit * 2);
      m4 = 15 << ((bit & 7) * 4);
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 8001d8c:	ea08 0801 	and.w	r8, r8, r1
 8001d90:	f8c3 8008 	str.w	r8, [r3, #8]
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
 8001d94:	f8d3 800c 	ldr.w	r8, [r3, #12]
  uint32_t bit     = 0;
  while (true) {
    if ((mask & 1) != 0) {
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
 8001d98:	0092      	lsls	r2, r2, #2
      m1 = 1 << bit;
      m2 = 3 << (bit * 2);
      m4 = 15 << ((bit & 7) * 4);
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
 8001d9a:	ea01 0808 	and.w	r8, r1, r8
      if (moder == PAL_STM32_MODE_ALTERNATE) {
 8001d9e:	2d02      	cmp	r5, #2
      m1 = 1 << bit;
      m2 = 3 << (bit * 2);
      m4 = 15 << ((bit & 7) * 4);
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
 8001da0:	f8c3 800c 	str.w	r8, [r3, #12]
  uint32_t bit     = 0;
  while (true) {
    if ((mask & 1) != 0) {
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
 8001da4:	fa0c f802 	lsl.w	r8, ip, r2
      m1 = 1 << bit;
      m2 = 3 << (bit * 2);
      m4 = 15 << ((bit & 7) * 4);
 8001da8:	fa0e f202 	lsl.w	r2, lr, r2
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
      if (moder == PAL_STM32_MODE_ALTERNATE) {
 8001dac:	d012      	beq.n	8001dd4 <_pal_lld_setgroupmode.constprop.4+0x94>
        port->MODER   = (port->MODER & ~m2) | moder;
      }
      else {
        /* If going into a non-alternate mode then the mode is switched
           before setting the alternate mode in order to avoid glitches.*/
        port->MODER   = (port->MODER & ~m2) | moder;
 8001dae:	f8d3 9000 	ldr.w	r9, [r3]
        if (bit < 8)
 8001db2:	2c07      	cmp	r4, #7
        port->MODER   = (port->MODER & ~m2) | moder;
      }
      else {
        /* If going into a non-alternate mode then the mode is switched
           before setting the alternate mode in order to avoid glitches.*/
        port->MODER   = (port->MODER & ~m2) | moder;
 8001db4:	ea01 0109 	and.w	r1, r1, r9
 8001db8:	ea41 0105 	orr.w	r1, r1, r5
 8001dbc:	6019      	str	r1, [r3, #0]
        if (bit < 8)
 8001dbe:	d9cb      	bls.n	8001d58 <_pal_lld_setgroupmode.constprop.4+0x18>
          port->AFRL = (port->AFRL & ~m4) | altrmask;
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
 8001dc0:	6a59      	ldr	r1, [r3, #36]	; 0x24
      }
    }
    mask >>= 1;
    if (!mask)
 8001dc2:	0840      	lsrs	r0, r0, #1
           before setting the alternate mode in order to avoid glitches.*/
        port->MODER   = (port->MODER & ~m2) | moder;
        if (bit < 8)
          port->AFRL = (port->AFRL & ~m4) | altrmask;
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
 8001dc4:	ea21 0202 	bic.w	r2, r1, r2
 8001dc8:	ea42 0208 	orr.w	r2, r2, r8
 8001dcc:	625a      	str	r2, [r3, #36]	; 0x24
      }
    }
    mask >>= 1;
    if (!mask)
 8001dce:	d1cb      	bne.n	8001d68 <_pal_lld_setgroupmode.constprop.4+0x28>
 8001dd0:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
      if (moder == PAL_STM32_MODE_ALTERNATE) {
        /* If going in alternate mode then the alternate number is set
           before switching mode in order to avoid glitches.*/
        if (bit < 8)
 8001dd4:	2c07      	cmp	r4, #7
 8001dd6:	d80c      	bhi.n	8001df2 <_pal_lld_setgroupmode.constprop.4+0xb2>
          port->AFRL = (port->AFRL & ~m4) | altrmask;
 8001dd8:	f8d3 9020 	ldr.w	r9, [r3, #32]
 8001ddc:	ea29 0202 	bic.w	r2, r9, r2
 8001de0:	ea42 0208 	orr.w	r2, r2, r8
 8001de4:	621a      	str	r2, [r3, #32]
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
        port->MODER   = (port->MODER & ~m2) | moder;
 8001de6:	681a      	ldr	r2, [r3, #0]
 8001de8:	4011      	ands	r1, r2
 8001dea:	f041 0102 	orr.w	r1, r1, #2
 8001dee:	6019      	str	r1, [r3, #0]
 8001df0:	e7b8      	b.n	8001d64 <_pal_lld_setgroupmode.constprop.4+0x24>
        /* If going in alternate mode then the alternate number is set
           before switching mode in order to avoid glitches.*/
        if (bit < 8)
          port->AFRL = (port->AFRL & ~m4) | altrmask;
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
 8001df2:	f8d3 9024 	ldr.w	r9, [r3, #36]	; 0x24
 8001df6:	ea29 0202 	bic.w	r2, r9, r2
 8001dfa:	ea42 0208 	orr.w	r2, r2, r8
 8001dfe:	625a      	str	r2, [r3, #36]	; 0x24
 8001e00:	e7f1      	b.n	8001de6 <_pal_lld_setgroupmode.constprop.4+0xa6>
 8001e02:	bf00      	nop
 8001e04:	40020000 	.word	0x40020000
	...
 8001e10:	00000a0d 	.word	0x00000a0d
	...

08001e20 <ram_areas>:
 8001e20:	080020b8 20000d68 20000d68 20000d68     . ..h.. h.. h.. 
 8001e30:	080020b8 00000000 00000000 00000000     . ..............
 8001e40:	080020b8 00000000 00000000 00000000     . ..............
 8001e50:	080020b8 00000000 00000000 00000000     . ..............
 8001e60:	080020b8 00000000 00000000 00000000     . ..............
 8001e70:	080020b8 00000000 00000000 00000000     . ..............
 8001e80:	080020b8 00000000 00000000 00000000     . ..............
 8001e90:	080020b8 00000000 00000000 00000000     . ..............

08001ea0 <convgrp.6898>:
 8001ea0:	00010000 00000000 00000000 01000000     ................
 8001eb0:	40000010 00000000 00000000 00000002     ...@............
	...
 8001ed0:	00000001 00000000 00000000 00000000     ................

08001ee0 <_stm32_dma_streams>:
 8001ee0:	40026000 40026008 00000001 00000000     .`.@.`.@........
 8001ef0:	000b0000 40026000 4002601c 00000002     .....`.@.`.@....
 8001f00:	00000000 000c0104 40026000 40026030     .........`.@0`.@
 8001f10:	00000004 00000000 000d0208 40026000     .............`.@
 8001f20:	40026044 00000008 00000000 000e030c     D`.@............
 8001f30:	40026000 40026058 00000010 00000000     .`.@X`.@........
 8001f40:	000f0410 40026000 4002606c 00000020     .....`.@l`.@ ...
 8001f50:	00000000 00100514 40026000 40026080     .........`.@.`.@
 8001f60:	00000040 00000000 00110618 00000000     @...............

08001f70 <ch_debug>:
 8001f70:	6e69616d 18431600 08440204 1814100c     main..C...D.....
 8001f80:	1e1d1c00 00000000 00000000 00000000     ................
 8001f90:	6e696c62 0072656b 2d2d2d2d 2d2d2d2d     blinker.--------
 8001fa0:	2d2d2d2d 00000000 2d2d2d2d 2d2d2d2d     ----....--------
 8001fb0:	2d2d2d2d 2d7c2d2d 00000000 2d2d2d2d     ------|-....----
 8001fc0:	2d2d2d2d 2d2d2d2d 2d7c2d2d 00002d2d     ----------|---..
 8001fd0:	2d2d2d2d 2d2d2d2d 2d2d2d2d 2d7c2d2d     --------------|-
 8001fe0:	2d2d2d2d 00002d2d 2d2d2d2d 2d2d2d2d     ------..--------
 8001ff0:	2d2d2d2d 2d7c2d2d 2d2d2d2d 2d2d2d2d     ------|---------
 8002000:	0000002d 2d2d2d2d 2d2d2d2d 2d2d2d2d     -...------------
 8002010:	2d7c2d2d 2d2d2d2d 2d2d2d2d 2d2d2d2d     --|-------------
 8002020:	002d2d2d 2d2d2d2d 2d2d2d2d 2d2d2d2d     ---.------------
 8002030:	2d7c2d2d 2d2d2d2d 2d2d2d2d 2d2d2d2d     --|-------------
 8002040:	2d2d2d2d 00002d2d 2d2d2d2d 2d2d2d2d     ------..--------
 8002050:	2d2d2d2d 2d7c2d2d 2d2d2d2d 2d2d2d2d     ------|---------
 8002060:	2d2d2d2d 2d2d2d2d 2d2d2d2d 00002d2d     --------------..
 8002070:	656c6469 00000000 00000000 00000000     idle............

08002080 <vmt>:
 8002080:	08000a11 08000b31 08000a91 08000ba1     ....1...........
 8002090:	08000a81 08000b91 08000a01 08000b21     ............!...
